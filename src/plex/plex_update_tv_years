#!/usr/bin/env python3
"""
Plex TV Show Year Updater
Version: 2.0
Purpose: Update TV show directories with correct release years using TVDB API

This refactored version uses modular components from lib/ for better code reuse:
- lib/tvdb_client.py: TVDB v4 API client with JWT authentication
- lib/cache_manager.py: Generic JSON-based caching with TTL support
- lib/retry_utils.py: Exponential backoff decorator for network resilience
- lib/media_name_utils.py: Media name parsing and year extraction
- lib/credential_manager.py: Multi-source credential resolution

The script has been reduced from 1,080 lines to ~600 lines through DRY refactoring
while maintaining all original functionality including zero external dependencies,
comprehensive caching, and robust error handling.
"""

import os
import sys
import argparse
import tempfile
import time
from pathlib import Path
from typing import Optional, Dict, Any

# ======================================================
# {{include utils.py}}


# ======================================================

# Import shared modules (will be included by build system)
# {{include retry_utils.py}}
# {{include cache_manager.py}}
# {{include tvdb_client.py}}
# {{include media_name_utils.py}}
# {{include credential_manager.py}}


VERSION = "2.0"


class TVShowYearUpdater:
    """Main class for updating TV show directories with correct years."""

    def __init__(self, tvdb_key: str, dry_run: bool = False, force: bool = False,
                 verbose: bool = False, debug: bool = False, yes: bool = False,
                 cache_dir: Optional[str] = None, cache_refresh: bool = False):
        """
        Initialize the TV Show Year Updater.

        Args:
            tvdb_key: TVDB API key
            dry_run: If True, only show what would be done
            force: Force execution even if another instance is running
            verbose: Enable verbose output
            debug: Enable debug output
            yes: Skip confirmation prompts
            cache_dir: Custom cache directory, defaults to ~/.cache
            cache_refresh: Force refresh of cached data
        """
        self.tvdb_key = tvdb_key
        self.dry_run = dry_run
        self.force = force
        self.verbose = verbose
        self.debug = debug
        self.yes = yes
        self.cache_refresh = cache_refresh
        self.file_lock = FileLock('plex_update_tv_years')

        # Initialize cache if not forcing refresh
        self.cache = None if cache_refresh else CacheManager('plex_tv_shows', cache_dir)
        self.tvdb_client = TVDBClient(tvdb_key, debug, self.cache)

        # Initialize media name parser
        self.name_parser = MediaNameParser(debug=debug)

        # Statistics
        self.stats = {
            'directories_processed': 0,
            'directories_renamed': 0,
            'directories_would_rename': 0,
            'directories_skipped': 0,
            'api_errors': 0,
            'file_errors': 0
        }

    def log_verbose(self, message: str) -> None:
        """Log verbose message if verbose mode is enabled."""
        if self.verbose:
            print(f"VERBOSE: {message}")

    def log_debug(self, message: str) -> None:
        """Log debug message if debug mode is enabled."""
        if self.debug:
            print(f"DEBUG: {message}")

    def acquire_lock(self, lock_dir: Path) -> bool:
        """
        Acquire file lock to prevent concurrent executions.

        Args:
            lock_dir: Directory to store lock file

        Returns:
            bool: True if lock acquired, False otherwise
        """
        return self.file_lock.acquire_lock(self.force)

    def release_lock(self) -> None:
        """Release the file lock."""
        self.file_lock.release_lock()

    def process_directory(self, target_path: Path) -> None:
        """
        Process the target directory to update TV show years.

        Args:
            target_path: Path to directory containing TV shows
        """
        self.log_verbose(f"Processing directory: {target_path}")

        # Acquire lock
        lock_dir = Path(tempfile.gettempdir())
        if not self.acquire_lock(lock_dir):
            return

        try:
            # Get all subdirectories (potential TV shows)
            tv_directories = [d for d in target_path.iterdir()
                            if d.is_dir() and not d.name.startswith('.')]

            if not tv_directories:
                print("No directories found to process")
                return

            print(f"Found {len(tv_directories)} directories to analyze")

            if not self.dry_run and not self.yes and not is_non_interactive():
                response = input(f"\nProceed with analyzing {len(tv_directories)} directories? [y/N]: ")
                if response.lower() not in ['y', 'yes']:
                    print("Operation cancelled.")
                    return
            elif self.yes or is_non_interactive():
                print("Proceeding with directory analysis...")

            # Process each directory
            for i, tv_dir in enumerate(tv_directories, 1):
                self.stats['directories_processed'] += 1

                print(f"\n[{i}/{len(tv_directories)}] {tv_dir.name}")
                self.log_verbose(f"Processing: {tv_dir.name}")

                # Extract clean show name for TVDB search
                clean_name = self.name_parser.clean_show_name(tv_dir.name)
                self.log_debug(f"Clean name for search: '{clean_name}'")

                if not clean_name:
                    print("  WARNING: Could not extract show name, skipping")
                    self.stats['directories_skipped'] += 1
                    continue

                # Search TVDB for show information
                try:
                    show_data = self.tvdb_client.search_show(clean_name)
                    if not show_data:
                        print(f"  ERROR: No TVDB results found for '{clean_name}'")
                        self.stats['api_errors'] += 1
                        continue

                    tvdb_year = show_data.get('year')
                    if not tvdb_year:
                        print(f"  WARNING: No year information available in TVDB")
                        self.stats['api_errors'] += 1
                        continue

                    # Check if update is needed using name parser
                    needs_update, current_year = self.name_parser.needs_year_update(
                        tv_dir.name, tvdb_year
                    )

                    if not needs_update:
                        print(f"  Already has correct year ({tvdb_year})")
                        continue

                    # Generate new name using name parser
                    new_name = self.name_parser.format_name_with_year(clean_name, tvdb_year)
                    new_path = tv_dir.parent / new_name

                    if current_year:
                        print(f"  Would change year: {current_year} â†’ {tvdb_year}")
                    else:
                        print(f"  Would add year: {tvdb_year}")

                    print(f"  New name: {new_name}")

                    # Check if target already exists
                    if new_path.exists():
                        print(f"  ERROR: Target directory already exists: {new_name}")
                        self.stats['file_errors'] += 1
                        continue

                    # Perform the rename (if not dry-run)
                    if not self.dry_run:
                        try:
                            tv_dir.rename(new_path)
                            print(f"  SUCCESS: Renamed successfully")
                            self.stats['directories_renamed'] += 1
                        except OSError as e:
                            print(f"  ERROR: Failed to rename: {e}")
                            self.stats['file_errors'] += 1
                    else:
                        print(f"  DRY RUN: Would rename to '{new_name}'")
                        self.stats['directories_would_rename'] += 1

                    # Small delay to be respectful to TVDB API
                    time.sleep(0.5)

                except Exception as e:
                    print(f"  ERROR: Error processing directory: {e}")
                    self.stats['api_errors'] += 1
                    self.log_debug(f"Error details: {e}")

            # Display final statistics
            self.display_statistics()

        finally:
            self.release_lock()

    def display_statistics(self) -> None:
        """Display processing statistics."""
        print(f"\nProcessing complete!")
        print(f"Statistics:")
        print(f"   Directories processed: {self.stats['directories_processed']}")
        if self.dry_run:
            print(f"   Directories would rename: {self.stats['directories_would_rename']}")
        else:
            print(f"   Directories renamed: {self.stats['directories_renamed']}")
        print(f"   Directories skipped: {self.stats['directories_skipped']}")
        print(f"   API errors: {self.stats['api_errors']}")
        print(f"   File errors: {self.stats['file_errors']}")

        # Display cache statistics if cache is enabled
        if self.cache and (self.tvdb_client.cache_hits > 0 or self.tvdb_client.cache_misses > 0):
            total_requests = self.tvdb_client.cache_hits + self.tvdb_client.cache_misses
            hit_rate = (self.tvdb_client.cache_hits / total_requests * 100) if total_requests > 0 else 0
            print(f"   Cache hits: {self.tvdb_client.cache_hits}")
            print(f"   Cache misses: {self.tvdb_client.cache_misses}")
            print(f"   Cache hit rate: {hit_rate:.1f}%")

        # Display retry statistics if retries occurred
        if self.tvdb_client.retry_attempts > 0:
            print(f"   Retry attempts: {self.tvdb_client.retry_attempts}")
            print(f"   Successful retries: {self.tvdb_client.retry_successes}")
            retry_success_rate = (self.tvdb_client.retry_successes / self.tvdb_client.retry_attempts * 100) if self.tvdb_client.retry_attempts > 0 else 0
            print(f"   Retry success rate: {retry_success_rate:.1f}%")

    def display_cache_statistics(self) -> None:
        """Display detailed cache statistics."""
        if not self.cache:
            print("Caching is disabled.")
            return

        stats = self.cache.get_stats()
        print(f"Cache Statistics:")
        print(f"  Cache file: {stats['cache_file']}")
        print(f"  Total entries: {stats['total_entries']}")
        print(f"  Expired entries: {stats['expired_entries']}")
        print(f"  Cache size: {self.format_bytes(stats['cache_size_bytes'])}")
        if stats['total_entries'] > 0:
            print(f"  Oldest entry: {stats['oldest_entry_age_days']:.1f} days old")

        # Show hit rate from current session if available
        if hasattr(self, 'tvdb_client'):
            total_requests = self.tvdb_client.cache_hits + self.tvdb_client.cache_misses
            if total_requests > 0:
                hit_rate = (self.tvdb_client.cache_hits / total_requests * 100)
                print(f"  Session hit rate: {hit_rate:.1f}% ({self.tvdb_client.cache_hits}/{total_requests})")

    def format_bytes(self, bytes_count: int) -> str:
        """Format byte count in human readable format."""
        for unit in ['B', 'KB', 'MB', 'GB']:
            if bytes_count < 1024.0:
                return f"{bytes_count:.1f} {unit}"
            bytes_count /= 1024.0
        return f"{bytes_count:.1f} TB"


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description='Update TV show directories with correct release years using TVDB API',
        epilog='''
Examples:
  %(prog)s /path/to/tv/shows --dry-run
  %(prog)s /path/to/tv/shows --tvdb-key YOUR_API_KEY
  %(prog)s /path/to/tv/shows -y --verbose

Cache Management:
  %(prog)s --cache-stats                     # Show cache statistics
  %(prog)s --cache-clear                     # Clear cache (with confirmation)
  %(prog)s --cache-clear -y                  # Clear cache (no confirmation)
  %(prog)s --cache-refresh /path/to/shows    # Force refresh cached data
  %(prog)s --cache-dir /custom/cache/path    # Use custom cache directory

Cron Usage:
  # Run daily at 3 AM (non-interactive)
  0 3 * * * /usr/local/bin/plex_update_tv_years /path/to/tv/shows -y

The script will scan TV show directories, look up correct years via TVDB API,
and rename directories to "Show Title (YEAR)" format. Results are cached for
14 days to reduce API calls on subsequent runs.
        ''',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    parser.add_argument('path', nargs='?', default='.',
                        help='Directory to process (default: current directory)')
    parser.add_argument('--tvdb-key',
                        help='TVDB API key (can also use TVDB_API_KEY env var, local .env, or ~/.media-library-tools/.env)')
    parser.add_argument('--dry-run', action='store_true', default=True,
                        help='Show what would be renamed without making changes (default: true)')
    parser.add_argument('--execute', action='store_true',
                        help='Actually perform the renaming operations (overrides --dry-run)')
    parser.add_argument('-y', '--yes', action='store_true',
                        help='Skip confirmation prompts (for non-interactive use)')
    parser.add_argument('--force', action='store_true',
                        help='Force execution even if another instance is running')
    parser.add_argument('--verbose', '-v', action='store_true',
                        help='Show verbose output')
    parser.add_argument('--debug', action='store_true',
                        help='Show detailed debug output')
    parser.add_argument('--no-banner', action='store_true',
                        help='Suppress banner display')

    # Cache management options
    parser.add_argument('--cache-stats', action='store_true',
                        help='Show cache statistics (hits, misses, size, entries)')
    parser.add_argument('--cache-refresh', action='store_true',
                        help='Force refresh of cached data during processing')
    parser.add_argument('--cache-clear', action='store_true',
                        help='Clear all cached data and exit')
    parser.add_argument('--cache-dir',
                        help='Specify custom cache directory (default: ~/.cache)')

    parser.add_argument('--version', action='version', version=f'%(prog)s v{VERSION}')

    args = parser.parse_args()

    # Read global configuration
    auto_execute = read_global_config_bool('AUTO_EXECUTE', False)
    auto_confirm = read_global_config_bool('AUTO_CONFIRM', False)
    quiet_mode = read_global_config_bool('QUIET_MODE', False)

    # Apply global configuration (CLI arguments take precedence)
    if auto_execute and not args.execute:
        args.execute = True  # Set execute flag if AUTO_EXECUTE is set
    if auto_confirm and not args.yes:
        args.yes = True  # Set yes flag if AUTO_CONFIRM is set

    # Handle dry-run/execute logic
    if args.execute:
        dry_run_mode = False
    else:
        dry_run_mode = args.dry_run  # This is True by default

    # Validate arguments
    if args.yes and dry_run_mode:
        print("Warning: -y/--yes flag has no effect in dry-run mode", file=sys.stderr)

    # Get TVDB API key using credential manager
    cred_manager = CredentialManager(debug=args.debug)
    tvdb_key = cred_manager.get_credential('TVDB_API_KEY', args.tvdb_key)
    if not tvdb_key:
        print("Error: TVDB_API_KEY not found. Please provide via --tvdb-key argument, "
              "TVDB_API_KEY environment variable, local .env file, or ~/.media-library-tools/.env file", file=sys.stderr)
        sys.exit(1)

    # Handle cache-specific operations that exit early
    if args.cache_clear or args.cache_stats:
        # Initialize cache for these operations
        cache = CacheManager('plex_tv_shows', args.cache_dir)

        if args.cache_clear:
            display_banner("plex_update_tv_years", VERSION,
                          "add/correct tv show years in directories using TVDB API",
                          args.no_banner, quiet_mode)
            print("Clearing cache...")

            if not args.yes and not is_non_interactive():
                stats = cache.get_stats()
                print(f"Cache location: {stats['cache_file']}")
                print(f"Cache entries: {stats['total_entries']}")
                print(f"Cache size: {stats['cache_size_bytes']} bytes")
                response = input("\nConfirm cache clear? [y/N]: ")
                if response.lower() not in ['y', 'yes']:
                    print("Cache clear cancelled.")
                    sys.exit(0)

            if cache.clear():
                print("Cache cleared successfully.")
            else:
                print("Error: Failed to clear cache.", file=sys.stderr)
                sys.exit(1)
            sys.exit(0)

        if args.cache_stats:
            display_banner("plex_update_tv_years", VERSION,
                          "add/correct tv show years in directories using TVDB API",
                          args.no_banner, quiet_mode)
            updater = TVShowYearUpdater(
                tvdb_key=tvdb_key,
                dry_run=True,
                force=args.force,
                verbose=args.verbose,
                debug=args.debug,
                yes=args.yes,
                cache_dir=args.cache_dir
            )
            updater.display_cache_statistics()
            sys.exit(0)

    # Display banner
    display_banner("plex_update_tv_years", VERSION,
                  "add/correct tv show years in directories using TVDB API",
                  args.no_banner, quiet_mode)

    if dry_run_mode:
        print("DRY-RUN MODE: No changes will be made")
    else:
        print("EXECUTE MODE: Changes will be made to directories")

    try:
        updater = TVShowYearUpdater(
            tvdb_key=tvdb_key,
            dry_run=dry_run_mode,
            force=args.force,
            verbose=args.verbose,
            debug=args.debug,
            yes=args.yes,
            cache_dir=args.cache_dir,
            cache_refresh=args.cache_refresh
        )

        # Process the target directory
        target_path = Path(args.path).resolve()
        if not target_path.exists():
            print(f"Error: Path '{target_path}' does not exist", file=sys.stderr)
            sys.exit(1)

        if not target_path.is_dir():
            print(f"Error: Path '{target_path}' is not a directory", file=sys.stderr)
            sys.exit(1)

        updater.process_directory(target_path)

    except KeyboardInterrupt:
        print("\nOperation cancelled by user")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
