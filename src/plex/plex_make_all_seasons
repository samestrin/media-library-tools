#!/usr/bin/env python3
"""
Plex Season Organizer (Batch)

A comprehensive tool for organizing TV show episodes into season directories across
multiple show directories. This script processes all subdirectories in a target
directory and organizes video files into proper season structures.

Features:
- Batch processing of multiple TV show directories
- System trash cleanup (.DS_Store, Thumbs.db, etc.)
- Parallel processing for improved performance
- Progress tracking and detailed reporting
- File-based locking mechanism
- Comprehensive error handling and recovery
- Dry-run mode for safe testing
- Cron-friendly operation

Author: Media Library Tools Project
Version: 2.2.0
"""

import argparse
import concurrent.futures
import os
import re
import shutil
import sys
import time
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union

VERSION = "2.2.0"

# ======================================================
# {{include utils.py}}


# ======================================================
# {{include lib/cleanup.py}}


# ======================================================
# {{include lib/season_detection.py}}


# ======================================================











class SeasonOrganizer(BaseSeasonDetector):
    """Organizes video files into season directories."""

    def __init__(self, dry_run: bool = False, depth: int = 1, enable_cleanup: bool = False, verbose: bool = False):
        # Initialize base season detector
        super().__init__(config={})

        self.dry_run = dry_run
        self.depth = depth
        self.enable_cleanup = enable_cleanup
        self.verbose = verbose
        self.video_extensions = {
            '.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm',
            '.m4v', '.mpg', '.mpeg', '.3gp', '.ogv', '.ts', '.m2ts'
        }

        # Episode extraction patterns (for episode numbers)
        self.episode_patterns = [
            re.compile(r'[Ss]\d{1,4}[Ee](\d{1,3})', re.IGNORECASE),  # S01E05
            re.compile(r'Episode\s*(\d{1,3})', re.IGNORECASE),       # Episode 5
            re.compile(r'\d{1,3}x(\d{1,3})', re.IGNORECASE),         # 1x05
        ]
    
    def is_video_file(self, file_path: Path) -> bool:
        """Check if file is a video file based on extension."""
        return file_path.suffix.lower() in self.video_extensions
    
    def find_video_files_with_depth(self, source_dir: Path, max_depth: int) -> List[Path]:
        """Find video files up to a specified depth in the directory structure.
        
        Args:
            source_dir: The directory to search in
            max_depth: Maximum depth to search (1 = only immediate files, 2 = immediate subdirs, etc.)
            
        Returns:
            List of Path objects for video files found within the depth limit
        """
        video_files = []
        
        # Use a queue-based approach to avoid recursion limits
        # Each item in the queue is a tuple of (directory_path, current_depth)
        queue = [(source_dir, 1)]
        
        while queue:
            current_dir, current_depth = queue.pop(0)
            
            # Skip if we've exceeded the maximum depth
            if current_depth > max_depth:
                continue
                
            try:
                # Iterate through items in the current directory
                for item in current_dir.iterdir():
                    if item.is_file() and self.is_video_file(item):
                        # Found a video file
                        video_files.append(item)
                    elif item.is_dir() and current_depth < max_depth:
                        # Add subdirectory to queue for processing
                        queue.append((item, current_depth + 1))
            except (PermissionError, OSError) as e:
                # Skip directories we can't access
                print(f"  Warning: Cannot access directory {current_dir}: {e}")
                continue
                
        return video_files
    
    def extract_episode_number(self, filename: str) -> Optional[int]:
        """Extract episode number from filename."""
        for pattern in self.episode_patterns:
            match = pattern.search(filename)
            if match:
                try:
                    return int(match.group(1))
                except (ValueError, IndexError):
                    continue
        return None

    def extract_season_episode(self, filename: str) -> Tuple[Optional[int], Optional[int]]:
        """Extract season and episode numbers from filename.

        Uses shared BaseSeasonDetector for season extraction and local patterns for episodes.
        """
        # Extract season using shared module
        season_num, description, matched_text = self.extract_season_info(filename)

        # Extract episode using local patterns
        episode_num = self.extract_episode_number(filename)

        return season_num, episode_num
    
    def generate_unique_filename(self, target_path: Path) -> Path:
        """Generate unique filename if collision exists."""
        if not target_path.exists():
            return target_path
        
        base_name = target_path.stem
        extension = target_path.suffix
        parent = target_path.parent
        counter = 1
        
        while True:
            new_name = f"{base_name}_{counter}{extension}"
            new_path = parent / new_name
            if not new_path.exists():
                return new_path
            counter += 1
    
    def organize_directory(self, show_dir: Path) -> Dict[str, Union[int, List[str]]]:
        """Organize a single TV show directory."""
        stats = {
            'total_files': 0,
            'moved_files': 0,
            'skipped_files': 0,
            'created_seasons': 0,
            'errors': []
        }
        
        if not show_dir.is_dir():
            stats['errors'].append(f"Not a directory: {show_dir}")
            return stats
        
        try:
            # Get all video files up to the specified depth
            video_files = self.find_video_files_with_depth(show_dir, self.depth)
            
            stats['total_files'] = len(video_files)
            
            if not video_files:
                return stats
            
            created_seasons = set()
            
            for video_file in video_files:
                try:
                    season_num, episode_num = self.extract_season_episode(video_file.name)
                    
                    if season_num is None:
                        stats['skipped_files'] += 1
                        if not self.dry_run:
                            print(f"  Skipping (no season pattern): {video_file.name}")
                        continue
                    
                    # Create season directory
                    season_dir_name = f"Season {season_num}"
                    season_dir = show_dir / season_dir_name
                    
                    if not season_dir.exists():
                        if season_dir_name not in created_seasons:
                            if self.dry_run:
                                print(f"  [DRY RUN] Would create: {season_dir_name}")
                            else:
                                season_dir.mkdir(exist_ok=True)
                                print(f"  Created: {season_dir_name}")
                            created_seasons.add(season_dir_name)
                            stats['created_seasons'] += 1
                    
                    # Determine target file path
                    target_file = season_dir / video_file.name
                    
                    # Handle collisions
                    if target_file.exists():
                        original_target = target_file
                        target_file = self.generate_unique_filename(target_file)
                        if not self.dry_run:
                            print(f"  Collision detected: {video_file.name}")
                            print(f"    Renaming to: {target_file.name}")
                    
                    # Move the file
                    if self.dry_run:
                        print(f"  [DRY RUN] Would move: {video_file.name} â†’ {season_dir_name}/{target_file.name}")
                        stats['moved_files'] += 1
                    else:
                        shutil.move(str(video_file), str(target_file))
                        print(f"  Moved: {video_file.name} â†’ {season_dir_name}/{target_file.name}")
                        stats['moved_files'] += 1
                
                except Exception as e:
                    stats['errors'].append(f"Error processing {video_file.name}: {e}")
                    stats['skipped_files'] += 1
        
        except Exception as e:
            stats['errors'].append(f"Error processing directory {show_dir}: {e}")
        
        return stats


class PlexSeasonBatchOrganizer:
    """Main class for batch season organization."""

    def __init__(self, dry_run: bool = False, force: bool = False,
                 max_workers: int = 4, recursive: bool = False, depth: int = 1,
                 enable_cleanup: bool = False, verbose: bool = False):
        self.dry_run = dry_run
        self.force = force
        self.max_workers = max_workers
        self.recursive = recursive
        self.depth = depth
        self.enable_cleanup = enable_cleanup
        self.verbose = verbose
        self.file_lock = FileLock('plex_make_all_seasons')
        self.organizer = SeasonOrganizer(
            dry_run=dry_run,
            depth=depth,
            enable_cleanup=enable_cleanup,
            verbose=verbose
        )
    
    def acquire_lock(self) -> bool:
        """Acquire file lock to prevent multiple instances."""
        return self.file_lock.acquire_lock(self.force)
    
    def release_lock(self) -> None:
        """Release the file lock."""
        self.file_lock.release_lock()
    
    def find_show_directories(self, base_dir: Path) -> List[Path]:
        """Find all show directories to process."""
        show_dirs = []
        
        try:
            if self.recursive:
                # Recursively find directories with video files
                for item in base_dir.rglob('*'):
                    if (item.is_dir() and 
                        any(f.is_file() and self.organizer.is_video_file(f) 
                            for f in item.iterdir())):
                        show_dirs.append(item)
            else:
                # Only immediate subdirectories
                for item in base_dir.iterdir():
                    if item.is_dir():
                        show_dirs.append(item)
        
        except Exception as e:
            print(f"Error scanning directories: {e}")
        
        return sorted(show_dirs)
    
    def process_show_sequential(self, show_dir: Path) -> Tuple[Path, Dict]:
        """Process a single show directory (for sequential processing)."""
        return show_dir, self.organizer.organize_directory(show_dir)
    
    def process_shows_parallel(self, show_dirs: List[Path]) -> List[Tuple[Path, Dict]]:
        """Process multiple show directories in parallel."""
        results = []
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            # Submit all tasks
            future_to_dir = {
                executor.submit(self.organizer.organize_directory, show_dir): show_dir 
                for show_dir in show_dirs
            }
            
            # Collect results as they complete
            for future in concurrent.futures.as_completed(future_to_dir):
                show_dir = future_to_dir[future]
                try:
                    stats = future.result()
                    results.append((show_dir, stats))
                except Exception as e:
                    error_stats = {
                        'total_files': 0, 'moved_files': 0, 'skipped_files': 0,
                        'created_seasons': 0, 'errors': [f"Processing error: {e}"]
                    }
                    results.append((show_dir, error_stats))
        
        return results
    
    def print_summary(self, results: List[Tuple[Path, Dict]]) -> None:
        """Print comprehensive summary of processing results."""
        total_stats = {
            'directories_processed': len(results),
            'total_files': 0,
            'moved_files': 0,
            'skipped_files': 0,
            'created_seasons': 0,
            'directories_with_errors': 0,
            'total_errors': 0
        }
        
        print("\n" + "=" * 60)
        print("PROCESSING SUMMARY")
        print("=" * 60)
        
        for show_dir, stats in results:
            total_stats['total_files'] += stats['total_files']
            total_stats['moved_files'] += stats['moved_files']
            total_stats['skipped_files'] += stats['skipped_files']
            total_stats['created_seasons'] += stats['created_seasons']
            
            if stats['errors']:
                total_stats['directories_with_errors'] += 1
                total_stats['total_errors'] += len(stats['errors'])
                print(f"\nâŒ {show_dir.name}:")
                for error in stats['errors']:
                    print(f"   Error: {error}")
            elif stats['moved_files'] > 0:
                print(f"\nâœ… {show_dir.name}: {stats['moved_files']} files organized into {stats['created_seasons']} seasons")
            elif stats['total_files'] == 0:
                print(f"\nâšª {show_dir.name}: No video files found")
            else:
                print(f"\nâš ï¸  {show_dir.name}: {stats['skipped_files']} files skipped (no season pattern)")
        
        print("\n" + "=" * 60)
        print("OVERALL STATISTICS")
        print("=" * 60)
        print(f"Directories processed: {total_stats['directories_processed']}")
        print(f"Total video files found: {total_stats['total_files']}")
        
        if self.dry_run:
            print(f"Files that would be moved: {total_stats['moved_files']}")
            print(f"Seasons that would be created: {total_stats['created_seasons']}")
        else:
            print(f"Files successfully moved: {total_stats['moved_files']}")
            print(f"Season directories created: {total_stats['created_seasons']}")
        
        print(f"Files skipped: {total_stats['skipped_files']}")
        print(f"Directories with errors: {total_stats['directories_with_errors']}")
        print(f"Total errors: {total_stats['total_errors']}")
        
        if total_stats['total_errors'] == 0:
            print("\nðŸŽ‰ Processing completed successfully!")
        else:
            print("\nâš ï¸  Processing completed with errors. See details above.")
    
    def handle_confirmation(self, skip_confirmation: bool) -> bool:
        """Handle user confirmation for the operation."""
        # Confirmation prompt for non-dry-run operations
        if not self.dry_run and not skip_confirmation and not is_non_interactive():
            print("\nThis will organize video files into season directories.")
            print("Files will be moved to create proper Plex library structure.")
            try:
                response = input("\nDo you want to proceed? (yes/no): ").strip().lower()
                if response not in ['yes', 'y']:
                    print("Operation cancelled.")
                    return False
            except (EOFError, KeyboardInterrupt):
                print("\nOperation cancelled.")
                return False
        elif not self.dry_run and (skip_confirmation or is_non_interactive()):
            if skip_confirmation:
                print("Proceeding with season organization (--yes flag)...")
            else:
                print("Proceeding with season organization (non-interactive environment)...")
        
        return True

    def process_directories(self, show_dirs: List[Path]) -> List[Tuple[Path, Dict]]:
        """Process the directories either sequentially or in parallel."""
        start_time = time.time()
        
        if self.max_workers == 1:
            # Sequential processing
            results = []
            for i, show_dir in enumerate(show_dirs, 1):
                print(f"[{i}/{len(show_dirs)}] Processing: {show_dir.name}")
                result = self.process_show_sequential(show_dir)
                results.append(result)
        else:
            # Parallel processing
            print(f"Processing {len(show_dirs)} directories in parallel...")
            results = self.process_shows_parallel(show_dirs)
        
        end_time = time.time()
        processing_time = end_time - start_time
        
        # Print summary
        self.print_summary(results)
        print(f"\nProcessing time: {processing_time:.2f} seconds")
        
        return results

    def process_directory(self, base_dir: Path, skip_confirmation: bool = False) -> bool:
        """Process all show directories in the base directory."""
        if not base_dir.exists():
            print(f"Error: Directory '{base_dir}' does not exist.")
            return False
        
        if not base_dir.is_dir():
            print(f"Error: '{base_dir}' is not a directory.")
            return False
        
        print(f"Processing TV shows in: {base_dir}")
        if self.recursive:
            print("RECURSIVE MODE - Processing all subdirectories")
        print(f"Using {self.max_workers} worker threads")

        # System trash cleanup (if enabled)
        if self.enable_cleanup:
            print("\nCleaning system trash files...")
            cleaner = SystemTrashCleaner(verbose=self.verbose, dry_run=self.dry_run)
            cleanup_count = cleaner.clean_directory(base_dir, recursive=True)

            if self.dry_run:
                print(f"Would remove {cleanup_count} trash files\n")
            else:
                print(f"Removed {cleanup_count} trash files\n")
        else:
            print()

        # Handle confirmation
        if not self.handle_confirmation(skip_confirmation):
            return False

        # Find all show directories
        show_dirs = self.find_show_directories(base_dir)
        
        if not show_dirs:
            print("No directories found to process.")
            return True
        
        print(f"Found {len(show_dirs)} directories to process:")
        for show_dir in show_dirs:
            print(f"  - {show_dir.name}")
        print()
        
        # Process directories
        self.process_directories(show_dirs)
        
        return True


def main():
    """Main function with argument parsing and execution."""
    parser = argparse.ArgumentParser(
        description="Plex Season Organizer (Batch) - Organize TV show episodes into season directories",
        epilog="""
Examples:
  %(prog)s /path/to/tv/shows                    # Preview changes (dry-run mode)
  %(prog)s /path/to/tv/shows --execute          # Actually organize files
  %(prog)s /path/to/tv/shows --execute -y       # Execute without confirmation
  %(prog)s /path/to/tv/shows --parallel 8       # Use 8 worker threads
  %(prog)s /path/to/tv/shows --recursive        # Process all subdirectories
  %(prog)s /path/to/tv/shows --depth 2 --execute # Search for files up to 2 levels deep
  %(prog)s /path/to/tv/shows --depth 3 --execute # Search for files up to 3 levels deep
  %(prog)s /path/to/tv/shows --verbose          # Show verbose output
  %(prog)s /path/to/tv/shows --debug            # Show debug output
  %(prog)s /path/to/tv/shows --force            # Force run (bypass lock)
  
Cron Usage:
  # Run daily at 3 AM (non-interactive)
  0 3 * * * /usr/local/bin/plex_make_all_seasons /path/to/tv/shows --execute -y
        """,
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument(
        'directory',
        nargs='?',
        default='.',
        help='Base directory containing TV show directories (default: current directory)'
    )
    parser.add_argument(
        '--dry-run',
        action='store_true',
        default=True,
        help='Show what would be done without making changes (default: true)'
    )
    parser.add_argument(
        '--execute',
        action='store_true',
        help='Actually perform operations (overrides --dry-run)'
    )
    parser.add_argument(
        '-y', '--yes',
        action='store_true',
        help='Skip confirmation prompt (for non-interactive use)'
    )
    parser.add_argument(
        '--verbose',
        action='store_true',
        help='Show verbose output'
    )
    parser.add_argument(
        '--debug',
        action='store_true',
        help='Show detailed debug output'
    )
    parser.add_argument(
        '--cleanup',
        action='store_true',
        help='Clean system trash files (.DS_Store, Thumbs.db, etc.) before processing'
    )
    parser.add_argument(
        '--force',
        action='store_true',
        help='Force execution even if another instance is running'
    )
    parser.add_argument(
        '--parallel', '--workers',
        type=int,
        default=4,
        metavar='N',
        help='Number of worker threads for parallel processing (default: 4, use 1 for sequential)'
    )
    parser.add_argument(
        '--recursive',
        action='store_true',
        help='Recursively process all subdirectories (not just immediate children)'
    )
    parser.add_argument(
        '--no-banner',
        action='store_true',
        help='Suppress banner display'
    )
    parser.add_argument(
        '--depth',
        type=int,
        default=1,
        help='Depth level for searching video files (default: 1). Use 2 or higher to search in subdirectories.'
    )
    parser.add_argument(
        '--version',
        action='version',
        version=f'%(prog)s v{VERSION}'
    )
    
    args = parser.parse_args()
    
    # Handle debug mode (enables verbose)
    if args.debug:
        args.verbose = True
    
    # Read global configuration
    auto_execute = read_global_config_bool('AUTO_EXECUTE', False)
    auto_confirm = read_global_config_bool('AUTO_CONFIRM', False)
    quiet_mode = read_global_config_bool('QUIET_MODE', False)
    
    # Apply global configuration (CLI arguments take precedence)
    if auto_execute and not args.execute:
        args.execute = True  # Set execute flag if AUTO_EXECUTE is set
    if auto_confirm and not args.yes:
        args.yes = True  # Set yes flag if AUTO_CONFIRM is set
    
    # Determine dry-run mode
    if args.execute:
        dry_run_mode = False
    else:
        dry_run_mode = args.dry_run  # This is True by default
    
    # Validate arguments
    if args.parallel < 1:
        print("Error: Number of workers must be at least 1")
        sys.exit(1)
    
    if args.yes and dry_run_mode:
        print("Warning: -y/--yes flag has no effect in dry-run mode", file=sys.stderr)
    
    # Display banner
    display_banner("plex_make_all_seasons", "2.1.0", 
                  "create season directories for TV shows with parallel processing support",
                  args.no_banner, quiet_mode)
    
    if dry_run_mode:
        print("DRY-RUN MODE: No changes will be made")
    else:
        print("EXECUTE MODE: Episodes will be organized")
    
    if args.debug:
        print("Debug: ENABLED")
    elif args.verbose:
        print("Verbose: ENABLED")
    print()
    
    # Create organizer instance
    organizer = PlexSeasonBatchOrganizer(
        dry_run=dry_run_mode,
        force=args.force,
        max_workers=args.parallel,
        recursive=args.recursive,
        depth=args.depth,
        enable_cleanup=args.cleanup,
        verbose=args.verbose or args.debug
    )
    
    try:
        # Acquire lock
        if not organizer.acquire_lock():
            sys.exit(1)
        
        # Process directory
        base_dir = Path(args.directory).resolve()
        success = organizer.process_directory(base_dir, skip_confirmation=args.yes)
        
        sys.exit(0 if success else 1)
        
    except KeyboardInterrupt:
        print("\nOperation cancelled by user.")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)
    finally:
        organizer.release_lock()


if __name__ == '__main__':
    main()