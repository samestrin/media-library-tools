#!/usr/bin/env python3
"""
Plex Movie Extras Organizer

A tool for organizing movie extras (featurettes, deleted scenes, etc.) according to
Plex naming conventions. This script moves and renames extra files from subdirectories
into the main movie directory with proper Plex-compatible naming.

Features:
- Moves extras from subdirectories to main movie directory
- Renames files with Plex-compatible naming conventions
- Handles multiple files with sequential numbering
- Dry-run mode for safe testing
- Cron-friendly operation with non-interactive detection
- File locking to prevent concurrent executions

Author: Media Library Tools Project
Version: 2.1.0
"""

import argparse
import os
import shutil
import sys
from pathlib import Path
from typing import List, Optional, Tuple


# ======================================================
# {{include utils.py}}


# ======================================================


# Version constant
VERSION = "2.1.0"










class PlexMovieExtrasOrganizer:
    """Main class for organizing Plex movie extras."""
    
    def __init__(self, dry_run: bool = False, force: bool = False, verbose: bool = False):
        self.dry_run = dry_run
        self.force = force
        self.verbose = verbose
        self.file_lock = FileLock('plex_move_movie_extras')
        
        # Video file extensions for validation
        self.video_extensions = {
            '.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v',
            '.mpg', '.mpeg', '.3gp', '.ogv', '.ts', '.m2ts', '.vob', '.divx',
            '.xvid', '.rm', '.rmvb', '.asf', '.f4v', '.m4p'
        }
    
    def acquire_lock(self) -> bool:
        """Acquire file lock to prevent multiple instances."""
        return self.file_lock.acquire_lock(self.force)
    
    def release_lock(self) -> None:
        """Release the file lock."""
        self.file_lock.release_lock()
    
    def is_video_file(self, file_path: str) -> bool:
        """Check if a file is a video file based on its extension.
        
        Args:
            file_path: Path to the file to check
            
        Returns:
            True if file is a video file, False otherwise
        """
        file_extension = os.path.splitext(file_path)[1].lower()
        return file_extension in self.video_extensions

    def organize_extras(self, main_file: str, sub_dir: str) -> bool:
        """Organize movie extras from subdirectory to main directory."""
        if not os.path.isfile(main_file):
            print(f"Error: main file '{main_file}' does not exist.")
            return False

        # Validate main file is a video file
        if not self.is_video_file(main_file):
            print(f"Error: main file '{main_file}' is not a supported video file.")
            print(f"Supported video extensions: {', '.join(sorted(self.video_extensions))}")
            return False

        movie_dir = os.path.dirname(main_file)
        base_name = os.path.splitext(os.path.basename(main_file))[0]
        extras_dir = os.path.join(movie_dir, sub_dir)

        if not os.path.isdir(extras_dir):
            print(f"Error: sub-directory '{sub_dir}' does not exist.")
            return False

        files = sorted(os.listdir(extras_dir))
        count = 1

        for file in files:
            src_path = os.path.join(extras_dir, file)
            if os.path.isdir(src_path):
                continue  # skip nested folders

            # Validate file is a video file
            if not self.is_video_file(src_path):  # Use src_path to check the full path
                print(f"Warning: Skipping non-video file '{file}'")
                continue

            ext = os.path.splitext(file)[1]
            safe_sub = sub_dir.lower().replace(" ", "")
            suffix = f"-{safe_sub}"

            if len(files) > 1:
                new_name = f"{base_name} - {sub_dir} {count:02d}{suffix}{ext}"
            else:
                new_name = f"{base_name} - {sub_dir}{suffix}{ext}"

            dest_path = os.path.join(movie_dir, new_name)

            if self.dry_run:
                print(f"[DRY RUN] Would rename:\\n  '{src_path}'\\n  => '{dest_path}'")
            else:
                try:
                    shutil.move(src_path, dest_path)
                    print(f"Renamed:\n  '{src_path}'\n  => '{dest_path}'")
                except Exception as e:
                    print(f"Error moving '{src_path}' to '{dest_path}': {e}")
                    return False
            count += 1

        if not self.dry_run:
            try:
                os.rmdir(extras_dir)
                print(f"Removed empty directory: {extras_dir}")
            except OSError:
                print(f"Note: Directory not empty or not removed: {extras_dir}")
        
        return True



def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Move and rename movie extras to match Plex naming conventions",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Preview what would be moved (dry-run mode, default)
  %(prog)s "Movie (2023).mkv" "Featurettes"
  
  # Actually move files with confirmation
  %(prog)s "Movie (2023).mkv" "Deleted Scenes" --execute
  
  # Move files without confirmation (for automation)
  %(prog)s "Movie (2023).mkv" "Behind the Scenes" --execute -y
  
Cron Usage:
  # Run daily to organize movie extras (non-interactive)
  0 2 * * * /usr/local/bin/plex_move_movie_extras "/movies/Movie.mkv" "Featurettes" --execute -y
  

"""
    )
    
    parser.add_argument(
        "main_file", 
        help="Main movie file path"
    )
    parser.add_argument(
        "sub_dir", 
        help="Subdirectory name containing extras (e.g., 'Featurettes', 'Deleted Scenes')"
    )
    parser.add_argument(
        "--dry-run", 
        action="store_true",
        default=True,
        help="Preview changes without modifying files (default: true)"
    )
    parser.add_argument(
        "--execute", 
        action="store_true", 
        help="Actually perform operations (overrides --dry-run)"
    )
    parser.add_argument(
        "-y", "--yes", 
        action="store_true", 
        help="Skip confirmation prompts (useful for automation/cron)"
    )
    parser.add_argument(
        "--force", 
        action="store_true", 
        help="Force execution even if another instance is running"
    )
    parser.add_argument(
        "--verbose", 
        action="store_true", 
        help="Enable verbose output for debugging"
    )
    parser.add_argument(
        "--debug", 
        action="store_true", 
        help="Enable debug output (implies --verbose)"
    )
    parser.add_argument(
        "--no-banner",
        action="store_true",
        help="Suppress banner display"
    )
    parser.add_argument(
        "--version", 
        action="version", 
        version=f"%(prog)s {VERSION}"
    )
    
    args = parser.parse_args()
    
    # Handle debug mode
    if args.debug:
        args.verbose = True
    
    # Read configuration with CLI > ENV > Local .env > Global .env priority
    auto_execute = read_config_bool('AUTO_EXECUTE', cli_args=args, default=False)
    auto_confirm = read_config_bool('AUTO_CONFIRM', cli_args=args, default=False)
    quiet_mode = read_config_bool('QUIET_MODE', cli_args=args, default=False)

    # Apply configuration (CLI arguments already have highest priority via read_config_bool)
    if auto_execute and not args.execute:
        args.execute = True  # Set execute flag if AUTO_EXECUTE is set
    if auto_confirm and not args.yes:
        args.yes = True  # Set yes flag if AUTO_CONFIRM is set
    
    # Handle dry-run/execute logic
    if args.execute:
        dry_run_mode = False
    else:
        dry_run_mode = args.dry_run  # This is True by default
    
    # Validate arguments
    if not os.path.exists(args.main_file):
        print(f"Error: Main file '{args.main_file}' does not exist.")
        sys.exit(1)
    
    if not os.path.isfile(args.main_file):
        print(f"Error: '{args.main_file}' is not a file.")
        sys.exit(1)
    
    # Check if subdirectory exists relative to main file
    main_file_dir = os.path.dirname(os.path.abspath(args.main_file))
    sub_dir_path = os.path.join(main_file_dir, args.sub_dir)
    
    if not os.path.exists(sub_dir_path):
        print(f"Error: Subdirectory '{args.sub_dir}' does not exist in '{main_file_dir}'.")
        sys.exit(1)
    
    if not os.path.isdir(sub_dir_path):
        print(f"Error: '{args.sub_dir}' is not a directory.")
        sys.exit(1)
    
    # Display banner
    display_banner("plex_move_movie_extras", VERSION, 
                  "organize movie extras into proper subdirectories",
                  args.no_banner, quiet_mode)
    
    if dry_run_mode:
        print("DRY-RUN MODE: No changes will be made")
    else:
        print("EXECUTE MODE: Files will be moved and renamed")
    
    if args.debug:
        print("Debug: ENABLED")
    elif args.verbose:
        print("Verbose: ENABLED")
    print()
    
    # Create organizer instance
    organizer = PlexMovieExtrasOrganizer(
        dry_run=dry_run_mode,
        force=args.force,
        verbose=args.verbose
    )
    
    # Acquire lock
    if not organizer.acquire_lock():
        sys.exit(1)
    
    try:
        # Show what will be done
        if args.verbose:
            print(f"Main file: {args.main_file}")
            print(f"Subdirectory: {args.sub_dir}")
            print(f"Mode: {'DRY RUN' if dry_run_mode else 'EXECUTE'}")
            print("-" * 50)
        
        # Confirm action unless in dry-run mode or confirmation skipped
        if not dry_run_mode:
            if not confirm_action(
                f"Move extras from '{args.sub_dir}' to main movie directory?",
                args.yes or is_non_interactive()
            ):
                print("Operation cancelled.")
                sys.exit(0)
        
        # Execute the organization
        success = organizer.organize_extras(args.main_file, sub_dir_path)
        
        if success:
            if dry_run_mode:
                print("\nDry run completed successfully. Use --execute to make changes.")
            else:
                print("\nMovie extras organized successfully!")
        else:
            print("\nOperation failed. Check error messages above.")
            sys.exit(1)
            
    except KeyboardInterrupt:
        print("\nOperation cancelled by user.")
        sys.exit(1)
    except Exception as e:
        print(f"\nUnexpected error: {e}")
        if args.debug:
            import traceback
            traceback.print_exc()
        sys.exit(1)
    finally:
        organizer.release_lock()


if __name__ == "__main__":
    main()
