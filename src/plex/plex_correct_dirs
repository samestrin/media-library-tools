#!/usr/bin/env python3
"""
Plex Directory Name Corrector

A comprehensive tool for sanitizing and organizing Plex media directory names.
This script processes directory names to ensure they follow Plex naming conventions
by removing unwanted tags, standardizing formats, and organizing files into directories.

Features:
- Enhanced regex patterns for comprehensive tag removal
- Standardizes resolution and year formats
- Converts files to directory structure
- File-based locking mechanism
- Dry-run mode for safe testing
- Cron-friendly operation

Author: Media Library Tools Project
Version: 2.0.0
"""

import argparse
import os
import re
import shutil
import sys
from pathlib import Path
from typing import List, Optional, Tuple

VERSION = "2.1.0"

# ======================================================
# {{include lib/core.py}}
# {{include lib/ui.py}}

# ======================================================





class PlexDirectoryCorrector:
    """Main class for correcting Plex directory names."""

    def __init__(self, dry_run: bool = False, force: bool = False, max_items: int = 5,
                 verbose: bool = False, debug: bool = False):
        self.dry_run = dry_run
        self.force = force
        self.max_items = max_items if dry_run else float('inf')
        self.verbose = verbose
        self.debug = debug
        self.processed_count = 0
        self.file_lock = FileLock('plex_correct_dirs')

        # Enhanced regex patterns for comprehensive tag removal
        self.patterns = {
            # Resolution patterns - enclose in brackets
            'resolution': re.compile(r'(?<!\[)(\b\d{3,4}p\b)(?=(\W|$))', re.IGNORECASE),

            # Year patterns - enclose in parentheses
            'year': re.compile(r'(?<!\()(\b(19|20)\d{2}\b)(?!\))', re.IGNORECASE),

            # 4K to 2160p conversion
            'four_k': re.compile(r'\[4k\]', re.IGNORECASE),

            # Release group tags
            'release_groups': re.compile(
                r'\[(YTS\.[A-Z]{2,3}|RARBG|YIFY|FGT|ION10|STUTTERSHIT|RMTEAM|PSA|KOGi|'
                r'SPARKS|DEFLATE|BLOW|Scene|CMRG|EVO|FXG|MiGHTY|QOQ|SiNNERS|UTR|'
                r'YAWNiNG|SAMPA|ION265|BONSAI|YTS|MeGusta|LAMA|SUBSCRiBE|RAWR|NOW|'
                r'ETRG|AMIABLE|GALAXY|GECKOS|HONE|KILLERS|ROVERS|SWTYBLZ|TGx|'
                r'TORRENTGALAXY|VARYG|YIFY|ZMNT)\]', re.IGNORECASE
            ),

            # Video source/quality tags
            'video_quality': re.compile(
                r'\[(BluRay|BDRip|WEBRip|DVDRip|BRRip|HDRip|WEB-DL|WEB|HDTV|CAM|TS|'
                r'TC|SCR|R5|DVDScr|HDCAM|HDTS|WORKPRINT|TELECINE|TELESYNC|'
                r'SCREENER|DVDSCREENER|BDRIP|BRRIP|HDRIP|WEBRIP|WEBDL)\]', re.IGNORECASE
            ),

            # Audio format tags
            'audio_format': re.compile(
                r'\[(5\.1|7\.1|2\.0|AC3|AAC|DTS|DOLBY|Atmos|DTS-HD|AAC2\.0|'
                r'DD5\.1|DD7\.1|TrueHD|FLAC|MP3|OGG|PCM|LPCM)\]', re.IGNORECASE
            ),

            # Codec tags
            'codec': re.compile(
                r'\[(H\.264|H\.265|x264|x265|HEVC|AVC|XviD|DivX|VP9|AV1|'
                r'MPEG2|MPEG4)\]', re.IGNORECASE
            ),

            # HDR and enhancement tags
            'enhancement': re.compile(
                r'\[(HDR|HDR10|HDR10\+|DV|DOLBY.VISION|IMAX|REMASTERED|UNRATED|'
                r'DC|EXTENDED|DIRECTOR.S.CUT|THEATRICAL|ULTIMATE|SPECIAL.EDITION|'
                r'CRITERION|ANNIVERSARY)\]', re.IGNORECASE
            ),

            # Streaming service tags
            'streaming': re.compile(
                r'\[(AMZN|NFLX|HULU|DSNP|ATVP|HMAX|PCOK|PMTP|STAN|CRAV|'
                r'AMAZON|NETFLIX|DISNEY|APPLE|HBO|PEACOCK|PARAMOUNT)\]', re.IGNORECASE
            ),

            # Technical tags
            'technical': re.compile(
                r'\[(10bit|8bit|12bit|HDR|WEB|INTERNAL|PROPER|REPACK|READ\.NFO|'
                r'RERiP|SUBBED|DUBBED|MULTI|DUAL|REMUX|HYBRID)\]', re.IGNORECASE
            ),

            # Dots to spaces
            'dots': re.compile(r'\.'),

            # Duplicate resolution tags
            'duplicate_resolution': re.compile(r'\[2160p\]\s*\[2160p\]'),

            # Empty brackets
            'empty_brackets': re.compile(r'\[\s*\]'),

            # Multiple spaces
            'multiple_spaces': re.compile(r'[ \t]+'),

            # Leading/trailing whitespace and punctuation
            'trim': re.compile(r'^[\s\.\-_]+|[\s\.\-_]+$')
        }

    def log_verbose(self, msg: str):
        """Log verbose message."""
        if self.verbose or self.debug:
            print(f"[VERBOSE] {msg}", file=sys.stderr)

    def log_debug(self, msg: str):
        """Log debug message."""
        if self.debug:
            print(f"[DEBUG] {msg}", file=sys.stderr)

    def acquire_lock(self) -> bool:
        """Acquire file lock to prevent multiple instances."""
        return self.file_lock.acquire_lock(self.force)

    def release_lock(self) -> None:
        """Release the file lock."""
        self.file_lock.release_lock()

    def sanitize_name(self, name: str) -> str:
        """Sanitize directory name using enhanced regex patterns."""
        result = name

        # Step 1: Enclose resolutions in brackets
        result = self.patterns['resolution'].sub(r'[\1]', result)

        # Step 2: Enclose years in parentheses
        result = self.patterns['year'].sub(r'(\1)', result)

        # Step 3: Convert [4K] to [2160p]
        result = self.patterns['four_k'].sub('[2160p]', result)

        # Step 4: Remove unwanted tags (before dot replacement)
        for pattern_name in ['release_groups', 'video_quality', 'audio_format',
                           'codec', 'enhancement', 'streaming', 'technical']:
            result = self.patterns[pattern_name].sub('', result)

        # Step 5: Replace dots with spaces
        result = self.patterns['dots'].sub(' ', result)

        # Step 6: Remove duplicate resolution tags
        result = self.patterns['duplicate_resolution'].sub('[2160p]', result)

        # Step 7: Remove remaining unwanted terms after resolution/year
        # Split on resolution or year markers and clean suffix
        match = re.search(r'(.*(?:\(\d{4}\)|\[\d{3,4}p\]))(.*)', result, re.DOTALL)
        if match:
            prefix, suffix = match.groups()
            # Remove remaining unwanted terms from suffix
            suffix = re.sub(
                r'(AMZN|NFLX|HULU|DSNP|ATVP|HMAX|PCOK|PMTP|STAN|10bit|8bit|HDR|'
                r'WEB|INTERNAL|PROPER|REPACK|READ\.NFO|RERiP)', '', suffix, flags=re.IGNORECASE
            )
            suffix = re.sub(r'^[\s\.\-_]+|[\s\.\-_]+$', '', suffix)
            result = prefix + suffix

        # Step 8: Remove empty brackets
        result = self.patterns['empty_brackets'].sub('', result)

        # Step 9: Final cleanup
        result = self.patterns['multiple_spaces'].sub(' ', result)
        result = self.patterns['trim'].sub('', result)

        return result

    def process_entry(self, entry_path: Path) -> Tuple[bool, str]:
        """Process a single file or directory entry."""
        if self.processed_count >= self.max_items:
            return False, "Dry-run limit reached"

        original_path = entry_path

        # If it's a file, create directory and move file into it
        if entry_path.is_file():
            base_name = entry_path.stem  # filename without extension
            new_dir = entry_path.parent / base_name

            if self.dry_run:
                print(f"Would create directory '{new_dir}' and move file '{entry_path}' into it.")
            else:
                new_dir.mkdir(exist_ok=True)
                shutil.move(str(entry_path), str(new_dir / entry_path.name))
                print(f"Created directory '{new_dir}' and moved file '{entry_path}' into it.")

            entry_path = new_dir  # Update to process the new directory

        # Process directory renaming
        if entry_path.is_dir():
            base_name = entry_path.name
            sanitized_name = self.sanitize_name(base_name)
            sanitized_path = entry_path.parent / sanitized_name

            if base_name == sanitized_name:
                print(f"No renaming needed for '{entry_path}'.")
            elif sanitized_path.exists():
                print(f"Error: A directory with the sanitized name '{sanitized_name}' already exists. Skipping '{entry_path}'.")
            else:
                if self.dry_run:
                    print(f"Would rename directory '{entry_path}' to '{sanitized_name}'")
                else:
                    entry_path.rename(sanitized_path)
                    print(f"Renamed directory '{entry_path}' to '{sanitized_name}'")

        self.processed_count += 1
        return True, "Success"

    def process_directory(self, input_dir: Path) -> bool:
        """Process all entries in the specified directory."""
        if not input_dir.exists():
            print(f"Error: Directory '{input_dir}' does not exist.")
            return False

        if not input_dir.is_dir():
            print(f"Error: '{input_dir}' is not a directory.")
            return False

        print(f"Processing directory: {input_dir}")
        if self.dry_run:
            print(f"DRY-RUN MODE - Limited to {self.max_items} items")
        print()

        # Get immediate child entries (files and directories)
        entries = list(input_dir.iterdir())

        for entry in entries:
            success, message = self.process_entry(entry)
            if not success and "limit reached" in message:
                print(f"Dry-run limit of {self.max_items} items reached. Exiting.")
                break

        print(f"\nProcessed {self.processed_count} items.")
        return True


def main():
    """Main function with argument parsing and execution."""
    parser = argparse.ArgumentParser(
        description="Plex Directory Name Corrector - Sanitize and organize Plex media directory names",
        epilog="""
Examples:
  %(prog)s                                   # Process current directory (interactive)
  %(prog)s /path/to/media                    # Process specific directory (interactive)
  %(prog)s --dry-run                         # Preview changes in current directory
  %(prog)s /path/to/media --dry-run          # Preview changes in specific directory
  %(prog)s -y                                # Process current directory without confirmation
  %(prog)s /path/to/media -y                 # Process specific directory without confirmation
  %(prog)s --force                           # Force run in current directory (bypass lock)
  %(prog)s --verbose                         # Show verbose output
  %(prog)s --debug                           # Show detailed debug output

Global Configuration:
  Set AUTO_CONFIRM=true to skip confirmation prompts automatically
  Set QUIET_MODE=true to suppress banner display

Cron Usage:
  # Run daily at 2 AM (non-interactive)
  0 2 * * * /usr/local/bin/plex_correct_dirs /path/to/media -y
        """,
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    parser.add_argument(
        'directory',
        nargs='?',
        default='.',
        help='Directory to process (default: current directory)'
    )
    parser.add_argument(
        '--dry-run',
        action='store_true',
        default=True,
        help='Show what would be done without making changes (limited to 5 items)'
    )
    parser.add_argument(
        '--execute',
        action='store_true',
        help='Actually perform the directory corrections (overrides --dry-run)'
    )
    parser.add_argument(
        '-y', '--yes',
        action='store_true',
        help='Skip confirmation prompt (for non-interactive use)'
    )
    parser.add_argument(
        '--force',
        action='store_true',
        help='Force execution even if another instance is running'
    )
    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        help='Show verbose output'
    )
    parser.add_argument(
        '--debug',
        action='store_true',
        help='Show detailed debug output'
    )
    parser.add_argument(
        '--no-banner',
        action='store_true',
        help='Suppress banner display'
    )
    parser.add_argument(
        '--max-items',
        type=int,
        default=5,
        help='Maximum items to process in dry-run mode (default: 5)'
    )
    parser.add_argument(
        '--version',
        action='version',
        version=f'%(prog)s v{VERSION}'
    )

    args = parser.parse_args()

    # Handle execute flag (overrides dry-run default)
    if args.execute:
        args.dry_run = False

    # Handle debug mode
    if args.debug:
        args.verbose = True

    # Read global configuration
    auto_execute = read_global_config_bool('AUTO_EXECUTE', False)
    auto_confirm = read_global_config_bool('AUTO_CONFIRM', False)
    quiet_mode = read_global_config_bool('QUIET_MODE', False)

    # Apply global configuration (CLI arguments take precedence)
    if auto_confirm and not args.yes:
        args.yes = True  # Set yes flag if AUTO_CONFIRM is set

    # Display banner (respecting suppression flags)
    display_banner(
        "Plex Directory Name Corrector",
        "2.1.0",
        "Sanitize and organize Plex media directory names",
        args.no_banner,
        quiet_mode
    )

    # Validate arguments
    if args.yes and args.dry_run:
        print("Warning: -y/--yes flag has no effect in dry-run mode", file=sys.stderr)

    # Create corrector instance
    corrector = PlexDirectoryCorrector(
        dry_run=args.dry_run,
        force=args.force,
        max_items=args.max_items,
        verbose=args.verbose,
        debug=args.debug
    )

    try:
        # Acquire lock
        if not corrector.acquire_lock():
            sys.exit(1)

        # Get confirmation for non-dry-run operations
        if not args.dry_run and not args.yes and not is_non_interactive():
            print("\nThis will modify directory names and file locations.")
            print("Consider running with --dry-run first to preview changes.")
            try:
                response = input("\nDo you want to proceed? (yes/no): ").strip().lower()
            except (EOFError, KeyboardInterrupt):
                print("\nOperation cancelled.")
                sys.exit(0)

            if response not in ['yes', 'y']:
                print("Operation cancelled.")
                sys.exit(0)
        elif not args.dry_run and (args.yes or is_non_interactive()):
            if args.yes:
                print("Proceeding with directory processing (--yes flag)...")
            else:
                print("Proceeding with directory processing (non-interactive environment)...")

        # Process directory
        input_dir = Path(args.directory).resolve()
        success = corrector.process_directory(input_dir)

        sys.exit(0 if success else 1)

    except KeyboardInterrupt:
        print("\nOperation cancelled by user.")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)
    finally:
        corrector.release_lock()


if __name__ == '__main__':
    main()