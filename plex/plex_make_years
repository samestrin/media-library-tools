#!/usr/bin/env python3
"""
Plex Year Organizer

A Python tool for organizing media directories by year. This script analyzes directory
names to extract year information and automatically creates year-based directory
structures that are ideal for organizing movies and TV shows by release year.

Features:
- Intelligent year detection from various directory name patterns
- Automatic year directory creation
- Directory collision handling with smart merging
- Support for multiple year naming conventions
- File-based locking mechanism
- Dry-run mode for safe testing
- Progress tracking and detailed statistics
- Cron-friendly operation

Author: Media Library Tools Project
Version: 2.1.0
"""

import argparse
import os
import re
import shutil
import sys
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple, Union

VERSION = "2.1.0"

# ======================================================

# ======================================================
# INJECTED MODULE - START
# Generated by build.py v3.0.0
# Source: utils.py
# ======================================================

"""
Shared Utility Module for Media Library Tools

This module provides backward compatibility by re-exporting functions from the
new modular library structure. New development should use the lib/ modules directly.

DEPRECATED: This module is maintained for backward compatibility only.
New tools should use the modular lib/ structure:
- lib/core.py: Essential utilities (locking, config, platform detection)
- lib/ui.py: User interface functions (banners, formatting, confirmations)
- lib/filesystem.py: File operations
- lib/validation.py: Input validation and error handling

Author: Media Library Tools Project
Version: 1.0.0
"""

import sys
import warnings
from pathlib import Path

# Add lib directory to path for imports
lib_path = Path(__file__).parent / "lib"
if str(lib_path) not in sys.path:
    sys.path.insert(0, str(lib_path))

# Import all functions from modular libraries
try:
    from core import (
        FileLock,
        acquire_lock,
        is_non_interactive,
        is_windows,
        read_global_config_bool,
        release_lock,
        should_use_emojis,
    )
    from filesystem import (
        get_directory_size,
        validate_directory_path,
    )
    from ui import (
        confirm_action,
        display_banner,
        format_size,
        format_status_message,
    )
    from validation import (
        validate_path_argument,
    )
except ImportError as e:
    # Fallback warning if lib modules are not available
    warnings.warn(
        f"Could not import from lib modules: {e}. Using legacy implementations.",
        DeprecationWarning,
        stacklevel=2,
    )

    # Keep legacy implementations as fallback
    import contextlib
    import os
    import platform
    import tempfile
    from typing import Optional, Tuple

    # Platform-specific imports
    try:
        import fcntl  # Unix/Linux/macOS
    except ImportError:
        fcntl = None  # Windows

    try:
        import msvcrt  # Windows
    except ImportError:
        msvcrt = None  # Unix/Linux/macOS

    # Legacy function implementations (fallback only)
    def display_banner(
        script_name: str,
        version: str,
        description: str,
        no_banner_flag: bool = False,
        quiet_mode: bool = False,
    ) -> None:
        """
        Display standardized banner for media library tools.

        Args:
            script_name: Name of the script
            version: Version string
            description: Brief description of the script
            no_banner_flag: If True, suppress banner display
            quiet_mode: If True, suppress banner display
        """
        # Check suppression conditions (highest to lowest priority)
        if no_banner_flag or quiet_mode or is_non_interactive():
            return

        try:
            # Display standardized ASCII art
            print("┏┳┓┏━╸╺┳┓╻┏━┓╻  ╻┏┓ ┏━┓┏━┓┏━┓╻ ╻╺┳╸┏━┓┏━┓╻  ┏━┓")
            print("┃┃┃┣╸  ┃┃┃┣━┫┃  ┃┣┻┓┣┳┛┣━┫┣┳┛┗┳┛ ┃ ┃ ┃┃ ┃┃  ┗━┓")
            print("╹ ╹┗━╸╺┻┛╹╹ ╹┗━╸╹┗━┛╹┗╸╹ ╹╹┗╸ ╹  ╹ ┗━┛┗━┛┗━╸┗━┛")
            print(f"{script_name} v{version}: {description}")
            print()  # Blank line for separation
        except Exception:
            # Banner display errors should not prevent script execution
            pass

    def is_non_interactive() -> bool:
        """
        Detect if running in non-interactive environment (cron, etc.).

        Returns:
            True if non-interactive, False otherwise
        """
        # Check if stdin is not a TTY (common in cron jobs)
        if not sys.stdin.isatty():
            return True

        # Check for common non-interactive environment variables
        non_interactive_vars = ["CRON", "CI", "AUTOMATED", "NON_INTERACTIVE"]
        for var in non_interactive_vars:
            if os.environ.get(var):
                return True

        # Check if TERM is not set or is 'dumb' (common in automated environments)
        term = os.environ.get("TERM", "")
        return bool(not term or term == "dumb")

    def read_global_config_bool(var_name: str, default: bool = False) -> bool:
        """
        Read a boolean environment variable with support for .env files.

        Args:
            var_name: Name of the environment variable
            default: Default value if not found

        Returns:
            Boolean value of the environment variable
        """
        # Check environment variable directly
        value = os.environ.get(var_name)
        if value is not None:
            return value.lower() in ("true", "1", "yes", "on")

        # Check local .env file
        env_file = ".env"
        if os.path.exists(env_file):
            try:
                with open(env_file) as f:
                    for line in f:
                        line = line.strip()
                        if line.startswith(f"{var_name}="):
                            value = line.split("=", 1)[1].strip()
                            return value.lower() in ("true", "1", "yes", "on")
            except OSError:
                pass

        # Check global .env file
        global_env_path = Path.home() / ".media-library-tools" / ".env"
        if global_env_path.exists():
            try:
                with open(global_env_path) as f:
                    for line in f:
                        line = line.strip()
                        if line.startswith(f"{var_name}="):
                            value = line.split("=", 1)[1].strip()
                            return value.lower() in ("true", "1", "yes", "on")
            except OSError:
                pass

        return default

    def is_windows() -> bool:
        """
        Detect if running on Windows platform.

        Returns:
            True if running on Windows, False otherwise
        """
        return platform.system().lower() == "windows"

    def should_use_emojis() -> bool:
        """
        Determine if emojis should be used based on platform and environment.

        Returns:
            True if emojis should be used, False otherwise
        """
        # Don't use emojis on Windows to avoid encoding issues
        if is_windows():
            return False

        # Don't use emojis in non-interactive environments
        if is_non_interactive():
            return False

        # Check for explicit emoji suppression
        return not read_global_config_bool("NO_EMOJIS", False)

    def format_size(size_bytes: int) -> str:
        """
        Format size in bytes to human readable format.

        Args:
            size_bytes: Size in bytes

        Returns:
            Human readable size string
        """
        for unit in ["B", "K", "M", "G", "T"]:
            if size_bytes < 1024.0:
                if unit == "B":
                    return f"{size_bytes:.0f}{unit}"
                else:
                    return f"{size_bytes:.1f}{unit}"
            size_bytes /= 1024.0
        return f"{size_bytes:.1f}P"

    def confirm_action(message: str, skip_confirmation: bool = False) -> bool:
        """
        Ask for user confirmation unless skipped.

        Args:
            message: Confirmation message to display
            skip_confirmation: If True, automatically confirm

        Returns:
            True if confirmed, False otherwise
        """
        if skip_confirmation:
            return True

        try:
            response = input(f"{message} (y/N): ").strip().lower()
            return response in ["y", "yes"]
        except (EOFError, KeyboardInterrupt):
            print("\nOperation cancelled.")
            return False

    class FileLock:
        """
        File locking utility class for preventing concurrent executions.
        """

        def __init__(self, lock_prefix: str = "media_library_tool"):
            """
            Initialize file lock.

            Args:
                lock_prefix: Prefix for lock file name
            """
            self.lock_prefix = lock_prefix
            self.lock_file = None

        def acquire_lock(self, force: bool = False) -> bool:
            """
            Acquire file lock to prevent multiple instances.

            Args:
                force: If True, skip locking mechanism

            Returns:
                True if lock acquired successfully, False otherwise
            """
            if force:
                return True

            try:
                with tempfile.NamedTemporaryFile(
                    mode="w",
                    prefix=f"{self.lock_prefix}_",
                    suffix=".lock",
                    delete=False,
                ) as temp_file:
                    self.lock_file = temp_file

                    # Platform-specific file locking
                    if fcntl is not None:  # Unix/Linux/macOS
                        fcntl.flock(
                            self.lock_file.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB
                        )
                    elif msvcrt is not None:  # Windows
                        msvcrt.locking(self.lock_file.fileno(), msvcrt.LK_NBLCK, 1)
                    else:
                        # Fallback: no locking available, just proceed
                        pass

                    self.lock_file.write(str(os.getpid()))
                    self.lock_file.flush()
                return True
            except OSError as e:
                if self.lock_file:
                    self.lock_file.close()
                    with contextlib.suppress(OSError):
                        os.unlink(self.lock_file.name)
                    self.lock_file = None
                print(
                    "Error: Another instance is already running. Use --force to override."
                )
                print(f"Lock error: {e}")
                return False

        def release_lock(self) -> None:
            """
            Release the file lock.
            """
            if self.lock_file:
                try:
                    # Only unlock if file is still open
                    if not self.lock_file.closed:
                        # Platform-specific file unlocking
                        if fcntl is not None:  # Unix/Linux/macOS
                            fcntl.flock(self.lock_file.fileno(), fcntl.LOCK_UN)
                        elif msvcrt is not None:  # Windows
                            msvcrt.locking(self.lock_file.fileno(), msvcrt.LK_UNLCK, 1)
                        # No explicit unlock needed for fallback case

                        self.lock_file.close()
                except (OSError, ValueError):
                    # Handle both file system errors and closed file errors
                    pass

                # Always try to remove lock file if it exists
                try:
                    if os.path.exists(self.lock_file.name):
                        os.unlink(self.lock_file.name)
                except OSError:
                    pass
                finally:
                    self.lock_file = None

    # Legacy standalone functions for backward compatibility
    def acquire_lock(
        lock_prefix: str = "media_library_tool", force: bool = False
    ) -> Tuple[bool, Optional[FileLock]]:
        """
        Legacy function for acquiring file locks.

        Args:
            lock_prefix: Prefix for lock file name
            force: If True, skip locking mechanism

        Returns:
            Tuple of (success: bool, lock_instance: FileLock or None)
        """
        lock = FileLock(lock_prefix)
        success = lock.acquire_lock(force)
        return success, lock if success else None

    def release_lock(lock_instance: FileLock) -> None:
        """
        Legacy function for releasing file locks.

        Args:
            lock_instance: FileLock instance to release
        """
        if lock_instance:
            lock_instance.release_lock()

    def format_status_message(
        message: str, emoji: str = "", fallback_prefix: str = ""
    ) -> str:
        """
        Format a status message with emoji on supported platforms or fallback text.

        Args:
            message: The main message text
            emoji: The emoji to use on supported platforms
            fallback_prefix: Text prefix to use instead of emoji on unsupported platforms

        Returns:
            Formatted message string
        """
        if should_use_emojis() and emoji:
            return f"{emoji} {message}"
        elif fallback_prefix:
            return f"{fallback_prefix}: {message}"
        else:
            return message

    # Add any missing functions that might be needed for backward compatibility
    def get_directory_size(path: str) -> int:
        """Legacy fallback for directory size calculation."""
        total_size = 0
        try:
            for dirpath, _dirnames, filenames in os.walk(path):
                for filename in filenames:
                    filepath = os.path.join(dirpath, filename)
                    try:
                        total_size += os.path.getsize(filepath)
                    except OSError:
                        continue
        except OSError:
            pass
        return total_size

    def validate_directory_path(path: str) -> Tuple[bool, str]:
        """Legacy fallback for directory path validation."""
        if not path:
            return False, "Path cannot be empty"

        path_obj = Path(path)

        if not path_obj.exists():
            return False, f"Path does not exist: {path}"

        if not path_obj.is_dir():
            return False, f"Path is not a directory: {path}"

        return True, ""

    def validate_path_argument(path: str) -> Tuple[bool, str]:
        """Legacy fallback for path argument validation."""
        return validate_directory_path(path)


# ======================================================
# INJECTED MODULE - END
# Source: utils.py
# ======================================================



# ======================================================







class YearOrganizer:
    """Main class for organizing directories by year."""
    
    def __init__(self, dry_run: bool = False, force: bool = False, 
                 base_dir: Optional[Path] = None, year_range: Tuple[int, int] = (1900, 2030)):
        self.dry_run = dry_run
        self.force = force
        self.base_dir = base_dir
        self.year_range = year_range
        self.file_lock = FileLock('plex_make_years')
        
        # Year detection patterns (ordered by specificity)
        self.year_patterns = [
            # Parentheses patterns
            (r'\((\d{4})\)', 'Parentheses format (YYYY)'),
            (r'\[(\d{4})\]', 'Brackets format [YYYY]'),
            
            # Dot/space separated patterns
            (r'\.(\d{4})\.', 'Dot separated .YYYY.'),
            (r'\s(\d{4})\s', 'Space separated YYYY'),
            (r'-(\d{4})-', 'Dash separated -YYYY-'),
            (r'_(\d{4})_', 'Underscore separated _YYYY_'),
            
            # End of string patterns
            (r'\.(\d{4})$', 'Dot ending .YYYY'),
            (r'\s(\d{4})$', 'Space ending YYYY'),
            (r'-(\d{4})$', 'Dash ending -YYYY'),
            (r'_(\d{4})$', 'Underscore ending _YYYY'),
            
            # Beginning patterns
            (r'^(\d{4})\.', 'Dot beginning YYYY.'),
            (r'^(\d{4})\s', 'Space beginning YYYY '),
            (r'^(\d{4})-', 'Dash beginning YYYY-'),
            (r'^(\d{4})_', 'Underscore beginning YYYY_'),
            
            # Standalone year (be careful with this one)
            (r'\b(\d{4})\b', 'Standalone year YYYY'),
        ]
        
        # Statistics tracking
        self.stats = {
            'total_directories': 0,
            'processed_directories': 0,
            'skipped_directories': 0,
            'created_year_directories': 0,
            'merged_directories': 0,
            'year_patterns_found': {},
            'years_found': set(),
            'errors': []
        }
    
    def acquire_lock(self) -> bool:
        """Acquire file lock to prevent multiple instances."""
        return self.file_lock.acquire_lock(self.force)
    
    def release_lock(self) -> None:
        """Release the file lock."""
        self.file_lock.release_lock()
    
    def extract_year_info(self, dirname: str) -> Tuple[Optional[int], str, str]:
        """Extract year information from directory name.
        
        Returns:
            Tuple of (year, pattern_description, matched_text)
        """
        for pattern, description in self.year_patterns:
            match = re.search(pattern, dirname)
            if match:
                try:
                    year = int(match.group(1))
                    
                    # Validate year is within reasonable range
                    if self.year_range[0] <= year <= self.year_range[1]:
                        return year, description, match.group(0)
                        
                except (ValueError, IndexError):
                    continue
        
        return None, "No pattern matched", ""
    
    def generate_year_directory_name(self, year: int) -> str:
        """Generate year directory name."""
        return str(year)
    
    def handle_directory_collision(self, source_dir: Path, target_year_dir: Path) -> Tuple[Path, str, List[str]]:
        """Handle directory collisions when moving to year directory.
        
        Returns:
            Tuple of (final_target_path, collision_status, actions_taken)
        """
        actions = []
        
        if not target_year_dir.exists():
            return target_year_dir / source_dir.name, "no_collision", actions
        
        final_target = target_year_dir / source_dir.name
        
        if not final_target.exists():
            return final_target, "year_dir_exists", actions
        
        if final_target.is_file():
            # Target is a file, need to rename it
            backup_name = f"{final_target.stem}_backup{final_target.suffix}"
            backup_path = final_target.parent / backup_name
            
            counter = 1
            while backup_path.exists():
                backup_name = f"{final_target.stem}_backup_{counter}{final_target.suffix}"
                backup_path = final_target.parent / backup_name
                counter += 1
            
            if not self.dry_run:
                final_target.rename(backup_path)
                actions.append(f"Renamed conflicting file to {backup_path.name}")
            else:
                actions.append(f"Would rename conflicting file to {backup_path.name}")
            
            return final_target, "file_conflict_resolved", actions
        
        elif final_target.is_dir():
            # Target directory exists, need to merge or create unique name
            existing_items = list(final_target.iterdir())
            source_items = list(source_dir.iterdir())
            
            # Check if we can merge (no conflicting files)
            can_merge = True
            conflicts = []
            
            for source_item in source_items:
                target_item = final_target / source_item.name
                if target_item.exists():
                    if source_item.is_file() and target_item.is_file():
                        # File conflict - check if they're the same
                        if source_item.stat().st_size != target_item.stat().st_size:
                            conflicts.append(source_item.name)
                            can_merge = False
                    elif source_item.is_dir() and target_item.is_dir():
                        # Directory conflict - would need recursive merge
                        conflicts.append(f"{source_item.name}/ (directory)")
                        can_merge = False
                    else:
                        # Type mismatch (file vs directory)
                        conflicts.append(f"{source_item.name} (type mismatch)")
                        can_merge = False
            
            if can_merge and not conflicts:
                # Safe to merge
                return final_target, "merge_safe", actions
            else:
                # Create unique directory name
                base_name = source_dir.name
                counter = 1
                while True:
                    unique_name = f"{base_name}_{counter}"
                    unique_path = target_year_dir / unique_name
                    if not unique_path.exists():
                        actions.append(f"Created unique name due to conflicts: {conflicts}")
                        return unique_path, "unique_name_created", actions
                    counter += 1
        
        return final_target, "unknown_collision", actions
    
    def merge_directories(self, source_dir: Path, target_dir: Path) -> List[str]:
        """Merge source directory into target directory.
        
        Returns:
            List of actions taken during merge
        """
        actions = []
        
        for item in source_dir.iterdir():
            target_item = target_dir / item.name
            
            if not target_item.exists():
                # Simple move
                if self.dry_run:
                    actions.append(f"Would move {item.name} to target")
                else:
                    shutil.move(str(item), str(target_item))
                    actions.append(f"Moved {item.name} to target")
            else:
                # Item exists in target, skip (we already checked for conflicts)
                actions.append(f"Skipped {item.name} (already exists in target)")
        
        return actions
    
    def process_directory(self, dir_path: Path, base_dir: Path) -> Tuple[bool, str]:
        """Process a single directory."""
        try:
            # Extract year information
            year, pattern_desc, matched_text = self.extract_year_info(dir_path.name)
            
            if year is None:
                print(f"  ⚠️  No year pattern found in: {dir_path.name}")
                self.stats['skipped_directories'] += 1
                return True, "no_year_pattern"
            
            # Track pattern usage and years found
            if pattern_desc not in self.stats['year_patterns_found']:
                self.stats['year_patterns_found'][pattern_desc] = 0
            self.stats['year_patterns_found'][pattern_desc] += 1
            self.stats['years_found'].add(year)
            
            # Generate year directory name
            year_dir_name = self.generate_year_directory_name(year)
            year_dir = base_dir / year_dir_name
            
            # Handle collisions
            final_target, collision_status, actions = self.handle_directory_collision(dir_path, year_dir)
            
            if self.dry_run:
                print(f"  [DRY RUN] Would create year directory: {year_dir_name}")
                print(f"  [DRY RUN] Would move: {dir_path.name} → {year_dir_name}/{final_target.name}")
                print(f"    Pattern matched: '{matched_text}' ({pattern_desc})")
                print(f"    Collision status: {collision_status}")
                
                if actions:
                    for action in actions:
                        print(f"    Action: {action}")
                
                if collision_status == "merge_safe":
                    merge_actions = self.merge_directories(dir_path, final_target)
                    for action in merge_actions:
                        print(f"    Merge: {action}")
            else:
                # Create year directory
                year_dir.mkdir(exist_ok=True)
                if not year_dir.exists():
                    self.stats['created_year_directories'] += 1
                
                # Handle the move based on collision status
                if collision_status == "merge_safe":
                    # Merge directories
                    try:
                        merge_actions = self.merge_directories(dir_path, final_target)
                        
                        # Remove empty source directory
                        try:
                            dir_path.rmdir()
                            print(f"  ✅ Merged: {dir_path.name} → {year_dir_name}/{final_target.name}")
                            self.stats['merged_directories'] += 1
                        except OSError:
                            print(f"  ⚠️  Could not remove source directory {dir_path.name} (not empty)")
                    except Exception as e:
                        error_msg = f"Error merging {dir_path.name}: {e}"
                        self.stats['errors'].append(error_msg)
                        print(f"  ❌ {error_msg}")
                        return False, str(e)
                else:
                    # Regular move
                    try:
                        shutil.move(str(dir_path), str(final_target))
                        print(f"  ✅ Moved: {dir_path.name} → {year_dir_name}/{final_target.name}")
                    except Exception as e:
                        error_msg = f"Error moving {dir_path.name}: {e}"
                        self.stats['errors'].append(error_msg)
                        print(f"  ❌ {error_msg}")
                        return False, str(e)
                
                print(f"    Pattern matched: '{matched_text}' ({pattern_desc})")
                print(f"    Collision status: {collision_status}")
                
                if actions:
                    for action in actions:
                        print(f"    Action: {action}")
            
            self.stats['processed_directories'] += 1
            return True, "success"
            
        except Exception as e:
            error_msg = f"Error processing {dir_path.name}: {e}"
            self.stats['errors'].append(error_msg)
            print(f"  ❌ {error_msg}")
            return False, str(e)
    
    def process_base_directory(self, source_dir: Path) -> bool:
        """Process all directories in the specified base directory."""
        if not source_dir.exists():
            print(f"Error: Directory '{source_dir}' does not exist.")
            return False
        
        if not source_dir.is_dir():
            print(f"Error: '{source_dir}' is not a directory.")
            return False
        
        # Determine base directory for year organization
        base_dir = self.base_dir if self.base_dir else source_dir
        
        print(f"Processing directories in: {source_dir}")
        if base_dir != source_dir:
            print(f"Year directories will be created in: {base_dir}")
        if self.dry_run:
            print("DRY RUN MODE - No directories will be moved")
        print(f"Year range: {self.year_range[0]}-{self.year_range[1]}")
        print()
        
        # Get all directories (not files)
        all_items = [item for item in source_dir.iterdir()]
        directories = [item for item in all_items if item.is_dir()]
        
        self.stats['total_directories'] = len(directories)
        
        if not directories:
            print("No directories found to process.")
            return True
        
        print(f"Found {len(directories)} directories to process:")
        
        # Process each directory
        for i, dir_path in enumerate(directories, 1):
            print(f"[{i}/{len(directories)}] Processing: {dir_path.name}")
            success, message = self.process_directory(dir_path, base_dir)
            
            if not success:
                self.stats['skipped_directories'] += 1
        
        # Print summary
        self.print_summary()
        return True
    
    def print_summary(self) -> None:
        """Print processing summary and statistics."""
        print("\n" + "=" * 60)
        print("PROCESSING SUMMARY")
        print("=" * 60)
        
        print(f"Total directories found: {self.stats['total_directories']}")
        
        if self.dry_run:
            print(f"Directories that would be processed: {self.stats['processed_directories']}")
            print(f"Year directories that would be created: {self.stats['created_year_directories']}")
            print(f"Directories that would be merged: {self.stats['merged_directories']}")
        else:
            print(f"Directories successfully processed: {self.stats['processed_directories']}")
            print(f"Year directories created: {self.stats['created_year_directories']}")
            print(f"Directories merged: {self.stats['merged_directories']}")
        
        print(f"Directories skipped: {self.stats['skipped_directories']}")
        print(f"Errors encountered: {len(self.stats['errors'])}")
        
        # Year statistics
        if self.stats['years_found']:
            years_list = sorted(self.stats['years_found'])
            print(f"\nYears detected: {', '.join(map(str, years_list))}")
            print(f"Year range: {min(years_list)}-{max(years_list)}")
        
        # Pattern statistics
        if self.stats['year_patterns_found']:
            print("\nYear Patterns Detected:")
            for pattern, count in sorted(self.stats['year_patterns_found'].items()):
                print(f"  {pattern}: {count} directories")
        
        if self.stats['errors']:
            print("\nErrors:")
            for error in self.stats['errors']:
                print(f"  - {error}")
        
        if len(self.stats['errors']) == 0 and self.stats['processed_directories'] > 0:
            print("\n🎉 Year organization completed successfully!")
        elif len(self.stats['errors']) > 0:
            print("\n⚠️  Year organization completed with errors.")
        else:
            print("\n⚪ No directories were processed.")


def main():
    """Main function with argument parsing and execution."""
    parser = argparse.ArgumentParser(
        description="Plex Year Organizer - Organize directories by year",
        epilog="""
Examples:
  %(prog)s                                      # Preview changes in current directory (dry-run default)
  %(prog)s /path/to/media                       # Preview changes in specific directory (dry-run default)
  %(prog)s --execute                            # Actually organize current directory by year
  %(prog)s /path/to/media --execute             # Actually organize specific directory by year
  %(prog)s --execute -y                         # Organize current directory without confirmation
  %(prog)s /path/to/media --execute -y          # Organize specific directory without confirmation
  %(prog)s --base /organized --execute          # Create year dirs in different location (current dir)
  %(prog)s /path/to/media --base /organized --execute # Create year dirs in different location (specific dir)
  %(prog)s --year-range 1980 2025 --execute     # Custom year range (current directory)
  %(prog)s --verbose --execute                  # Show verbose output while organizing
  %(prog)s --debug --execute                    # Show detailed debug output while organizing
  %(prog)s --force --execute                    # Force run in current directory (bypass lock)
  
Cron Usage:
  # Run daily at 2 AM (non-interactive)
  0 2 * * * /usr/local/bin/plex_make_years /path/to/downloads --execute -y
        """,
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument(
        'directory',
        nargs='?',
        default='.',
        help='Directory containing directories to organize by year (default: current directory)'
    )
    parser.add_argument(
        '--base',
        metavar='DIR',
        help='Base directory for year organization (default: same as source)'
    )
    parser.add_argument(
        '--dry-run',
        action='store_true',
        default=True,
        help='Show what would be done without making changes (default)'
    )
    parser.add_argument(
        '--execute',
        action='store_true',
        help='Actually perform operations (overrides --dry-run)'
    )
    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        help='Show verbose output'
    )
    parser.add_argument(
        '--debug',
        action='store_true',
        help='Show detailed debug output'
    )
    parser.add_argument(
        '--force',
        action='store_true',
        help='Force execution even if another instance is running'
    )
    
    parser.add_argument(
        '-y', '--yes',
        action='store_true',
        help='Skip confirmation prompts (for non-interactive use)'
    )
    parser.add_argument(
        '--year-range',
        nargs=2,
        type=int,
        metavar=('START', 'END'),
        default=[1900, 2030],
        help='Valid year range (default: 1900-2030)'
    )
    parser.add_argument(
        '--list-patterns',
        action='store_true',
        help='List all supported year detection patterns and exit'
    )
    parser.add_argument(
        '--no-banner',
        action='store_true',
        help='Suppress banner display'
    )
    parser.add_argument(
        '--version',
        action='version',
        version=f'%(prog)s v{VERSION}'
    )
    
    args = parser.parse_args()
    
    # Handle debug mode (enables verbose)
    if args.debug:
        args.verbose = True
    
    # Handle --list-patterns
    if args.list_patterns:
        # Read global configuration for banner display
        quiet_mode = read_global_config_bool('QUIET_MODE', False)
        
        # Display banner before listing patterns
        display_banner("plex_make_years", "2.1.0", 
                      "create year-based directory structures for movies",
                      args.no_banner, quiet_mode)
        
        organizer = YearOrganizer()
        print("Supported year detection patterns:")
        for pattern, description in organizer.year_patterns:
            print(f"  {description}: {pattern}")
        print("\nExample matches:")
        examples = [
            "Movie.Title.(2023)",
            "Another.Movie.[2022]",
            "Show.2021.Season.1",
            "Film.Title.2020.1080p",
            "2019.Movie.Title",
            "Movie_2018_BluRay"
        ]
        for example in examples:
            year, pattern_desc, matched = organizer.extract_year_info(example)
            if year:
                print(f"  '{example}' → {year} ({pattern_desc})")
        sys.exit(0)
    
    # Read global configuration
    auto_execute = read_global_config_bool('AUTO_EXECUTE', False)
    auto_confirm = read_global_config_bool('AUTO_CONFIRM', False)
    quiet_mode = read_global_config_bool('QUIET_MODE', False)
    
    # Apply global configuration (CLI arguments take precedence)
    if auto_execute and not args.execute:
        args.execute = True  # Override dry_run if AUTO_EXECUTE is set
    if auto_confirm and not args.yes:
        args.yes = True  # Set yes flag if AUTO_CONFIRM is set
    
    # Determine dry-run mode
    if args.execute:
        dry_run_mode = False
    else:
        dry_run_mode = args.dry_run  # This is True by default
    
    # Validate arguments
    if args.yes and dry_run_mode:
        print("Warning: -y/--yes flag has no effect in dry-run mode", file=sys.stderr)
    
    # Validate year range
    if args.year_range[0] >= args.year_range[1]:
        print("Error: Start year must be less than end year.")
        sys.exit(1)
    
    # Display banner
    display_banner("plex_make_years", "2.1.0", 
                  "create year-based directory structures for movies",
                  args.no_banner, quiet_mode)
    
    if dry_run_mode:
        print("DRY-RUN MODE: No changes will be made")
    else:
        print("EXECUTE MODE: Changes will be made")
    
    if args.debug:
        print("Debug: ENABLED")
    elif args.verbose:
        print("Verbose: ENABLED")
    print()
    
    # Create organizer instance
    base_dir = Path(args.base).resolve() if args.base else None
    organizer = YearOrganizer(
        dry_run=dry_run_mode,
        force=args.force,
        base_dir=base_dir,
        year_range=tuple(args.year_range)
    )
    
    # Confirmation logic for non-interactive environments
    if not dry_run_mode:
        source_dir = Path(args.directory).resolve()
        if not args.yes and not is_non_interactive():
            print(f"About to organize directories by year in: {source_dir}")
            if base_dir and base_dir != source_dir:
                print(f"Year directories will be created in: {base_dir}")
            print(f"Year range: {args.year_range[0]}-{args.year_range[1]}")
            
            response = input("\nProceed with directory organization? [y/N]: ")
            if response.lower() not in ['y', 'yes']:
                print("Operation cancelled.")
                sys.exit(0)
        elif args.yes or is_non_interactive():
            print(f"Proceeding with directory organization in: {source_dir}")
            if base_dir and base_dir != source_dir:
                print(f"Year directories will be created in: {base_dir}")
    
    try:
        # Acquire lock
        if not organizer.acquire_lock():
            sys.exit(1)
        
        # Process directory
        source_dir = Path(args.directory).resolve()
        success = organizer.process_base_directory(source_dir)
        
        sys.exit(0 if success else 1)
        
    except KeyboardInterrupt:
        print("\nOperation cancelled by user.")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)
    finally:
        organizer.release_lock()


if __name__ == '__main__':
    main()