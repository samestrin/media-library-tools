#!/usr/bin/env python3
"""
Plex Season Organizer

A Python tool for organizing TV show episodes into season-specific directories.
This script analyzes video filenames to extract season information and automatically
creates proper season directory structures that are ideal for Plex media organization.

Features:
- Intelligent season detection from various filename patterns
- Automatic season directory creation
- File collision handling with unique naming
- Support for multiple season naming conventions
- File-based locking mechanism
- Dry-run mode for safe testing
- Progress tracking and detailed statistics
- Cron-friendly operation

Author: Media Library Tools Project
Version: 2.1.0
"""

import argparse
import os
import re
import shutil
import sys
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple, Union

VERSION = "2.1.0"

# ======================================================

# ======================================================
# INJECTED MODULE - START
# Generated by build.py v3.0.0
# Source: utils.py
# ======================================================

"""
Shared Utility Module for Media Library Tools

This module contains common functions used across multiple media library tools.
It consolidates duplicated functionality to improve maintainability and consistency.

Functions:
- display_banner(): Display standardized banner with script information
- is_non_interactive(): Detect non-interactive environments (cron, CI, etc.)
- read_global_config_bool(): Read boolean configuration from environment variables and .env files
- format_size(): Convert bytes to human-readable format
- confirm_action(): Prompt user for confirmation with skip option
- acquire_lock(): File locking functionality for preventing concurrent executions
- release_lock(): Release file locks with proper cleanup

Author: Media Library Tools Project
Version: 1.0.0
"""

import contextlib
import os
import platform
import sys
import tempfile
from pathlib import Path
from typing import Optional, Tuple

# Platform-specific imports
try:
    import fcntl  # Unix/Linux/macOS
except ImportError:
    fcntl = None  # Windows

try:
    import msvcrt  # Windows
except ImportError:
    msvcrt = None  # Unix/Linux/macOS


def display_banner(
    script_name: str,
    version: str,
    description: str,
    no_banner_flag: bool = False,
    quiet_mode: bool = False,
) -> None:
    """
    Display standardized banner for media library tools.

    Args:
        script_name: Name of the script
        version: Version string
        description: Brief description of the script
        no_banner_flag: If True, suppress banner display
        quiet_mode: If True, suppress banner display
    """
    # Check suppression conditions (highest to lowest priority)
    if no_banner_flag or quiet_mode or is_non_interactive():
        return

    try:
        # Display standardized ASCII art
        print("‚îè‚î≥‚îì‚îè‚îÅ‚ï∏‚ï∫‚î≥‚îì‚ïª‚îè‚îÅ‚îì‚ïª  ‚ïª‚îè‚îì ‚îè‚îÅ‚îì‚îè‚îÅ‚îì‚îè‚îÅ‚îì‚ïª ‚ïª‚ï∫‚î≥‚ï∏‚îè‚îÅ‚îì‚îè‚îÅ‚îì‚ïª  ‚îè‚îÅ‚îì")
        print("‚îÉ‚îÉ‚îÉ‚î£‚ï∏  ‚îÉ‚îÉ‚îÉ‚î£‚îÅ‚î´‚îÉ  ‚îÉ‚î£‚îª‚îì‚î£‚î≥‚îõ‚î£‚îÅ‚î´‚î£‚î≥‚îõ‚îó‚î≥‚îõ ‚îÉ ‚îÉ ‚îÉ‚îÉ ‚îÉ‚îÉ  ‚îó‚îÅ‚îì")
        print("‚ïπ ‚ïπ‚îó‚îÅ‚ï∏‚ï∫‚îª‚îõ‚ïπ‚ïπ ‚ïπ‚îó‚îÅ‚ï∏‚ïπ‚îó‚îÅ‚îõ‚ïπ‚îó‚ï∏‚ïπ ‚ïπ‚ïπ‚îó‚ï∏ ‚ïπ  ‚ïπ ‚îó‚îÅ‚îõ‚îó‚îÅ‚îõ‚îó‚îÅ‚ï∏‚îó‚îÅ‚îõ")
        print(f"{script_name} v{version}: {description}")
        print()  # Blank line for separation
    except Exception:
        # Banner display errors should not prevent script execution
        pass


def is_non_interactive() -> bool:
    """
    Detect if running in non-interactive environment (cron, etc.).

    Returns:
        True if non-interactive, False otherwise
    """
    # Check if stdin is not a TTY (common in cron jobs)
    if not sys.stdin.isatty():
        return True

    # Check for common non-interactive environment variables
    non_interactive_vars = ["CRON", "CI", "AUTOMATED", "NON_INTERACTIVE"]
    for var in non_interactive_vars:
        if os.environ.get(var):
            return True

    # Check if TERM is not set or is 'dumb' (common in automated environments)
    term = os.environ.get("TERM", "")
    return bool(not term or term == "dumb")


def read_global_config_bool(var_name: str, default: bool = False) -> bool:
    """
    Read a boolean environment variable with support for .env files.

    Args:
        var_name: Name of the environment variable
        default: Default value if not found

    Returns:
        Boolean value of the environment variable
    """
    # Check environment variable directly
    value = os.environ.get(var_name)
    if value is not None:
        return value.lower() in ("true", "1", "yes", "on")

    # Check local .env file
    env_file = ".env"
    if os.path.exists(env_file):
        try:
            with open(env_file) as f:
                for line in f:
                    line = line.strip()
                    if line.startswith(f"{var_name}="):
                        value = line.split("=", 1)[1].strip()
                        return value.lower() in ("true", "1", "yes", "on")
        except OSError:
            pass

    # Check global .env file
    global_env_path = Path.home() / ".media-library-tools" / ".env"
    if global_env_path.exists():
        try:
            with open(global_env_path) as f:
                for line in f:
                    line = line.strip()
                    if line.startswith(f"{var_name}="):
                        value = line.split("=", 1)[1].strip()
                        return value.lower() in ("true", "1", "yes", "on")
        except OSError:
            pass

    return default


def is_windows() -> bool:
    """
    Detect if running on Windows platform.

    Returns:
        True if running on Windows, False otherwise
    """
    return platform.system().lower() == "windows"


def should_use_emojis() -> bool:
    """
    Determine if emojis should be used based on platform and environment.

    Returns:
        True if emojis should be used, False otherwise
    """
    # Don't use emojis on Windows to avoid encoding issues
    if is_windows():
        return False

    # Don't use emojis in non-interactive environments
    if is_non_interactive():
        return False

    # Check for explicit emoji suppression
    return not read_global_config_bool("NO_EMOJIS", False)


def format_size(size_bytes: int) -> str:
    """
    Format size in bytes to human readable format.

    Args:
        size_bytes: Size in bytes

    Returns:
        Human readable size string
    """
    for unit in ["B", "K", "M", "G", "T"]:
        if size_bytes < 1024.0:
            if unit == "B":
                return f"{size_bytes:.0f}{unit}"
            else:
                return f"{size_bytes:.1f}{unit}"
        size_bytes /= 1024.0
    return f"{size_bytes:.1f}P"


def confirm_action(message: str, skip_confirmation: bool = False) -> bool:
    """
    Ask for user confirmation unless skipped.

    Args:
        message: Confirmation message to display
        skip_confirmation: If True, automatically confirm

    Returns:
        True if confirmed, False otherwise
    """
    if skip_confirmation:
        return True

    try:
        response = input(f"{message} (y/N): ").strip().lower()
        return response in ["y", "yes"]
    except (EOFError, KeyboardInterrupt):
        print("\nOperation cancelled.")
        return False


class FileLock:
    """
    File locking utility class for preventing concurrent executions.
    """

    def __init__(self, lock_prefix: str = "media_library_tool"):
        """
        Initialize file lock.

        Args:
            lock_prefix: Prefix for lock file name
        """
        self.lock_prefix = lock_prefix
        self.lock_file = None

    def acquire_lock(self, force: bool = False) -> bool:
        """
        Acquire file lock to prevent multiple instances.

        Args:
            force: If True, skip locking mechanism

        Returns:
            True if lock acquired successfully, False otherwise
        """
        if force:
            return True

        try:
            with tempfile.NamedTemporaryFile(
                mode="w", prefix=f"{self.lock_prefix}_", suffix=".lock", delete=False
            ) as temp_file:
                self.lock_file = temp_file

                # Platform-specific file locking
                if fcntl is not None:  # Unix/Linux/macOS
                    fcntl.flock(self.lock_file.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
                elif msvcrt is not None:  # Windows
                    msvcrt.locking(self.lock_file.fileno(), msvcrt.LK_NBLCK, 1)
                else:
                    # Fallback: no locking available, just proceed
                    pass

                self.lock_file.write(str(os.getpid()))
                self.lock_file.flush()
            return True
        except OSError as e:
            if self.lock_file:
                self.lock_file.close()
                with contextlib.suppress(OSError):
                    os.unlink(self.lock_file.name)
                self.lock_file = None
            print(
                "Error: Another instance is already running. Use --force to override."
            )
            print(f"Lock error: {e}")
            return False

    def release_lock(self) -> None:
        """
        Release the file lock.
        """
        if self.lock_file:
            try:
                # Only unlock if file is still open
                if not self.lock_file.closed:
                    # Platform-specific file unlocking
                    if fcntl is not None:  # Unix/Linux/macOS
                        fcntl.flock(self.lock_file.fileno(), fcntl.LOCK_UN)
                    elif msvcrt is not None:  # Windows
                        msvcrt.locking(self.lock_file.fileno(), msvcrt.LK_UNLCK, 1)
                    # No explicit unlock needed for fallback case

                    self.lock_file.close()
            except (OSError, ValueError):
                # Handle both file system errors and closed file errors
                pass

            # Always try to remove lock file if it exists
            try:
                if os.path.exists(self.lock_file.name):
                    os.unlink(self.lock_file.name)
            except OSError:
                pass
            finally:
                self.lock_file = None


# Legacy standalone functions for backward compatibility
def acquire_lock(
    lock_prefix: str = "media_library_tool", force: bool = False
) -> Tuple[bool, Optional[FileLock]]:
    """
    Legacy function for acquiring file locks.

    Args:
        lock_prefix: Prefix for lock file name
        force: If True, skip locking mechanism

    Returns:
        Tuple of (success: bool, lock_instance: FileLock or None)
    """
    lock = FileLock(lock_prefix)
    success = lock.acquire_lock(force)
    return success, lock if success else None


def release_lock(lock_instance: FileLock) -> None:
    """
    Legacy function for releasing file locks.

    Args:
        lock_instance: FileLock instance to release
    """
    if lock_instance:
        lock_instance.release_lock()


# ======================================================
# INJECTED MODULE - END
# Source: utils.py
# ======================================================



# ======================================================









class SeasonOrganizer:
    """Main class for organizing TV show episodes into season directories."""
    
    def __init__(self, dry_run: bool = False, force: bool = False, 
                 target_dir: Optional[Path] = None, depth: int = 1):
        self.dry_run = dry_run
        self.force = force
        self.target_dir = target_dir
        self.depth = depth
        self.file_lock = FileLock('plex_make_seasons')
        
        # Video file extensions
        self.video_extensions = {
            '.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v',
            '.mpg', '.mpeg', '.3gp', '.ogv', '.ts', '.m2ts', '.vob', '.divx',
            '.xvid', '.rm', '.rmvb', '.asf', '.f4v', '.m4p'
        }
        
        # Season detection patterns (ordered by specificity)
        self.season_patterns = [
            # Standard patterns: S01E01, S1E1, etc. (highest priority)
            (r'[Ss](\d{1,2})[Ee]\d{1,3}', 'S{:02d}E format'),
            (r'[Ss]eason[\s\._-]*(\d{1,2})', 'Season X format'),
            
            # Extended season patterns (high priority) - NEW
            (r'[Ss](\d{3,4})[Ee]\d{1,3}', 'Extended season S###/####E## format'),
            (r'[Ss]eason[\s\._-]*(\d{3,4})', 'Extended Season #### format'),
            
            # Enhanced alternative patterns (medium-high priority)
            (r'(\d{1,3})x\d{1,3}', 'Enhanced season #x# format'),  # Updated range
            (r'[Ss](\d{1,4})\D', 'Enhanced S# format'),  # Updated range
            
            # Numeric-only patterns (medium priority) - NEW
            (r'(?:ep|episode)[\s\-_.]*(\d{1,2})(?:[^\d]|$)', 'Episode-prefixed numeric format'),
            (r'(?:^|[\s\-_.])[^\d]*[\s\-_.](\d{1,2})[\s\-_.](?!\d*(?:p|fps|kbps))', 'Separated numeric format'),
            
            # Year-based seasons (for some shows)
            (r'[\(\[]?(20\d{2})[\)\]]?', 'Year format'),
            
            # Episode numbering patterns
            (r'[Ee]pisode[\s\._-]*(\d{1,3})', 'Episode X format'),
            (r'[Ee]p[\s\._-]*(\d{1,3})', 'Ep X format'),
            
            # Part/Chapter patterns
            (r'[Pp]art[\s\._-]*(\d{1,2})', 'Part X format'),
            (r'[Cc]hapter[\s\._-]*(\d{1,2})', 'Chapter X format'),
            
            # Disc patterns
            (r'[Dd]isc[\s\._-]*(\d{1,2})', 'Disc X format'),
            (r'[Dd](\d{1,2})', 'D1 format'),
            
            # Volume patterns
            (r'[Vv]ol[\s\._-]*(\d{1,2})', 'Vol X format'),
            (r'[Vv](\d{1,2})', 'V1 format'),
        ]
        
        # Statistics tracking
        self.stats = {
            'total_files': 0,
            'video_files': 0,
            'processed_files': 0,
            'skipped_files': 0,
            'created_directories': 0,
            'season_patterns_found': {},
            'errors': []
        }
    
    def acquire_lock(self) -> bool:
        """Acquire file lock to prevent multiple instances."""
        return self.file_lock.acquire_lock(self.force)
    
    def release_lock(self) -> None:
        """Release the file lock."""
        self.file_lock.release_lock()
    
    def is_video_file(self, file_path: Path) -> bool:
        """Check if a file is a video file based on its extension."""
        return file_path.suffix.lower() in self.video_extensions
    
    def find_video_files_with_depth(self, source_dir: Path, max_depth: int) -> List[Path]:
        """Find video files up to a specified depth in the directory structure.
        
        Args:
            source_dir: The directory to search in
            max_depth: Maximum depth to search (1 = only immediate files, 2 = immediate subdirs, etc.)
            
        Returns:
            List of Path objects for video files found within the depth limit
        """
        video_files = []
        
        # Use a queue-based approach to avoid recursion limits
        # Each item in the queue is a tuple of (directory_path, current_depth)
        queue = [(source_dir, 1)]
        
        while queue:
            current_dir, current_depth = queue.pop(0)
            
            # Skip if we've exceeded the maximum depth
            if current_depth > max_depth:
                continue
                
            try:
                # Iterate through items in the current directory
                for item in current_dir.iterdir():
                    if item.is_file() and self.is_video_file(item):
                        # Found a video file
                        video_files.append(item)
                    elif item.is_dir() and current_depth < max_depth:
                        # Add subdirectory to queue for processing
                        queue.append((item, current_depth + 1))
            except (PermissionError, OSError) as e:
                # Skip directories we can't access
                print(f"  Warning: Cannot access directory {current_dir}: {e}")
                continue
                
        return video_files
    
    def validate_numeric_season(self, filename: str, match_text: str, season_num: int, 
                              pattern_desc: str) -> Tuple[bool, float]:
        """
        Validate that a numeric match represents a season, not episode or other identifier.
        
        Args:
            filename: Full filename being analyzed
            match_text: The matched text from regex
            season_num: Extracted season number
            pattern_desc: Pattern description for validation context
        
        Returns:
            Tuple[bool, float]: (is_valid, confidence_score)
        """
        confidence = 0.0
        
        # Quality indicator detection (major false positive source)
        quality_patterns = [
            r'720p', r'1080p', r'480p', r'2160p', r'4K', 
            r'\d+kbps', r'\d+fps', r'HDR', r'DTS', r'AC3',
            r'H\.?264', r'H\.?265', r'x264', r'x265',
            r'HEVC', r'AVC', r'BluRay', r'WEBRip', r'DVDRip'
        ]
        
        filename_lower = filename.lower()
        for pattern in quality_patterns:
            if re.search(pattern, filename_lower, re.IGNORECASE):
                return False, 0.0  # Immediate rejection for quality indicators
        
        # Position validation - avoid numbers at end of filename
        match_pos = filename.find(match_text)
        filename_length = len(filename)
        relative_position = match_pos / filename_length if filename_length > 0 else 0
        
        if relative_position > 0.8:  # Last 20% of filename
            confidence -= 0.5
        elif relative_position < 0.3:  # First 30% of filename
            confidence += 0.3
        
        # Range validation based on pattern type
        if 'Extended' in pattern_desc:
            if not (100 <= season_num <= 2050):
                return False, 0.0
            confidence += 0.4  # Extended patterns are more specific
        elif 'numeric' in pattern_desc.lower():
            if not (1 <= season_num <= 50):
                return False, 0.0
            confidence += 0.2
        elif 'Enhanced' in pattern_desc:
            if not (1 <= season_num <= 500):  # Broader range for alternative formats
                return False, 0.0
            confidence += 0.3
        
        # Context character analysis
        context_start = max(0, match_pos - 3)
        context_end = min(filename_length, match_pos + len(match_text) + 3)
        context = filename[context_start:context_end].lower()
        
        # Positive context indicators
        positive_indicators = ['ep', 'episode', 'season', 'series', '-', '_', '.', ' ']
        negative_indicators = ['p', 'fps', 'kbps', 'bit', 'mb', 'gb']
        
        for indicator in positive_indicators:
            if indicator in context:
                confidence += 0.1
        
        for indicator in negative_indicators:
            if indicator in context:
                confidence -= 0.2
        
        # Filename structure analysis
        if any(sep in filename for sep in [' - ', '.', '_', 'S0', 's0', 'Season', 'season']):
            confidence += 0.2
        
        # Final confidence scoring
        confidence = max(0.0, min(1.0, confidence))  # Clamp to [0.0, 1.0]
        
        # Minimum confidence thresholds
        if 'numeric' in pattern_desc.lower():
            min_confidence = 0.3  # Higher threshold for numeric-only patterns
        else:
            min_confidence = 0.2
        
        return confidence >= min_confidence, confidence

    def extract_season_info(self, filename: str) -> Tuple[Optional[int], str, str]:
        """Extract season information from filename.
        
        Returns:
            Tuple of (season_number, pattern_description, matched_text)
        """
        for pattern, description in self.season_patterns:
            match = re.search(pattern, filename, re.IGNORECASE)
            if match:
                try:
                    season_num = int(match.group(1))
                    matched_text = match.group(0)
                    
                    # Special handling for year-based seasons
                    if 'Year format' in description:
                        if season_num >= 1990:  # Reasonable year range
                            return season_num, description, matched_text
                    
                    # Extended season patterns validation
                    elif 'Extended' in description:
                        if 100 <= season_num <= 2050:
                            return season_num, description, matched_text
                    
                    # Numeric-only patterns require additional validation
                    elif 'numeric' in description.lower():
                        is_valid, confidence = self.validate_numeric_season(
                            filename, matched_text, season_num, description)
                        if is_valid:
                            return season_num, description, matched_text
                    
                    # Enhanced patterns with broader ranges
                    elif 'Enhanced' in description:
                        if 'S#' in description and 1 <= season_num <= 2050:  # S# format with extended range
                            return season_num, description, matched_text
                        elif '#x#' in description and 1 <= season_num <= 500:  # #x# format
                            return season_num, description, matched_text
                    
                    # Standard patterns - original logic
                    elif 1 <= season_num <= 50:  # Reasonable season range for standard patterns
                        return season_num, description, matched_text
                        
                except (ValueError, IndexError):
                    continue
        
        return None, "No pattern matched", ""
    
    def generate_season_directory_name(self, season_num: int, pattern_desc: str) -> str:
        """Generate season directory name based on season number and pattern."""
        if 'Year format' in pattern_desc:
            return f"Season {season_num}"
        elif 'Extended' in pattern_desc or season_num >= 100:
            # For extended seasons (100+), don't zero-pad to avoid "Season 02025"
            return f"Season {season_num}"
        else:
            return f"Season {season_num:02d}"
    
    def handle_file_collision(self, target_file: Path) -> Path:
        """Handle file name collisions by generating unique names."""
        if not target_file.exists():
            return target_file
        
        base_name = target_file.stem
        extension = target_file.suffix
        parent_dir = target_file.parent
        
        counter = 1
        while True:
            new_name = f"{base_name}_{counter}{extension}"
            new_path = parent_dir / new_name
            if not new_path.exists():
                return new_path
            counter += 1
    
    def process_file(self, file_path: Path, base_dir: Path) -> Tuple[bool, str]:
        """Process a single video file."""
        try:
            # Extract season information
            season_num, pattern_desc, matched_text = self.extract_season_info(file_path.name)
            
            if season_num is None:
                print(f"  ‚ö†Ô∏è  No season pattern found in: {file_path.name}")
                self.stats['skipped_files'] += 1
                return True, "no_season_pattern"
            
            # Track pattern usage
            if pattern_desc not in self.stats['season_patterns_found']:
                self.stats['season_patterns_found'][pattern_desc] = 0
            self.stats['season_patterns_found'][pattern_desc] += 1
            
            # Generate season directory name
            season_dir_name = self.generate_season_directory_name(season_num, pattern_desc)
            season_dir = base_dir / season_dir_name
            
            # Handle file collision
            target_file = season_dir / file_path.name
            final_target = self.handle_file_collision(target_file)
            
            collision_info = ""
            if final_target != target_file:
                collision_info = f" (renamed to {final_target.name})"
            
            if self.dry_run:
                print(f"  [DRY RUN] Would create directory: {season_dir_name}")
                print(f"  [DRY RUN] Would move: {file_path.name} ‚Üí {season_dir_name}/{final_target.name}")
                print(f"    Pattern matched: '{matched_text}' ({pattern_desc})")
                if collision_info:
                    print(f"    Collision handling: {collision_info}")
            else:
                # Create season directory
                season_dir.mkdir(exist_ok=True)
                if not season_dir.exists():
                    self.stats['created_directories'] += 1
                
                # Move file
                shutil.move(str(file_path), str(final_target))
                
                print(f"  ‚úÖ Moved: {file_path.name} ‚Üí {season_dir_name}/{final_target.name}")
                print(f"    Pattern matched: '{matched_text}' ({pattern_desc})")
                if collision_info:
                    print(f"    Collision handling: {collision_info}")
            
            self.stats['processed_files'] += 1
            return True, "success"
            
        except Exception as e:
            error_msg = f"Error processing {file_path.name}: {e}"
            self.stats['errors'].append(error_msg)
            print(f"  ‚ùå {error_msg}")
            return False, str(e)
    
    def process_directory(self, source_dir: Path) -> bool:
        """Process all video files in the specified directory."""
        if not source_dir.exists():
            print(f"Error: Directory '{source_dir}' does not exist.")
            return False
        
        if not source_dir.is_dir():
            print(f"Error: '{source_dir}' is not a directory.")
            return False
        
        # Determine target directory
        target_dir = self.target_dir if self.target_dir else source_dir
        
        print(f"Processing video files in: {source_dir}")
        if target_dir != source_dir:
            print(f"Target directory: {target_dir}")
        if self.dry_run:
            print("DRY RUN MODE - No files will be moved")
        print(f"Video extensions: {', '.join(sorted(self.video_extensions))}")
        print(f"Search depth: {self.depth}")
        print()
        
        # Get all video files up to the specified depth
        video_files = self.find_video_files_with_depth(source_dir, self.depth)
        all_files = []  # We don't count all files anymore, just video files
        
        self.stats['total_files'] = len(video_files)
        self.stats['video_files'] = len(video_files)
        
        if not video_files:
            print("No video files found to process.")
            return True
        
        print(f"Found {len(video_files)} video files to process:")
        
        # Process each video file
        for i, file_path in enumerate(video_files, 1):
            print(f"[{i}/{len(video_files)}] Processing: {file_path.name}")
            success, message = self.process_file(file_path, target_dir)
            
            if not success:
                self.stats['skipped_files'] += 1
        
        # Print summary
        self.print_summary()
        return True
    
    def print_summary(self) -> None:
        """Print processing summary and statistics."""
        print("\n" + "=" * 60)
        print("PROCESSING SUMMARY")
        print("=" * 60)
        
        print(f"Video files found: {self.stats['video_files']}")
        
        if self.dry_run:
            print(f"Files that would be processed: {self.stats['processed_files']}")
            print(f"Directories that would be created: {self.stats['created_directories']}")
        else:
            print(f"Files successfully processed: {self.stats['processed_files']}")
            print(f"Season directories created: {self.stats['created_directories']}")
        
        print(f"Files skipped: {self.stats['skipped_files']}")
        print(f"Errors encountered: {len(self.stats['errors'])}")
        
        # Pattern statistics
        if self.stats['season_patterns_found']:
            print("\nSeason Patterns Detected:")
            for pattern, count in sorted(self.stats['season_patterns_found'].items()):
                print(f"  {pattern}: {count} files")
        
        if self.stats['errors']:
            print("\nErrors:")
            for error in self.stats['errors']:
                print(f"  - {error}")
        
        if len(self.stats['errors']) == 0 and self.stats['processed_files'] > 0:
            print("\nüéâ Season organization completed successfully!")
        elif len(self.stats['errors']) > 0:
            print("\n‚ö†Ô∏è  Season organization completed with errors.")
        else:
            print("\n‚ö™ No files were processed.")


def main():
    """Main function with argument parsing and execution."""
    parser = argparse.ArgumentParser(
        description="Plex Season Organizer - Organize TV show episodes into season directories",
        epilog="""
Examples:
  %(prog)s                                      # Preview changes in current directory (dry-run default)
  %(prog)s /path/to/tv/show                     # Preview changes in specific directory (dry-run default)
  %(prog)s --execute                            # Actually organize current directory episodes
  %(prog)s /path/to/tv/show --execute           # Actually organize specific directory episodes
  %(prog)s --execute -y                         # Organize current directory without confirmation
  %(prog)s /path/to/tv/show --execute -y        # Organize specific directory without confirmation
  %(prog)s --target /organized --execute        # Move current directory files to different location
  %(prog)s /path/to/tv/show --target /organized --execute # Move specific directory files to different location
  %(prog)s --depth 2 --execute                  # Search for files up to 2 levels deep
  %(prog)s --depth 3 --execute                  # Search for files up to 3 levels deep
  %(prog)s --verbose --execute                  # Show verbose output while organizing
  %(prog)s --debug --execute                    # Show detailed debug output while organizing
  %(prog)s --force --execute                    # Force run in current directory (bypass lock)
  
Cron Usage:
  # Run daily at 3 AM (non-interactive)
  0 3 * * * /usr/local/bin/plex_make_seasons /path/to/tv/downloads --execute -y
        """,
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument(
        'directory',
        nargs='?',
        default='.',
        help='Directory containing video files to organize (default: current directory)'
    )
    parser.add_argument(
        '--target',
        metavar='DIR',
        help='Target directory for organized files (default: same as source)'
    )
    parser.add_argument(
        '--dry-run',
        action='store_true',
        default=True,
        help='Show what would be done without making changes (default)'
    )
    parser.add_argument(
        '--execute',
        action='store_true',
        help='Actually perform operations (overrides --dry-run)'
    )
    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        help='Show verbose output'
    )
    parser.add_argument(
        '--debug',
        action='store_true',
        help='Show detailed debug output'
    )
    parser.add_argument(
        '--force',
        action='store_true',
        help='Force execution even if another instance is running'
    )
    parser.add_argument(
        '-y', '--yes',
        action='store_true',
        help='Skip confirmation prompts (for non-interactive use)'
    )
    parser.add_argument(
        '--list-patterns',
        action='store_true',
        help='List all supported season detection patterns and exit'
    )
    parser.add_argument(
        '--no-banner',
        action='store_true',
        help='Suppress banner display'
    )
    parser.add_argument(
        '--depth',
        type=int,
        default=1,
        help='Depth level for searching video files (default: 1). Use 2 or higher to search in subdirectories.'
    )
    parser.add_argument(
        '--version',
        action='version',
        version=f'%(prog)s v{VERSION}'
    )
    
    args = parser.parse_args()
    
    # Handle debug mode (enables verbose)
    if args.debug:
        args.verbose = True
    
    # Handle --list-patterns
    if args.list_patterns:
        # Read global configuration for banner display
        quiet_mode = read_global_config_bool('QUIET_MODE', False)
        
        # Display banner before listing patterns
        display_banner("plex_make_seasons", "2.1.0", 
                      "create season directories for TV shows",
                      args.no_banner, quiet_mode)
        
        organizer = SeasonOrganizer()
        print("Supported season detection patterns:")
        for pattern, description in organizer.season_patterns:
            print(f"  {description}: {pattern}")
        print("\nExample matches:")
        examples = [
            "Show.S01E01.Episode.Name.mkv",
            "Show.1x01.Episode.Name.mp4",
            "Show.Season.1.Episode.1.avi",
            "Show.2023.Episode.Name.mp4",
            "Show.Episode.01.mkv",
            "Show.Part.1.mp4"
        ]
        for example in examples:
            season_num, pattern_desc, matched = organizer.extract_season_info(example)
            if season_num:
                print(f"  '{example}' ‚Üí Season {season_num:02d} ({pattern_desc})")
        sys.exit(0)
    
    # Read global configuration
    auto_execute = read_global_config_bool('AUTO_EXECUTE', False)
    auto_confirm = read_global_config_bool('AUTO_CONFIRM', False)
    quiet_mode = read_global_config_bool('QUIET_MODE', False)
    
    # Apply global configuration (CLI arguments take precedence)
    if auto_execute and not args.execute:
        args.execute = True  # Override dry_run if AUTO_EXECUTE is set
    if auto_confirm and not args.yes:
        args.yes = True  # Set yes flag if AUTO_CONFIRM is set
    
    # Determine dry-run mode
    if args.execute:
        dry_run_mode = False
    else:
        dry_run_mode = args.dry_run  # This is True by default
    
    # Validate arguments
    if args.yes and dry_run_mode:
        print("Warning: -y/--yes flag has no effect in dry-run mode", file=sys.stderr)
    
    # Display banner
    display_banner("plex_make_seasons", "2.1.0", 
                  "create season directories for TV shows",
                  args.no_banner, quiet_mode)
    
    if dry_run_mode:
        print("DRY-RUN MODE: No changes will be made")
    else:
        print("EXECUTE MODE: Changes will be made")
    
    if args.debug:
        print("Debug: ENABLED")
    elif args.verbose:
        print("Verbose: ENABLED")
    print()
    
    # Create organizer instance
    target_dir = Path(args.target).resolve() if args.target else None
    organizer = SeasonOrganizer(
        dry_run=dry_run_mode,
        force=args.force,
        target_dir=target_dir,
        depth=args.depth
    )
    
    # Confirmation logic for non-interactive environments
    if not dry_run_mode:
         source_dir = Path(args.directory).resolve()
         if not args.yes and not is_non_interactive():
             print(f"About to organize video files in: {source_dir}")
             if target_dir and target_dir != source_dir:
                 print(f"Files will be moved to: {target_dir}")
             
             response = input("\nProceed with file organization? [y/N]: ")
             if response.lower() not in ['y', 'yes']:
                 print("Operation cancelled.")
                 sys.exit(0)
         elif args.yes or is_non_interactive():
             print(f"Proceeding with file organization in: {source_dir}")
             if target_dir and target_dir != source_dir:
                 print(f"Files will be moved to: {target_dir}")
    
    try:
        # Acquire lock
        if not organizer.acquire_lock():
            sys.exit(1)
        
        # Process directory
        source_dir = Path(args.directory).resolve()
        success = organizer.process_directory(source_dir)
        
        sys.exit(0 if success else 1)
        
    except KeyboardInterrupt:
        print("\nOperation cancelled by user.")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)
    finally:
        organizer.release_lock()


if __name__ == '__main__':
    main()