#!/usr/bin/env python3
"""
Plex Season Organizer

A Python tool for organizing TV show episodes into season-specific directories.
This script analyzes video filenames to extract season information and automatically
creates proper season directory structures that are ideal for Plex media organization.

Features:
- Intelligent season detection from various filename patterns
- Automatic season directory creation
- File collision handling with unique naming
- Support for multiple season naming conventions
- File-based locking mechanism
- Dry-run mode for safe testing
- Progress tracking and detailed statistics
- Cron-friendly operation

Author: Media Library Tools Project
Version: 2.1.0
"""

import argparse
import fcntl
import os
import re
import shutil
import sys
import tempfile
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple, Union


def read_global_config_bool(var_name: str, default: bool = False) -> bool:
    """Read a boolean environment variable with support for .env files.
    
    Args:
        var_name: Name of the environment variable
        default: Default value if not found
        
    Returns:
        Boolean value of the environment variable
    """
    # Check environment variable directly
    value = os.environ.get(var_name)
    if value is not None:
        return value.lower() in ('true', '1', 'yes', 'on')
    
    # Check local .env file
    env_file = '.env'
    if os.path.exists(env_file):
        try:
            with open(env_file, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line.startswith(f'{var_name}='):
                        value = line.split('=', 1)[1].strip()
                        return value.lower() in ('true', '1', 'yes', 'on')
        except (IOError, OSError):
            pass
    
    # Check global .env file
    global_env_path = Path.home() / '.media-library-tools' / '.env'
    if global_env_path.exists():
        try:
            with open(global_env_path, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line.startswith(f'{var_name}='):
                        value = line.split('=', 1)[1].strip()
                        return value.lower() in ('true', '1', 'yes', 'on')
        except (IOError, OSError):
            pass
    
    return default


def is_non_interactive() -> bool:
    """Detect if running in non-interactive environment (cron, etc.).
    
    Returns:
        True if non-interactive, False otherwise
    """
    # Check if stdin is not a TTY (common in cron jobs)
    if not sys.stdin.isatty():
        return True
        
    # Check for common non-interactive environment variables
    non_interactive_vars = ['CRON', 'CI', 'AUTOMATED', 'NON_INTERACTIVE']
    for var in non_interactive_vars:
        if os.environ.get(var):
            return True
            
    # Check if TERM is not set or is 'dumb' (common in automated environments)
    term = os.environ.get('TERM', '')
    if not term or term == 'dumb':
        return True
        
    return False


class SeasonOrganizer:
    """Main class for organizing TV show episodes into season directories."""
    
    def __init__(self, dry_run: bool = False, force: bool = False, 
                 target_dir: Optional[Path] = None):
        self.dry_run = dry_run
        self.force = force
        self.target_dir = target_dir
        self.lock_file = None
        
        # Video file extensions
        self.video_extensions = {
            '.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v',
            '.mpg', '.mpeg', '.3gp', '.ogv', '.ts', '.m2ts', '.vob', '.divx',
            '.xvid', '.rm', '.rmvb', '.asf', '.f4v', '.m4p'
        }
        
        # Season detection patterns (ordered by specificity)
        self.season_patterns = [
            # Standard patterns: S01E01, S1E1, etc.
            (r'[Ss](\d{1,2})[Ee]\d{1,3}', 'S{:02d}E format'),
            (r'[Ss]eason[\s\._-]*(\d{1,2})', 'Season X format'),
            
            # Alternative patterns
            (r'(\d{1,2})x\d{1,3}', '1x01 format'),
            (r'[Ss](\d{1,2})\D', 'S1 format'),
            
            # Year-based seasons (for some shows)
            (r'[\(\[]?(20\d{2})[\)\]]?', 'Year format'),
            
            # Episode numbering patterns
            (r'[Ee]pisode[\s\._-]*(\d{1,3})', 'Episode X format'),
            (r'[Ee]p[\s\._-]*(\d{1,3})', 'Ep X format'),
            
            # Part/Chapter patterns
            (r'[Pp]art[\s\._-]*(\d{1,2})', 'Part X format'),
            (r'[Cc]hapter[\s\._-]*(\d{1,2})', 'Chapter X format'),
            
            # Disc patterns
            (r'[Dd]isc[\s\._-]*(\d{1,2})', 'Disc X format'),
            (r'[Dd](\d{1,2})', 'D1 format'),
            
            # Volume patterns
            (r'[Vv]ol[\s\._-]*(\d{1,2})', 'Vol X format'),
            (r'[Vv](\d{1,2})', 'V1 format'),
        ]
        
        # Statistics tracking
        self.stats = {
            'total_files': 0,
            'video_files': 0,
            'processed_files': 0,
            'skipped_files': 0,
            'created_directories': 0,
            'season_patterns_found': {},
            'errors': []
        }
    
    def acquire_lock(self) -> bool:
        """Acquire file lock to prevent multiple instances."""
        if self.force:
            return True
            
        try:
            self.lock_file = tempfile.NamedTemporaryFile(
                mode='w',
                prefix='plex_make_seasons_',
                suffix='.lock',
                delete=False
            )
            fcntl.flock(self.lock_file.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
            self.lock_file.write(str(os.getpid()))
            self.lock_file.flush()
            return True
        except (IOError, OSError) as e:
            if self.lock_file:
                self.lock_file.close()
                try:
                    os.unlink(self.lock_file.name)
                except OSError:
                    pass
                self.lock_file = None
            print(f"Error: Another instance is already running. Use --force to override.")
            print(f"Lock error: {e}")
            return False
    
    def release_lock(self) -> None:
        """Release the file lock."""
        if self.lock_file:
            try:
                fcntl.flock(self.lock_file.fileno(), fcntl.LOCK_UN)
                self.lock_file.close()
                os.unlink(self.lock_file.name)
            except (IOError, OSError):
                pass
            finally:
                self.lock_file = None
    
    def is_video_file(self, file_path: Path) -> bool:
        """Check if a file is a video file based on its extension."""
        return file_path.suffix.lower() in self.video_extensions
    
    def extract_season_info(self, filename: str) -> Tuple[Optional[int], str, str]:
        """Extract season information from filename.
        
        Returns:
            Tuple of (season_number, pattern_description, matched_text)
        """
        for pattern, description in self.season_patterns:
            match = re.search(pattern, filename, re.IGNORECASE)
            if match:
                try:
                    season_num = int(match.group(1))
                    
                    # Special handling for year-based seasons
                    if 'Year format' in description:
                        # Convert year to season (e.g., 2023 -> Season 2023)
                        if season_num >= 1990:  # Reasonable year range
                            return season_num, description, match.group(0)
                    
                    # For other patterns, ensure reasonable season numbers
                    elif 1 <= season_num <= 50:  # Reasonable season range
                        return season_num, description, match.group(0)
                        
                except (ValueError, IndexError):
                    continue
        
        return None, "No pattern matched", ""
    
    def generate_season_directory_name(self, season_num: int, pattern_desc: str) -> str:
        """Generate season directory name based on season number and pattern."""
        if 'Year format' in pattern_desc:
            return f"Season {season_num}"
        else:
            return f"Season {season_num:02d}"
    
    def handle_file_collision(self, target_file: Path) -> Path:
        """Handle file name collisions by generating unique names."""
        if not target_file.exists():
            return target_file
        
        base_name = target_file.stem
        extension = target_file.suffix
        parent_dir = target_file.parent
        
        counter = 1
        while True:
            new_name = f"{base_name}_{counter}{extension}"
            new_path = parent_dir / new_name
            if not new_path.exists():
                return new_path
            counter += 1
    
    def process_file(self, file_path: Path, base_dir: Path) -> Tuple[bool, str]:
        """Process a single video file."""
        try:
            # Extract season information
            season_num, pattern_desc, matched_text = self.extract_season_info(file_path.name)
            
            if season_num is None:
                print(f"  ‚ö†Ô∏è  No season pattern found in: {file_path.name}")
                self.stats['skipped_files'] += 1
                return True, "no_season_pattern"
            
            # Track pattern usage
            if pattern_desc not in self.stats['season_patterns_found']:
                self.stats['season_patterns_found'][pattern_desc] = 0
            self.stats['season_patterns_found'][pattern_desc] += 1
            
            # Generate season directory name
            season_dir_name = self.generate_season_directory_name(season_num, pattern_desc)
            season_dir = base_dir / season_dir_name
            
            # Handle file collision
            target_file = season_dir / file_path.name
            final_target = self.handle_file_collision(target_file)
            
            collision_info = ""
            if final_target != target_file:
                collision_info = f" (renamed to {final_target.name})"
            
            if self.dry_run:
                print(f"  [DRY RUN] Would create directory: {season_dir_name}")
                print(f"  [DRY RUN] Would move: {file_path.name} ‚Üí {season_dir_name}/{final_target.name}")
                print(f"    Pattern matched: '{matched_text}' ({pattern_desc})")
                if collision_info:
                    print(f"    Collision handling: {collision_info}")
            else:
                # Create season directory
                season_dir.mkdir(exist_ok=True)
                if not season_dir.exists():
                    self.stats['created_directories'] += 1
                
                # Move file
                shutil.move(str(file_path), str(final_target))
                
                print(f"  ‚úÖ Moved: {file_path.name} ‚Üí {season_dir_name}/{final_target.name}")
                print(f"    Pattern matched: '{matched_text}' ({pattern_desc})")
                if collision_info:
                    print(f"    Collision handling: {collision_info}")
            
            self.stats['processed_files'] += 1
            return True, "success"
            
        except Exception as e:
            error_msg = f"Error processing {file_path.name}: {e}"
            self.stats['errors'].append(error_msg)
            print(f"  ‚ùå {error_msg}")
            return False, str(e)
    
    def process_directory(self, source_dir: Path) -> bool:
        """Process all video files in the specified directory."""
        if not source_dir.exists():
            print(f"Error: Directory '{source_dir}' does not exist.")
            return False
        
        if not source_dir.is_dir():
            print(f"Error: '{source_dir}' is not a directory.")
            return False
        
        # Determine target directory
        target_dir = self.target_dir if self.target_dir else source_dir
        
        print(f"Processing video files in: {source_dir}")
        if target_dir != source_dir:
            print(f"Target directory: {target_dir}")
        if self.dry_run:
            print("DRY RUN MODE - No files will be moved")
        print(f"Video extensions: {', '.join(sorted(self.video_extensions))}")
        print()
        
        # Get all files in the directory (not subdirectories)
        all_files = [f for f in source_dir.iterdir() if f.is_file()]
        video_files = [f for f in all_files if self.is_video_file(f)]
        
        self.stats['total_files'] = len(all_files)
        self.stats['video_files'] = len(video_files)
        
        if not video_files:
            print("No video files found to process.")
            return True
        
        print(f"Found {len(video_files)} video files to process (out of {len(all_files)} total files):")
        
        # Process each video file
        for i, file_path in enumerate(video_files, 1):
            print(f"[{i}/{len(video_files)}] Processing: {file_path.name}")
            success, message = self.process_file(file_path, target_dir)
            
            if not success:
                self.stats['skipped_files'] += 1
        
        # Print summary
        self.print_summary()
        return True
    
    def print_summary(self) -> None:
        """Print processing summary and statistics."""
        print("\n" + "=" * 60)
        print("PROCESSING SUMMARY")
        print("=" * 60)
        
        print(f"Total files found: {self.stats['total_files']}")
        print(f"Video files found: {self.stats['video_files']}")
        
        if self.dry_run:
            print(f"Files that would be processed: {self.stats['processed_files']}")
            print(f"Directories that would be created: {self.stats['created_directories']}")
        else:
            print(f"Files successfully processed: {self.stats['processed_files']}")
            print(f"Season directories created: {self.stats['created_directories']}")
        
        print(f"Files skipped: {self.stats['skipped_files']}")
        print(f"Errors encountered: {len(self.stats['errors'])}")
        
        # Pattern statistics
        if self.stats['season_patterns_found']:
            print("\nSeason Patterns Detected:")
            for pattern, count in sorted(self.stats['season_patterns_found'].items()):
                print(f"  {pattern}: {count} files")
        
        if self.stats['errors']:
            print("\nErrors:")
            for error in self.stats['errors']:
                print(f"  - {error}")
        
        if len(self.stats['errors']) == 0 and self.stats['processed_files'] > 0:
            print("\nüéâ Season organization completed successfully!")
        elif len(self.stats['errors']) > 0:
            print("\n‚ö†Ô∏è  Season organization completed with errors.")
        else:
            print("\n‚ö™ No files were processed.")


def main():
    """Main function with argument parsing and execution."""
    parser = argparse.ArgumentParser(
        description="Plex Season Organizer - Organize TV show episodes into season directories",
        epilog="""
Examples:
  %(prog)s                                      # Preview changes in current directory (dry-run default)
  %(prog)s /path/to/tv/show                     # Preview changes in specific directory (dry-run default)
  %(prog)s --execute                            # Actually organize current directory episodes
  %(prog)s /path/to/tv/show --execute           # Actually organize specific directory episodes
  %(prog)s --execute -y                         # Organize current directory without confirmation
  %(prog)s /path/to/tv/show --execute -y        # Organize specific directory without confirmation
  %(prog)s --target /organized --execute        # Move current directory files to different location
  %(prog)s /path/to/tv/show --target /organized --execute # Move specific directory files to different location
  %(prog)s --verbose --execute                  # Show verbose output while organizing
  %(prog)s --debug --execute                    # Show detailed debug output while organizing
  %(prog)s --force --execute                    # Force run in current directory (bypass lock)
  
Cron Usage:
  # Run daily at 3 AM (non-interactive)
  0 3 * * * /usr/local/bin/plex_make_seasons /path/to/tv/downloads --execute -y
        """,
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument(
        'directory',
        nargs='?',
        default='.',
        help='Directory containing video files to organize (default: current directory)'
    )
    parser.add_argument(
        '--target',
        metavar='DIR',
        help='Target directory for organized files (default: same as source)'
    )
    parser.add_argument(
        '--dry-run',
        action='store_true',
        default=True,
        help='Show what would be done without making changes (default)'
    )
    parser.add_argument(
        '--execute',
        action='store_true',
        help='Actually perform operations (overrides --dry-run)'
    )
    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        help='Show verbose output'
    )
    parser.add_argument(
        '--debug',
        action='store_true',
        help='Show detailed debug output'
    )
    parser.add_argument(
        '--force',
        action='store_true',
        help='Force execution even if another instance is running'
    )
    parser.add_argument(
        '-y', '--yes',
        action='store_true',
        help='Skip confirmation prompts (for non-interactive use)'
    )
    parser.add_argument(
        '--list-patterns',
        action='store_true',
        help='List all supported season detection patterns and exit'
    )
    parser.add_argument(
        '--version',
        action='version',
        version='%(prog)s 2.1.0'
    )
    
    args = parser.parse_args()
    
    # Handle debug mode (enables verbose)
    if args.debug:
        args.verbose = True
    
    # Handle --list-patterns
    if args.list_patterns:
        organizer = SeasonOrganizer()
        print("Supported season detection patterns:")
        for pattern, description in organizer.season_patterns:
            print(f"  {description}: {pattern}")
        print("\nExample matches:")
        examples = [
            "Show.S01E01.Episode.Name.mkv",
            "Show.1x01.Episode.Name.mp4",
            "Show.Season.1.Episode.1.avi",
            "Show.2023.Episode.Name.mp4",
            "Show.Episode.01.mkv",
            "Show.Part.1.mp4"
        ]
        for example in examples:
            season_num, pattern_desc, matched = organizer.extract_season_info(example)
            if season_num:
                print(f"  '{example}' ‚Üí Season {season_num:02d} ({pattern_desc})")
        sys.exit(0)
    
    # Read global configuration
    auto_execute = read_global_config_bool('AUTO_EXECUTE', False)
    auto_confirm = read_global_config_bool('AUTO_CONFIRM', False)
    
    # Apply global configuration (CLI arguments take precedence)
    if auto_execute and not args.execute:
        args.execute = True  # Override dry_run if AUTO_EXECUTE is set
    if auto_confirm and not args.yes:
        args.yes = True  # Set yes flag if AUTO_CONFIRM is set
    
    # Determine dry-run mode
    if args.execute:
        dry_run_mode = False
    else:
        dry_run_mode = args.dry_run  # This is True by default
    
    # Validate arguments
    if args.yes and dry_run_mode:
        print("Warning: -y/--yes flag has no effect in dry-run mode", file=sys.stderr)
    
    # Show mode indicators
    print(f"Plex Season Organizer v2.1.0")
    print("=" * 50)
    
    if dry_run_mode:
        print("DRY-RUN MODE: No changes will be made")
    else:
        print("EXECUTE MODE: Changes will be made")
    
    if args.debug:
        print("Debug: ENABLED")
    elif args.verbose:
        print("Verbose: ENABLED")
    print()
    
    # Create organizer instance
    target_dir = Path(args.target).resolve() if args.target else None
    organizer = SeasonOrganizer(
        dry_run=dry_run_mode,
        force=args.force,
        target_dir=target_dir
    )
    
    # Confirmation logic for non-interactive environments
    if not dry_run_mode:
         source_dir = Path(args.directory).resolve()
         if not args.yes and not is_non_interactive():
             print(f"About to organize video files in: {source_dir}")
             if target_dir and target_dir != source_dir:
                 print(f"Files will be moved to: {target_dir}")
             
             response = input("\nProceed with file organization? [y/N]: ")
             if response.lower() not in ['y', 'yes']:
                 print("Operation cancelled.")
                 sys.exit(0)
         elif args.yes or is_non_interactive():
             print(f"Proceeding with file organization in: {source_dir}")
             if target_dir and target_dir != source_dir:
                 print(f"Files will be moved to: {target_dir}")
    
    try:
        # Acquire lock
        if not organizer.acquire_lock():
            sys.exit(1)
        
        # Process directory
        source_dir = Path(args.directory).resolve()
        success = organizer.process_directory(source_dir)
        
        sys.exit(0 if success else 1)
        
    except KeyboardInterrupt:
        print("\nOperation cancelled by user.")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)
    finally:
        organizer.release_lock()


if __name__ == '__main__':
    main()