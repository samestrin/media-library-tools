#!/usr/bin/env python3
"""
Plex Movie Extras Organizer

A tool for organizing movie extras (featurettes, deleted scenes, etc.) according to
Plex naming conventions. This script moves and renames extra files from subdirectories
into the main movie directory with proper Plex-compatible naming.

Features:
- Moves extras from subdirectories to main movie directory
- Renames files with Plex-compatible naming conventions
- Handles multiple files with sequential numbering
- Dry-run mode for safe testing
- Cron-friendly operation with non-interactive detection
- File locking to prevent concurrent executions

Author: Media Library Tools Project
Version: 2.1.0
"""

import argparse
import fcntl
import os
import shutil
import sys
import tempfile
from pathlib import Path
from typing import List, Optional, Tuple




class PlexMovieExtrasOrganizer:
    """Main class for organizing Plex movie extras."""
    
    def __init__(self, dry_run: bool = False, force: bool = False, verbose: bool = False):
        self.dry_run = dry_run
        self.force = force
        self.verbose = verbose
        self.lock_file = None
        
        # Video file extensions for validation
        self.video_extensions = {
            '.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v',
            '.mpg', '.mpeg', '.3gp', '.ogv', '.ts', '.m2ts', '.vob', '.divx',
            '.xvid', '.rm', '.rmvb', '.asf', '.f4v', '.m4p'
        }
    
    def acquire_lock(self) -> bool:
        """Acquire file lock to prevent multiple instances."""
        if self.force:
            return True
            
        try:
            self.lock_file = tempfile.NamedTemporaryFile(
                mode='w',
                prefix='plex_move_movie_extras_',
                suffix='.lock',
                delete=False
            )
            fcntl.flock(self.lock_file.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
            self.lock_file.write(str(os.getpid()))
            self.lock_file.flush()
            return True
        except (IOError, OSError) as e:
            if self.lock_file:
                self.lock_file.close()
                try:
                    os.unlink(self.lock_file.name)
                except OSError:
                    pass
                self.lock_file = None
            print(f"Error: Another instance is already running. Use --force to override.")
            if self.verbose:
                print(f"Lock error: {e}")
            return False
    
    def release_lock(self) -> None:
        """Release the file lock."""
        if self.lock_file:
            try:
                fcntl.flock(self.lock_file.fileno(), fcntl.LOCK_UN)
                self.lock_file.close()
                os.unlink(self.lock_file.name)
            except (IOError, OSError):
                pass
            finally:
                self.lock_file = None
    
    def is_video_file(self, file_path: str) -> bool:
        """Check if a file is a video file based on its extension.
        
        Args:
            file_path: Path to the file to check
            
        Returns:
            True if file is a video file, False otherwise
        """
        file_extension = os.path.splitext(file_path)[1].lower()
        return file_extension in self.video_extensions

    def organize_extras(self, main_file: str, sub_dir: str) -> bool:
        """Organize movie extras from subdirectory to main directory."""
        if not os.path.isfile(main_file):
            print(f"Error: main file '{main_file}' does not exist.")
            return False

        # Validate main file is a video file
        if not self.is_video_file(main_file):
            print(f"Error: main file '{main_file}' is not a supported video file.")
            print(f"Supported video extensions: {', '.join(sorted(self.video_extensions))}")
            return False

        movie_dir = os.path.dirname(main_file)
        base_name = os.path.splitext(os.path.basename(main_file))[0]
        extras_dir = os.path.join(movie_dir, sub_dir)

        if not os.path.isdir(extras_dir):
            print(f"Error: sub-directory '{sub_dir}' does not exist.")
            return False

        files = sorted(os.listdir(extras_dir))
        count = 1

        for file in files:
            src_path = os.path.join(extras_dir, file)
            if os.path.isdir(src_path):
                continue  # skip nested folders

            # Validate file is a video file
            if not self.is_video_file(src_path):  # Use src_path to check the full path
                print(f"Warning: Skipping non-video file '{file}'")
                continue

            ext = os.path.splitext(file)[1]
            safe_sub = sub_dir.lower().replace(" ", "")
            suffix = f"-{safe_sub}"

            if len(files) > 1:
                new_name = f"{base_name} - {sub_dir} {count:02d}{suffix}{ext}"
            else:
                new_name = f"{base_name} - {sub_dir}{suffix}{ext}"

            dest_path = os.path.join(movie_dir, new_name)

            if self.dry_run:
                print(f"[DRY RUN] Would rename:\\n  '{src_path}'\\n  => '{dest_path}'")
            else:
                try:
                    shutil.move(src_path, dest_path)
                    print(f"Renamed:\n  '{src_path}'\n  => '{dest_path}'")
                except Exception as e:
                    print(f"Error moving '{src_path}' to '{dest_path}': {e}")
                    return False
            count += 1

        if not self.dry_run:
            try:
                os.rmdir(extras_dir)
                print(f"Removed empty directory: {extras_dir}")
            except OSError:
                print(f"Note: Directory not empty or not removed: {extras_dir}")
        
        return True

def confirm_action(message: str, skip_confirmation: bool = False) -> bool:
    """Ask for user confirmation unless skipped.
    
    Args:
        message: Confirmation message to display
        skip_confirmation: If True, automatically confirm
        
    Returns:
        True if confirmed, False otherwise
    """
    if skip_confirmation:
        return True
        
    try:
        response = input(f"{message} (y/N): ").strip().lower()
        return response in ['y', 'yes']
    except (EOFError, KeyboardInterrupt):
        print("\nOperation cancelled.")
        return False


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Move and rename movie extras to match Plex naming conventions",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Preview what would be moved (dry run)
  %(prog)s "Movie (2023).mkv" "Featurettes" --dry-run
  
  # Actually move files with confirmation
  %(prog)s "Movie (2023).mkv" "Deleted Scenes"
  
  # Move files without confirmation (for automation)
  %(prog)s "Movie (2023).mkv" "Behind the Scenes" -y
  

"""
    )
    
    parser.add_argument(
        "main_file", 
        help="Main movie file path"
    )
    parser.add_argument(
        "sub_dir", 
        help="Subdirectory name containing extras (e.g., 'Featurettes', 'Deleted Scenes')"
    )
    parser.add_argument(
        "--dry-run", 
        action="store_true", 
        help="Preview changes without modifying files"
    )
    parser.add_argument(
        "-y", "--yes", 
        action="store_true", 
        help="Skip confirmation prompts (useful for automation/cron)"
    )
    parser.add_argument(
        "--force", 
        action="store_true", 
        help="Force execution even if another instance is running"
    )
    parser.add_argument(
        "--verbose", 
        action="store_true", 
        help="Enable verbose output for debugging"
    )
    parser.add_argument(
        "--debug", 
        action="store_true", 
        help="Enable debug output (implies --verbose)"
    )
    parser.add_argument(
        "--version", 
        action="version", 
        version="%(prog)s 2.1.0"
    )
    
    args = parser.parse_args()
    
    # Handle debug mode
    if args.debug:
        args.verbose = True
    
    # Validate arguments
    if not os.path.exists(args.main_file):
        print(f"Error: Main file '{args.main_file}' does not exist.")
        sys.exit(1)
    
    if not os.path.isfile(args.main_file):
        print(f"Error: '{args.main_file}' is not a file.")
        sys.exit(1)
    
    # Check if subdirectory exists relative to main file
    main_file_dir = os.path.dirname(os.path.abspath(args.main_file))
    sub_dir_path = os.path.join(main_file_dir, args.sub_dir)
    
    if not os.path.exists(sub_dir_path):
        print(f"Error: Subdirectory '{args.sub_dir}' does not exist in '{main_file_dir}'.")
        sys.exit(1)
    
    if not os.path.isdir(sub_dir_path):
        print(f"Error: '{args.sub_dir}' is not a directory.")
        sys.exit(1)
    
    # Create organizer instance
    organizer = PlexMovieExtrasOrganizer(
        dry_run=args.dry_run,
        force=args.force,
        verbose=args.verbose
    )
    
    # Acquire lock
    if not organizer.acquire_lock():
        sys.exit(1)
    
    try:
        # Show what will be done
        if args.verbose:
            print(f"Main file: {args.main_file}")
            print(f"Subdirectory: {args.sub_dir}")
            print(f"Mode: {'DRY RUN' if args.dry_run else 'EXECUTE'}")
            print("-" * 50)
        
        # Confirm action unless in dry-run mode or confirmation skipped
        if not args.dry_run:
            if not confirm_action(
                f"Move extras from '{args.sub_dir}' to main movie directory?",
                args.yes
            ):
                print("Operation cancelled.")
                sys.exit(0)
        
        # Execute the organization
        success = organizer.organize_extras(args.main_file, sub_dir_path)
        
        if success:
            if args.dry_run:
                print("\nDry run completed successfully. Use without --dry-run to execute.")
            else:
                print("\nMovie extras organized successfully!")
        else:
            print("\nOperation failed. Check error messages above.")
            sys.exit(1)
            
    except KeyboardInterrupt:
        print("\nOperation cancelled by user.")
        sys.exit(1)
    except Exception as e:
        print(f"\nUnexpected error: {e}")
        if args.debug:
            import traceback
            traceback.print_exc()
        sys.exit(1)
    finally:
        organizer.release_lock()


if __name__ == "__main__":
    main()
