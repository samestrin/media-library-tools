#!/usr/bin/env python3
"""
Plex Movie Subdirectory Renamer

A tool for renaming movie featurettes and extras in subdirectories according to
Plex naming conventions. This script processes video files in a subdirectory and
renames them with proper Plex-compatible naming patterns.

Features:
- Renames featurettes with Plex-compatible naming conventions
- Auto-detects movie name from parent directory
- Handles multiple files with sequential numbering
- Categorizes different types of extras (featurettes, deleted scenes, etc.)
- Dry-run mode for safe testing
- Cron-friendly operation with non-interactive detection
- File locking to prevent concurrent executions

Author: Media Library Tools Project
Version: 2.1.0
"""

import argparse
import fcntl
import os
import re
import sys
import tempfile
from pathlib import Path
from typing import Dict, List, Optional, Tuple

def get_plex_naming_convention():
    """
    Plex naming conventions for extras:
    - behind the scenes: movie-behindthescenes
    - deleted scenes: movie-deleted  
    - featurettes: movie-featurette
    - interviews: movie-interview
    - scenes: movie-scene
    - shorts: movie-short
    - trailers: movie-trailer
    - other: movie-other
    """
    return {
        'trailer': 'trailer',
        'behind the scenes': 'behindthescenes', 
        'deleted scene': 'deleted',
        'featurette': 'featurette',
        'interview': 'interview',
        'scene': 'scene',
        'short': 'short',
        'other': 'other'
    }




def categorize_file(filename: str) -> str:
    """Categorize file based on filename patterns.
    
    Args:
        filename: The filename to categorize
        
    Returns:
        Category string for the file type
    """
    filename_lower = filename.lower()
    
    # Define patterns for different categories
    patterns = {
        'deleted': ['deleted', 'cut', 'alternate', 'extended'],
        'featurette': ['featurette', 'behind', 'making', 'documentary', 'interview'],
        'trailer': ['trailer', 'teaser', 'preview'],
        'other': ['extra', 'bonus', 'special']
    }
    
    for category, keywords in patterns.items():
        if any(keyword in filename_lower for keyword in keywords):
            return category
    
    # Default to featurette if no specific category found
    return 'featurette'

def clean_title(filename: str) -> str:
    """Clean up the filename to extract a readable title.
    
    Args:
        filename: The filename to clean
        
    Returns:
        Cleaned title string
    """
    # Remove file extension
    title = os.path.splitext(filename)[0]
    
    # Remove common prefixes/suffixes
    title = re.sub(r'^(\d+[\s\-_]*)', '', title)  # Remove leading numbers
    title = re.sub(r'[\s\-_]*\d+$', '', title)    # Remove trailing numbers
    
    # Replace separators with spaces
    title = re.sub(r'[\-_\.]+', ' ', title)
    
    # Clean up multiple spaces
    title = re.sub(r'\s+', ' ', title).strip()
    
    return title

def generate_new_filename(original_filename: str, movie_name_clean: str, counter: int) -> str:
    """Generate new filename based on Plex conventions.
    
    Args:
        original_filename: Original filename
        movie_name_clean: Cleaned movie name for filename
        counter: Sequential counter for numbering
        
    Returns:
        New filename following Plex conventions
    """
    file_ext = Path(original_filename).suffix
    category = categorize_file(original_filename)
    
    # Get the naming convention for this category
    naming_conventions = get_plex_naming_convention()
    if category in naming_conventions:
        if counter == 1:
            new_name = f"{movie_name_clean}-{naming_conventions[category]}{file_ext}"
        else:
            new_name = f"{movie_name_clean}-{naming_conventions[category]}{counter:02d}{file_ext}"
    else:
        # Fallback naming
        if counter == 1:
            new_name = f"{movie_name_clean}-featurette{file_ext}"
        else:
            new_name = f"{movie_name_clean}-featurette{counter:02d}{file_ext}"
    
    return new_name

class PlexMovieSubdirRenamer:
    """Main class for renaming movie subdirectory files."""
    
    def __init__(self, dry_run: bool = False, force: bool = False, verbose: bool = False):
        self.dry_run = dry_run
        self.force = force
        self.verbose = verbose
        self.lock_file = None
        
        # Video file extensions
        self.video_extensions = {
            '.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v',
            '.mpg', '.mpeg', '.3gp', '.ogv', '.ts', '.m2ts', '.vob', '.divx',
            '.xvid', '.rm', '.rmvb', '.asf', '.f4v', '.m4p'
        }
    
    def is_video_file(self, file_path) -> bool:
        """Check if a file is a video file based on its extension.
        
        Args:
            file_path: Path to the file to check (str or Path object)
            
        Returns:
            True if file is a video file, False otherwise
        """
        if hasattr(file_path, 'suffix'):
            # Path object
            file_extension = file_path.suffix.lower()
        else:
            # String path
            import os
            file_extension = os.path.splitext(str(file_path))[1].lower()
        return file_extension in self.video_extensions
    
    def acquire_lock(self) -> bool:
        """Acquire file lock to prevent multiple instances."""
        if self.force:
            return True
            
        try:
            self.lock_file = tempfile.NamedTemporaryFile(
                mode='w',
                prefix='plex_movie_subdir_renamer_',
                suffix='.lock',
                delete=False
            )
            fcntl.flock(self.lock_file.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
            self.lock_file.write(str(os.getpid()))
            self.lock_file.flush()
            return True
        except (IOError, OSError) as e:
            if self.lock_file:
                self.lock_file.close()
                try:
                    os.unlink(self.lock_file.name)
                except OSError:
                    pass
                self.lock_file = None
            print(f"Error: Another instance is already running. Use --force to override.")
            if self.verbose:
                print(f"Lock error: {e}")
            return False
    
    def release_lock(self) -> None:
        """Release the file lock."""
        if self.lock_file:
            try:
                fcntl.flock(self.lock_file.fileno(), fcntl.LOCK_UN)
                self.lock_file.close()
                os.unlink(self.lock_file.name)
            except (IOError, OSError):
                pass
            finally:
                self.lock_file = None
    
    def rename_featurettes(self, directory_path: str, movie_name: Optional[str] = None) -> bool:
        """Rename all files in the featurettes directory."""
        directory = Path(directory_path)
        
        if not directory.exists():
            print(f"Error: Directory '{directory_path}' does not exist.")
            return False
        
        if not directory.is_dir():
            print(f"Error: '{directory_path}' is not a directory.")
            return False
    
        # Auto-detect movie name if not provided
        if not movie_name:
            parent_dir = directory.parent.name
            # Extract movie name from parent directory (remove year and quality info)
            movie_match = re.match(r'^(.+?)\s*\(\d{4}\)', parent_dir)
            if movie_match:
                movie_name = movie_match.group(1).strip()
            else:
                # Fallback: use parent directory name, cleaned up
                movie_name = re.sub(r'\s*\[.*?\]', '', parent_dir)
                movie_name = re.sub(r'\s*\(\d{4}\)', '', movie_name).strip()
        
        # Remove special characters from movie name for filename
        movie_name_clean = re.sub(r'[^\w\s-]', '', movie_name)
        movie_name_clean = re.sub(r'\s+', '', movie_name_clean)  # Remove all spaces
        
        print(f"Processing directory: {directory}")
        print(f"Detected movie name: {movie_name}")
        print(f"Clean movie name for files: {movie_name_clean}")
        print(f"Mode: {'DRY RUN' if self.dry_run else 'RENAME FILES'}")
        print("-" * 50)
        
        # Get all video files
        video_files = [f for f in directory.iterdir() 
                       if f.is_file() and f.suffix.lower() in self.video_extensions]
        
        if not video_files:
            print("No video files found in directory.")
            return True
        
        # Sort files for consistent numbering
        video_files.sort(key=lambda x: x.name.lower())
        
        # Group by category for numbering
        category_counters = {}
        
        for video_file in video_files:
            category = categorize_file(video_file.name)
            category_counters[category] = category_counters.get(category, 0) + 1
            counter = category_counters[category]
            
            new_filename = generate_new_filename(
                video_file.name, 
                movie_name_clean, 
                counter
            )
            
            new_path = directory / new_filename
            
            print(f"'{video_file.name}'")
            print(f"  -> '{new_filename}'")
            print(f"  Category: {category}")
            print()
            
            if not self.dry_run:
                try:
                    video_file.rename(new_path)
                    print(f"  ✅ Renamed successfully")
                except Exception as e:
                    print(f"  ❌ Error renaming: {e}")
                    return False
                print()
        
        return True

def confirm_action(message: str, skip_confirmation: bool = False) -> bool:
    """Ask for user confirmation unless skipped.
    
    Args:
        message: Confirmation message to display
        skip_confirmation: If True, automatically confirm
        
    Returns:
        True if confirmed, False otherwise
    """
    if skip_confirmation:
        return True
        
    try:
        response = input(f"{message} (y/N): ").strip().lower()
        return response in ['y', 'yes']
    except (EOFError, KeyboardInterrupt):
        print("\nOperation cancelled.")
        return False


def validate_args(args):
    """Validate command line arguments."""
    # Handle debug mode
    if args.debug:
        args.verbose = True
    
    # Validate arguments
    if not os.path.exists(args.directory):
        print(f"Error: Directory '{args.directory}' does not exist.")
        sys.exit(1)
    
    if not os.path.isdir(args.directory):
        print(f"Error: '{args.directory}' is not a directory.")
        sys.exit(1)

def handle_confirmation(args):
    """Handle user confirmation for the operation."""
    # Confirm action unless in dry-run mode or confirmation skipped
    if not args.dry_run:
        if not confirm_action(
            f"Rename video files in '{args.directory}'?",
            args.yes
        ):
            print("Operation cancelled.")
            sys.exit(0)

def handle_result(args, success):
    """Handle the result of the renaming operation."""
    if success:
        if args.dry_run:
            print("\\nDry run completed successfully. Use without --dry-run to execute.")
        else:
            print("\\nVideo files renamed successfully!")
    else:
        print("\\nOperation failed. Check error messages above.")
        sys.exit(1)

def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Rename movie featurettes and extras according to Plex naming conventions",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Preview what would be renamed (dry run)
  %(prog)s "./Featurettes" --dry-run
  
  # Actually rename files with confirmation
  %(prog)s "./Deleted Scenes" --movie-name "Movie Title"
  
  # Rename files without confirmation (for automation)
  %(prog)s "./Behind the Scenes" -y
  

"""
    )
    
    parser.add_argument(
        "directory", 
        help="Directory containing video files to rename"
    )
    parser.add_argument(
        "--movie-name", 
        help="Movie name (auto-detected from parent directory if not provided)"
    )
    parser.add_argument(
        "--dry-run", 
        action="store_true", 
        help="Preview changes without modifying files"
    )
    parser.add_argument(
        "-y", "--yes", 
        action="store_true", 
        help="Skip confirmation prompts (useful for automation/cron)"
    )
    parser.add_argument(
        "--force", 
        action="store_true", 
        help="Force execution even if another instance is running"
    )
    parser.add_argument(
        "--verbose", 
        action="store_true", 
        help="Enable verbose output for debugging"
    )
    parser.add_argument(
        "--debug", 
        action="store_true", 
        help="Enable debug output (implies --verbose)"
    )
    parser.add_argument(
        "--version", 
        action="version", 
        version="%(prog)s 2.1.0"
    )
    
    args = parser.parse_args()
    
    # Validate arguments
    validate_args(args)
    
    # Create renamer instance
    renamer = PlexMovieSubdirRenamer(
        dry_run=args.dry_run,
        force=args.force,
        verbose=args.verbose
    )
    
    # Acquire lock
    if not renamer.acquire_lock():
        sys.exit(1)
    
    try:
        # Show what will be done
        if args.verbose:
            print(f"Directory: {args.directory}")
            print(f"Movie name: {args.movie_name or 'auto-detect'}")
            print(f"Mode: {'DRY RUN' if args.dry_run else 'EXECUTE'}")
            print("-" * 50)
        
        # Handle confirmation
        handle_confirmation(args)
        
        # Execute the renaming
        success = renamer.rename_featurettes(args.directory, args.movie_name)
        
        # Handle result
        handle_result(args, success)
            
    except KeyboardInterrupt:
        print("\\nOperation cancelled by user.")
        sys.exit(1)
    except Exception as e:
        print(f"\\nUnexpected error: {e}")
        if args.debug:
            import traceback
            traceback.print_exc()
        sys.exit(1)
    finally:
        renamer.release_lock()

if __name__ == "__main__":
    main()
