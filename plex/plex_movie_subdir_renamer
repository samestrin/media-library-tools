#!/usr/bin/env python3
"""
Plex Movie Subdirectory Renamer

A tool for renaming movie featurettes and extras in subdirectories according to
Plex naming conventions. This script processes video files in a subdirectory and
renames them with proper Plex-compatible naming patterns.

Features:
- Renames featurettes with Plex-compatible naming conventions
- Auto-detects movie name from parent directory
- Handles multiple files with sequential numbering
- Categorizes different types of extras (featurettes, deleted scenes, etc.)
- Dry-run mode for safe testing
- Cron-friendly operation with non-interactive detection
- File locking to prevent concurrent executions

Author: Media Library Tools Project
Version: 2.1.0
"""

import argparse
import os
import re
import sys
from pathlib import Path
from typing import Dict, List, Optional, Tuple


# ======================================================

# ======================================================
# INJECTED MODULE - START
# Generated by build.py v3.0.0
# Source: utils.py
# ======================================================

"""
Shared Utility Module for Media Library Tools

This module provides backward compatibility by re-exporting functions from the
new modular library structure. New development should use the lib/ modules directly.

DEPRECATED: This module is maintained for backward compatibility only.
New tools should use the modular lib/ structure:
- lib/core.py: Essential utilities (locking, config, platform detection)
- lib/ui.py: User interface functions (banners, formatting, confirmations)
- lib/filesystem.py: File operations
- lib/validation.py: Input validation and error handling

Author: Media Library Tools Project
Version: 1.0.0
"""

import sys
import warnings
from pathlib import Path

# Add lib directory to path for imports
lib_path = Path(__file__).parent / "lib"
if str(lib_path) not in sys.path:
    sys.path.insert(0, str(lib_path))

# Import all functions from modular libraries
try:
    from core import (
        FileLock,
        acquire_lock,
        is_non_interactive,
        is_windows,
        read_global_config_bool,
        release_lock,
        should_use_emojis,
    )
    from filesystem import (
        get_directory_size,
        validate_directory_path,
    )
    from ui import (
        confirm_action,
        display_banner,
        format_size,
        format_status_message,
    )
    from validation import (
        validate_path_argument,
    )
except ImportError as e:
    # Fallback warning if lib modules are not available
    warnings.warn(
        f"Could not import from lib modules: {e}. Using legacy implementations.",
        DeprecationWarning,
        stacklevel=2,
    )

    # Keep legacy implementations as fallback
    import contextlib
    import os
    import platform
    import tempfile
    from typing import Optional, Tuple

    # Platform-specific imports
    try:
        import fcntl  # Unix/Linux/macOS
    except ImportError:
        fcntl = None  # Windows

    try:
        import msvcrt  # Windows
    except ImportError:
        msvcrt = None  # Unix/Linux/macOS

    # Legacy function implementations (fallback only)
    def display_banner(
        script_name: str,
        version: str,
        description: str,
        no_banner_flag: bool = False,
        quiet_mode: bool = False,
    ) -> None:
        """
        Display standardized banner for media library tools.

        Args:
            script_name: Name of the script
            version: Version string
            description: Brief description of the script
            no_banner_flag: If True, suppress banner display
            quiet_mode: If True, suppress banner display
        """
        # Check suppression conditions (highest to lowest priority)
        if no_banner_flag or quiet_mode or is_non_interactive():
            return

        try:
            # Display standardized ASCII art
            print("┏┳┓┏━╸╺┳┓╻┏━┓╻  ╻┏┓ ┏━┓┏━┓┏━┓╻ ╻╺┳╸┏━┓┏━┓╻  ┏━┓")
            print("┃┃┃┣╸  ┃┃┃┣━┫┃  ┃┣┻┓┣┳┛┣━┫┣┳┛┗┳┛ ┃ ┃ ┃┃ ┃┃  ┗━┓")
            print("╹ ╹┗━╸╺┻┛╹╹ ╹┗━╸╹┗━┛╹┗╸╹ ╹╹┗╸ ╹  ╹ ┗━┛┗━┛┗━╸┗━┛")
            print(f"{script_name} v{version}: {description}")
            print()  # Blank line for separation
        except Exception:
            # Banner display errors should not prevent script execution
            pass

    def is_non_interactive() -> bool:
        """
        Detect if running in non-interactive environment (cron, etc.).

        Returns:
            True if non-interactive, False otherwise
        """
        # Check if stdin is not a TTY (common in cron jobs)
        if not sys.stdin.isatty():
            return True

        # Check for common non-interactive environment variables
        non_interactive_vars = ["CRON", "CI", "AUTOMATED", "NON_INTERACTIVE"]
        for var in non_interactive_vars:
            if os.environ.get(var):
                return True

        # Check if TERM is not set or is 'dumb' (common in automated environments)
        term = os.environ.get("TERM", "")
        return bool(not term or term == "dumb")

    def read_global_config_bool(var_name: str, default: bool = False) -> bool:
        """
        Read a boolean environment variable with support for .env files.

        Args:
            var_name: Name of the environment variable
            default: Default value if not found

        Returns:
            Boolean value of the environment variable
        """
        # Check environment variable directly
        value = os.environ.get(var_name)
        if value is not None:
            return value.lower() in ("true", "1", "yes", "on")

        # Check local .env file
        env_file = ".env"
        if os.path.exists(env_file):
            try:
                with open(env_file) as f:
                    for line in f:
                        line = line.strip()
                        if line.startswith(f"{var_name}="):
                            value = line.split("=", 1)[1].strip()
                            return value.lower() in ("true", "1", "yes", "on")
            except OSError:
                pass

        # Check global .env file
        global_env_path = Path.home() / ".media-library-tools" / ".env"
        if global_env_path.exists():
            try:
                with open(global_env_path) as f:
                    for line in f:
                        line = line.strip()
                        if line.startswith(f"{var_name}="):
                            value = line.split("=", 1)[1].strip()
                            return value.lower() in ("true", "1", "yes", "on")
            except OSError:
                pass

        return default

    def is_windows() -> bool:
        """
        Detect if running on Windows platform.

        Returns:
            True if running on Windows, False otherwise
        """
        return platform.system().lower() == "windows"

    def should_use_emojis() -> bool:
        """
        Determine if emojis should be used based on platform and environment.

        Returns:
            True if emojis should be used, False otherwise
        """
        # Don't use emojis on Windows to avoid encoding issues
        if is_windows():
            return False

        # Don't use emojis in non-interactive environments
        if is_non_interactive():
            return False

        # Check for explicit emoji suppression
        return not read_global_config_bool("NO_EMOJIS", False)

    def format_size(size_bytes: int) -> str:
        """
        Format size in bytes to human readable format.

        Args:
            size_bytes: Size in bytes

        Returns:
            Human readable size string
        """
        for unit in ["B", "K", "M", "G", "T"]:
            if size_bytes < 1024.0:
                if unit == "B":
                    return f"{size_bytes:.0f}{unit}"
                else:
                    return f"{size_bytes:.1f}{unit}"
            size_bytes /= 1024.0
        return f"{size_bytes:.1f}P"

    def confirm_action(message: str, skip_confirmation: bool = False) -> bool:
        """
        Ask for user confirmation unless skipped.

        Args:
            message: Confirmation message to display
            skip_confirmation: If True, automatically confirm

        Returns:
            True if confirmed, False otherwise
        """
        if skip_confirmation:
            return True

        try:
            response = input(f"{message} (y/N): ").strip().lower()
            return response in ["y", "yes"]
        except (EOFError, KeyboardInterrupt):
            print("\nOperation cancelled.")
            return False

    class FileLock:
        """
        File locking utility class for preventing concurrent executions.
        """

        def __init__(self, lock_prefix: str = "media_library_tool"):
            """
            Initialize file lock.

            Args:
                lock_prefix: Prefix for lock file name
            """
            self.lock_prefix = lock_prefix
            self.lock_file = None

        def acquire_lock(self, force: bool = False) -> bool:
            """
            Acquire file lock to prevent multiple instances.

            Args:
                force: If True, skip locking mechanism

            Returns:
                True if lock acquired successfully, False otherwise
            """
            if force:
                return True

            try:
                with tempfile.NamedTemporaryFile(
                    mode="w",
                    prefix=f"{self.lock_prefix}_",
                    suffix=".lock",
                    delete=False,
                ) as temp_file:
                    self.lock_file = temp_file

                    # Platform-specific file locking
                    if fcntl is not None:  # Unix/Linux/macOS
                        fcntl.flock(
                            self.lock_file.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB
                        )
                    elif msvcrt is not None:  # Windows
                        msvcrt.locking(self.lock_file.fileno(), msvcrt.LK_NBLCK, 1)
                    else:
                        # Fallback: no locking available, just proceed
                        pass

                    self.lock_file.write(str(os.getpid()))
                    self.lock_file.flush()
                return True
            except OSError as e:
                if self.lock_file:
                    self.lock_file.close()
                    with contextlib.suppress(OSError):
                        os.unlink(self.lock_file.name)
                    self.lock_file = None
                print(
                    "Error: Another instance is already running. Use --force to override."
                )
                print(f"Lock error: {e}")
                return False

        def release_lock(self) -> None:
            """
            Release the file lock.
            """
            if self.lock_file:
                try:
                    # Only unlock if file is still open
                    if not self.lock_file.closed:
                        # Platform-specific file unlocking
                        if fcntl is not None:  # Unix/Linux/macOS
                            fcntl.flock(self.lock_file.fileno(), fcntl.LOCK_UN)
                        elif msvcrt is not None:  # Windows
                            msvcrt.locking(self.lock_file.fileno(), msvcrt.LK_UNLCK, 1)
                        # No explicit unlock needed for fallback case

                        self.lock_file.close()
                except (OSError, ValueError):
                    # Handle both file system errors and closed file errors
                    pass

                # Always try to remove lock file if it exists
                try:
                    if os.path.exists(self.lock_file.name):
                        os.unlink(self.lock_file.name)
                except OSError:
                    pass
                finally:
                    self.lock_file = None

    # Legacy standalone functions for backward compatibility
    def acquire_lock(
        lock_prefix: str = "media_library_tool", force: bool = False
    ) -> Tuple[bool, Optional[FileLock]]:
        """
        Legacy function for acquiring file locks.

        Args:
            lock_prefix: Prefix for lock file name
            force: If True, skip locking mechanism

        Returns:
            Tuple of (success: bool, lock_instance: FileLock or None)
        """
        lock = FileLock(lock_prefix)
        success = lock.acquire_lock(force)
        return success, lock if success else None

    def release_lock(lock_instance: FileLock) -> None:
        """
        Legacy function for releasing file locks.

        Args:
            lock_instance: FileLock instance to release
        """
        if lock_instance:
            lock_instance.release_lock()

    def format_status_message(
        message: str, emoji: str = "", fallback_prefix: str = ""
    ) -> str:
        """
        Format a status message with emoji on supported platforms or fallback text.

        Args:
            message: The main message text
            emoji: The emoji to use on supported platforms
            fallback_prefix: Text prefix to use instead of emoji on unsupported platforms

        Returns:
            Formatted message string
        """
        if should_use_emojis() and emoji:
            return f"{emoji} {message}"
        elif fallback_prefix:
            return f"{fallback_prefix}: {message}"
        else:
            return message

    # Add any missing functions that might be needed for backward compatibility
    def get_directory_size(path: str) -> int:
        """Legacy fallback for directory size calculation."""
        total_size = 0
        try:
            for dirpath, _dirnames, filenames in os.walk(path):
                for filename in filenames:
                    filepath = os.path.join(dirpath, filename)
                    try:
                        total_size += os.path.getsize(filepath)
                    except OSError:
                        continue
        except OSError:
            pass
        return total_size

    def validate_directory_path(path: str) -> Tuple[bool, str]:
        """Legacy fallback for directory path validation."""
        if not path:
            return False, "Path cannot be empty"

        path_obj = Path(path)

        if not path_obj.exists():
            return False, f"Path does not exist: {path}"

        if not path_obj.is_dir():
            return False, f"Path is not a directory: {path}"

        return True, ""

    def validate_path_argument(path: str) -> Tuple[bool, str]:
        """Legacy fallback for path argument validation."""
        return validate_directory_path(path)


# ======================================================
# INJECTED MODULE - END
# Source: utils.py
# ======================================================



# ======================================================


# Version constant
VERSION = "2.1.0"








def get_plex_naming_convention():
    """
    Plex naming conventions for extras:
    - behind the scenes: movie-behindthescenes
    - deleted scenes: movie-deleted  
    - featurettes: movie-featurette
    - interviews: movie-interview
    - scenes: movie-scene
    - shorts: movie-short
    - trailers: movie-trailer
    - other: movie-other
    """
    return {
        'trailer': 'trailer',
        'behind the scenes': 'behindthescenes', 
        'deleted scene': 'deleted',
        'featurette': 'featurette',
        'interview': 'interview',
        'scene': 'scene',
        'short': 'short',
        'other': 'other'
    }




def categorize_file(filename: str) -> str:
    """Categorize file based on filename patterns.
    
    Args:
        filename: The filename to categorize
        
    Returns:
        Category string for the file type
    """
    filename_lower = filename.lower()
    
    # Define patterns for different categories
    patterns = {
        'deleted': ['deleted', 'cut', 'alternate', 'extended'],
        'featurette': ['featurette', 'behind', 'making', 'documentary', 'interview'],
        'trailer': ['trailer', 'teaser', 'preview'],
        'other': ['extra', 'bonus', 'special']
    }
    
    for category, keywords in patterns.items():
        if any(keyword in filename_lower for keyword in keywords):
            return category
    
    # Default to featurette if no specific category found
    return 'featurette'

def clean_title(filename: str) -> str:
    """Clean up the filename to extract a readable title.
    
    Args:
        filename: The filename to clean
        
    Returns:
        Cleaned title string
    """
    # Remove file extension
    title = os.path.splitext(filename)[0]
    
    # Remove common prefixes/suffixes
    title = re.sub(r'^(\d+[\s\-_]*)', '', title)  # Remove leading numbers
    title = re.sub(r'[\s\-_]*\d+$', '', title)    # Remove trailing numbers
    
    # Replace separators with spaces
    title = re.sub(r'[\-_\.]+', ' ', title)
    
    # Clean up multiple spaces
    title = re.sub(r'\s+', ' ', title).strip()
    
    return title

def generate_new_filename(original_filename: str, movie_name_clean: str, counter: int) -> str:
    """Generate new filename based on Plex conventions.
    
    Args:
        original_filename: Original filename
        movie_name_clean: Cleaned movie name for filename
        counter: Sequential counter for numbering
        
    Returns:
        New filename following Plex conventions
    """
    file_ext = Path(original_filename).suffix
    category = categorize_file(original_filename)
    
    # Get the naming convention for this category
    naming_conventions = get_plex_naming_convention()
    if category in naming_conventions:
        if counter == 1:
            new_name = f"{movie_name_clean}-{naming_conventions[category]}{file_ext}"
        else:
            new_name = f"{movie_name_clean}-{naming_conventions[category]}{counter:02d}{file_ext}"
    else:
        # Fallback naming
        if counter == 1:
            new_name = f"{movie_name_clean}-featurette{file_ext}"
        else:
            new_name = f"{movie_name_clean}-featurette{counter:02d}{file_ext}"
    
    return new_name

class PlexMovieSubdirRenamer:
    """Main class for renaming movie subdirectory files."""
    
    def __init__(self, dry_run: bool = False, force: bool = False, verbose: bool = False):
        self.dry_run = dry_run
        self.force = force
        self.verbose = verbose
        self.file_lock = FileLock('plex_movie_subdir_renamer')
        
        # Video file extensions
        self.video_extensions = {
            '.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v',
            '.mpg', '.mpeg', '.3gp', '.ogv', '.ts', '.m2ts', '.vob', '.divx',
            '.xvid', '.rm', '.rmvb', '.asf', '.f4v', '.m4p'
        }
    
    def is_video_file(self, file_path) -> bool:
        """Check if a file is a video file based on its extension.
        
        Args:
            file_path: Path to the file to check (str or Path object)
            
        Returns:
            True if file is a video file, False otherwise
        """
        if hasattr(file_path, 'suffix'):
            # Path object
            file_extension = file_path.suffix.lower()
        else:
            # String path
            import os
            file_extension = os.path.splitext(str(file_path))[1].lower()
        return file_extension in self.video_extensions
    
    def acquire_lock(self) -> bool:
        """Acquire file lock to prevent multiple instances."""
        return self.file_lock.acquire_lock(self.force)
    
    def release_lock(self) -> None:
        """Release the file lock."""
        self.file_lock.release_lock()
    
    def rename_featurettes(self, directory_path: str, movie_name: Optional[str] = None) -> bool:
        """Rename all files in the featurettes directory."""
        directory = Path(directory_path)
        
        if not directory.exists():
            print(f"Error: Directory '{directory_path}' does not exist.")
            return False
        
        if not directory.is_dir():
            print(f"Error: '{directory_path}' is not a directory.")
            return False
    
        # Auto-detect movie name if not provided
        if not movie_name:
            parent_dir = directory.parent.name
            # Extract movie name from parent directory (remove year and quality info)
            movie_match = re.match(r'^(.+?)\s*\(\d{4}\)', parent_dir)
            if movie_match:
                movie_name = movie_match.group(1).strip()
            else:
                # Fallback: use parent directory name, cleaned up
                movie_name = re.sub(r'\s*\[.*?\]', '', parent_dir)
                movie_name = re.sub(r'\s*\(\d{4}\)', '', movie_name).strip()
        
        # Remove special characters from movie name for filename
        movie_name_clean = re.sub(r'[^\w\s-]', '', movie_name)
        movie_name_clean = re.sub(r'\s+', '', movie_name_clean)  # Remove all spaces
        
        print(f"Processing directory: {directory}")
        print(f"Detected movie name: {movie_name}")
        print(f"Clean movie name for files: {movie_name_clean}")
        print(f"Mode: {'DRY RUN' if self.dry_run else 'RENAME FILES'}")
        print("-" * 50)
        
        # Get all video files
        video_files = [f for f in directory.iterdir() 
                       if f.is_file() and f.suffix.lower() in self.video_extensions]
        
        if not video_files:
            print("No video files found in directory.")
            return True
        
        # Sort files for consistent numbering
        video_files.sort(key=lambda x: x.name.lower())
        
        # Group by category for numbering
        category_counters = {}
        
        for video_file in video_files:
            category = categorize_file(video_file.name)
            category_counters[category] = category_counters.get(category, 0) + 1
            counter = category_counters[category]
            
            new_filename = generate_new_filename(
                video_file.name, 
                movie_name_clean, 
                counter
            )
            
            new_path = directory / new_filename
            
            print(f"'{video_file.name}'")
            print(f"  -> '{new_filename}'")
            print(f"  Category: {category}")
            print()
            
            if not self.dry_run:
                try:
                    video_file.rename(new_path)
                    print(f"  ✅ Renamed successfully")
                except Exception as e:
                    print(f"  ❌ Error renaming: {e}")
                    return False
                print()
        
        return True



def validate_args(args):
    """Validate command line arguments."""
    # Read global configuration
    auto_execute = read_global_config_bool('AUTO_EXECUTE', False)
    auto_confirm = read_global_config_bool('AUTO_CONFIRM', False)
    quiet_mode = read_global_config_bool('QUIET_MODE', False)
    
    # Set quiet_mode as attribute for access elsewhere
    args.quiet_mode = quiet_mode
    
    # Apply global configuration (CLI arguments take precedence)
    if auto_execute and not args.execute:
        args.execute = True  # Set execute flag if AUTO_EXECUTE is set
    if auto_confirm and not args.yes:
        args.yes = True  # Set yes flag if AUTO_CONFIRM is set
    
    # Handle dry-run/execute logic
    if args.execute:
        dry_run_mode = False
    else:
        dry_run_mode = args.dry_run  # This is True by default
    
    # Validate arguments
    if not os.path.exists(args.directory):
        print(f"Error: Directory '{args.directory}' does not exist.")
        sys.exit(1)
    
    if not os.path.isdir(args.directory):
        print(f"Error: '{args.directory}' is not a directory.")
        sys.exit(1)
    
    return dry_run_mode

def handle_confirmation(args, dry_run_mode):
    """Handle user confirmation for the operation."""
    # Confirm action unless in dry-run mode or confirmation skipped
    if not dry_run_mode:
        if not confirm_action(
            f"Rename video files in '{args.directory}'?",
            args.yes or is_non_interactive()
        ):
            print("Operation cancelled.")
            sys.exit(0)

def handle_result(args, dry_run_mode, success):
    """Handle the result of the renaming operation."""
    if success:
        if dry_run_mode:
            print("\\nDry run completed successfully. Use --execute to make changes.")
        else:
            print("\\nVideo files renamed successfully!")
    else:
        print("\\nOperation failed. Check error messages above.")
        sys.exit(1)

def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Rename movie featurettes and extras according to Plex naming conventions",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Preview what would be renamed in current directory (dry-run mode, default)
  %(prog)s
  
  # Preview what would be renamed in specific directory (dry-run mode, default)
  %(prog)s "./Featurettes"
  
  # Actually rename files in current directory with confirmation
  %(prog)s --execute --movie-name "Movie Title"
  
  # Actually rename files in specific directory with confirmation
  %(prog)s "./Deleted Scenes" --execute --movie-name "Movie Title"
  
  # Rename files without confirmation (for automation)
  %(prog)s --execute -y
  
  # Rename files in specific directory without confirmation (for automation)
  %(prog)s "./Behind the Scenes" --execute -y

Cron Usage:
  # Run daily to rename movie extras (non-interactive)
  0 3 * * * /usr/local/bin/plex_movie_subdir_renamer "/movies/Featurettes" --execute -y
  

"""
    )
    
    parser.add_argument(
        "directory", 
        nargs='?',
        default='.',
        help="Directory containing video files to rename (default: current directory)"
    )
    parser.add_argument(
        "--movie-name", 
        help="Movie name (auto-detected from parent directory if not provided)"
    )
    parser.add_argument(
        "--dry-run", 
        action="store_true",
        default=True,
        help="Preview changes without modifying files (default: true)"
    )
    parser.add_argument(
        "--execute", 
        action="store_true", 
        help="Actually perform operations (overrides --dry-run)"
    )
    parser.add_argument(
        "-y", "--yes", 
        action="store_true", 
        help="Skip confirmation prompts (useful for automation/cron)"
    )
    parser.add_argument(
        "--force", 
        action="store_true", 
        help="Force execution even if another instance is running"
    )
    parser.add_argument(
        "--verbose", "-v", 
        action="store_true", 
        help="Enable verbose output for debugging"
    )
    parser.add_argument(
        "--debug", 
        action="store_true", 
        help="Enable debug output (implies --verbose)"
    )
    parser.add_argument(
        "--no-banner",
        action="store_true",
        help="Suppress banner display"
    )
    parser.add_argument(
        "--version", 
        action="version", 
        version=f"%(prog)s {VERSION}"
    )
    
    args = parser.parse_args()
    
    # Handle debug mode
    if args.debug:
        args.verbose = True
    
    # Validate arguments and get dry_run_mode
    dry_run_mode = validate_args(args)
    
    # Display banner
    display_banner("plex_movie_subdir_renamer", VERSION, 
                  "rename movie featurettes and extras according to Plex naming conventions",
                  args.no_banner, getattr(args, 'quiet_mode', False))
    
    if dry_run_mode:
        print("DRY-RUN MODE: No changes will be made")
    else:
        print("EXECUTE MODE: Files will be renamed")
    
    if args.debug:
        print("Debug: ENABLED")
    elif args.verbose:
        print("Verbose: ENABLED")
    print()
    
    # Create renamer instance
    renamer = PlexMovieSubdirRenamer(
        dry_run=dry_run_mode,
        force=args.force,
        verbose=args.verbose
    )
    
    # Acquire lock
    if not renamer.acquire_lock():
        sys.exit(1)
    
    try:
        # Show what will be done
        if args.verbose:
            print(f"Directory: {args.directory}")
            print(f"Movie name: {args.movie_name or 'auto-detect'}")
            print(f"Mode: {'DRY RUN' if dry_run_mode else 'EXECUTE'}")
            print("-" * 50)
        
        # Handle confirmation
        handle_confirmation(args, dry_run_mode)
        
        # Execute the renaming
        success = renamer.rename_featurettes(args.directory, args.movie_name)
        
        # Handle result
        handle_result(args, dry_run_mode, success)
            
    except KeyboardInterrupt:
        print("\\nOperation cancelled by user.")
        sys.exit(1)
    except Exception as e:
        print(f"\\nUnexpected error: {e}")
        if args.debug:
            import traceback
            traceback.print_exc()
        sys.exit(1)
    finally:
        renamer.release_lock()

if __name__ == "__main__":
    main()
