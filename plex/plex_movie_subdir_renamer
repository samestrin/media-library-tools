#!/usr/bin/env python3
"""
Plex Movie Subdirectory Renamer

A tool for renaming movie featurettes and extras in subdirectories according to
Plex naming conventions. This script processes video files in a subdirectory and
renames them with proper Plex-compatible naming patterns.

Features:
- Renames featurettes with Plex-compatible naming conventions
- Auto-detects movie name from parent directory
- Handles multiple files with sequential numbering
- Categorizes different types of extras (featurettes, deleted scenes, etc.)
- Dry-run mode for safe testing
- Cron-friendly operation with non-interactive detection
- File locking to prevent concurrent executions

Author: Media Library Tools Project
Version: 2.1.0
"""

import argparse
import os
import re
import sys
from pathlib import Path
from typing import Dict, List, Optional, Tuple


# ======================================================
# Modular includes will be injected here by build.py
# ======================================================

# Modular utilities will be injected by build.py
# ======================================================



# ======================================================


# Version constant
VERSION = "2.1.0"

# {{include lib/core.py}}
# {{include lib/ui.py}}








def get_plex_naming_convention():
    """
    Plex naming conventions for extras:
    - behind the scenes: movie-behindthescenes
    - deleted scenes: movie-deleted  
    - featurettes: movie-featurette
    - interviews: movie-interview
    - scenes: movie-scene
    - shorts: movie-short
    - trailers: movie-trailer
    - other: movie-other
    """
    return {
        'trailer': 'trailer',
        'behind the scenes': 'behindthescenes', 
        'deleted scene': 'deleted',
        'featurette': 'featurette',
        'interview': 'interview',
        'scene': 'scene',
        'short': 'short',
        'other': 'other'
    }




def categorize_file(filename: str) -> str:
    """Categorize file based on filename patterns.
    
    Args:
        filename: The filename to categorize
        
    Returns:
        Category string for the file type
    """
    filename_lower = filename.lower()
    
    # Define patterns for different categories
    patterns = {
        'deleted': ['deleted', 'cut', 'alternate', 'extended'],
        'featurette': ['featurette', 'behind', 'making', 'documentary', 'interview'],
        'trailer': ['trailer', 'teaser', 'preview'],
        'other': ['extra', 'bonus', 'special']
    }
    
    for category, keywords in patterns.items():
        if any(keyword in filename_lower for keyword in keywords):
            return category
    
    # Default to featurette if no specific category found
    return 'featurette'

def clean_title(filename: str) -> str:
    """Clean up the filename to extract a readable title.
    
    Args:
        filename: The filename to clean
        
    Returns:
        Cleaned title string
    """
    # Remove file extension
    title = os.path.splitext(filename)[0]
    
    # Remove common prefixes/suffixes
    title = re.sub(r'^(\d+[\s\-_]*)', '', title)  # Remove leading numbers
    title = re.sub(r'[\s\-_]*\d+$', '', title)    # Remove trailing numbers
    
    # Replace separators with spaces
    title = re.sub(r'[\-_\.]+', ' ', title)
    
    # Clean up multiple spaces
    title = re.sub(r'\s+', ' ', title).strip()
    
    return title

def generate_new_filename(original_filename: str, movie_name_clean: str, counter: int) -> str:
    """Generate new filename based on Plex conventions.
    
    Args:
        original_filename: Original filename
        movie_name_clean: Cleaned movie name for filename
        counter: Sequential counter for numbering
        
    Returns:
        New filename following Plex conventions
    """
    file_ext = Path(original_filename).suffix
    category = categorize_file(original_filename)
    
    # Get the naming convention for this category
    naming_conventions = get_plex_naming_convention()
    if category in naming_conventions:
        if counter == 1:
            new_name = f"{movie_name_clean}-{naming_conventions[category]}{file_ext}"
        else:
            new_name = f"{movie_name_clean}-{naming_conventions[category]}{counter:02d}{file_ext}"
    else:
        # Fallback naming
        if counter == 1:
            new_name = f"{movie_name_clean}-featurette{file_ext}"
        else:
            new_name = f"{movie_name_clean}-featurette{counter:02d}{file_ext}"
    
    return new_name

class PlexMovieSubdirRenamer:
    """Main class for renaming movie subdirectory files."""
    
    def __init__(self, dry_run: bool = False, force: bool = False, verbose: bool = False):
        self.dry_run = dry_run
        self.force = force
        self.verbose = verbose
        self.file_lock = FileLock('plex_movie_subdir_renamer')
        
        # Video file extensions
        self.video_extensions = {
            '.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v',
            '.mpg', '.mpeg', '.3gp', '.ogv', '.ts', '.m2ts', '.vob', '.divx',
            '.xvid', '.rm', '.rmvb', '.asf', '.f4v', '.m4p'
        }
    
    def is_video_file(self, file_path) -> bool:
        """Check if a file is a video file based on its extension.
        
        Args:
            file_path: Path to the file to check (str or Path object)
            
        Returns:
            True if file is a video file, False otherwise
        """
        if hasattr(file_path, 'suffix'):
            # Path object
            file_extension = file_path.suffix.lower()
        else:
            # String path
            import os
            file_extension = os.path.splitext(str(file_path))[1].lower()
        return file_extension in self.video_extensions
    
    def acquire_lock(self) -> bool:
        """Acquire file lock to prevent multiple instances."""
        return self.file_lock.acquire_lock(self.force)
    
    def release_lock(self) -> None:
        """Release the file lock."""
        self.file_lock.release_lock()
    
    def rename_featurettes(self, directory_path: str, movie_name: Optional[str] = None) -> bool:
        """Rename all files in the featurettes directory."""
        directory = Path(directory_path)
        
        if not directory.exists():
            print(format_status_message(f"Directory '{directory_path}' does not exist", "❌", "Error"))
            return False
        
        if not directory.is_dir():
            print(format_status_message(f"'{directory_path}' is not a directory", "❌", "Error"))
            return False
    
        # Auto-detect movie name if not provided
        if not movie_name:
            parent_dir = directory.parent.name
            # Extract movie name from parent directory (remove year and quality info)
            movie_match = re.match(r'^(.+?)\s*\(\d{4}\)', parent_dir)
            if movie_match:
                movie_name = movie_match.group(1).strip()
            else:
                # Fallback: use parent directory name, cleaned up
                movie_name = re.sub(r'\s*\[.*?\]', '', parent_dir)
                movie_name = re.sub(r'\s*\(\d{4}\)', '', movie_name).strip()
        
        # Remove special characters from movie name for filename
        movie_name_clean = re.sub(r'[^\w\s-]', '', movie_name)
        movie_name_clean = re.sub(r'\s+', '', movie_name_clean)  # Remove all spaces
        
        # Display processing information
        processing_info = {
            'Processing directory': str(directory),
            'Detected movie name': movie_name,
            'Clean movie name for files': movie_name_clean,
            'Mode': 'DRY RUN' if self.dry_run else 'RENAME FILES'
        }
        display_summary_list(processing_info, 'Processing Information')
        
        # Get all video files
        video_files = [f for f in directory.iterdir() 
                       if f.is_file() and f.suffix.lower() in self.video_extensions]
        
        if not video_files:
            print(format_status_message("No video files found in directory", "ℹ️", "Info"))
            return True
        
        # Sort files for consistent numbering
        video_files.sort(key=lambda x: x.name.lower())
        
        # Group by category for numbering
        category_counters = {}
        
        for video_file in video_files:
            category = categorize_file(video_file.name)
            category_counters[category] = category_counters.get(category, 0) + 1
            counter = category_counters[category]
            
            new_filename = generate_new_filename(
                video_file.name, 
                movie_name_clean, 
                counter
            )
            
            new_path = directory / new_filename
            
            # Display file processing information
            file_info = [
                f"'{video_file.name}' -> '{new_filename}'",
                f"Category: {category}"
            ]
            display_item_list(file_info, numbered=False)
            
            if not self.dry_run:
                try:
                    video_file.rename(new_path)
                    print(format_status_message("Renamed successfully", "✅", "SUCCESS"))
                except Exception as e:
                    print(format_status_message(f"Error renaming: {e}", "❌", "Error"))
                    return False
                print()
        
        return True



def validate_args(args):
    """Validate command line arguments."""
    # Read global configuration
    auto_execute = read_global_config_bool('AUTO_EXECUTE', False)
    auto_confirm = read_global_config_bool('AUTO_CONFIRM', False)
    quiet_mode = read_global_config_bool('QUIET_MODE', False)
    
    # Set quiet_mode as attribute for access elsewhere
    args.quiet_mode = quiet_mode
    
    # Apply global configuration (CLI arguments take precedence)
    if auto_execute and not args.execute:
        args.execute = True  # Set execute flag if AUTO_EXECUTE is set
    if auto_confirm and not args.yes:
        args.yes = True  # Set yes flag if AUTO_CONFIRM is set
    
    # Handle dry-run/execute logic
    if args.execute:
        dry_run_mode = False
    else:
        dry_run_mode = args.dry_run  # This is True by default
    
    # Validate arguments
    if not os.path.exists(args.directory):
        print(format_status_message(f"Directory '{args.directory}' does not exist", "❌", "Error"))
        sys.exit(1)
    
    if not os.path.isdir(args.directory):
        print(format_status_message(f"'{args.directory}' is not a directory", "❌", "Error"))
        sys.exit(1)
    
    return dry_run_mode

def handle_confirmation(args, dry_run_mode):
    """Handle user confirmation for the operation."""
    # Confirm action unless in dry-run mode or confirmation skipped
    if not dry_run_mode:
        if not confirm_action(
            f"Rename video files in '{args.directory}'?",
            args.yes or is_non_interactive()
        ):
            print(format_status_message("Operation cancelled", "❌", "Error"))
            sys.exit(0)

def handle_result(args, dry_run_mode, success):
    """Handle the result of the renaming operation."""
    if success:
        if dry_run_mode:
            print(format_status_message("Dry run completed successfully. Use --execute to make changes", "✅", "SUCCESS"))
        else:
            print(format_status_message("Video files renamed successfully!", "✅", "SUCCESS"))
    else:
        print(format_status_message("Operation failed. Check error messages above", "❌", "Error"))
        sys.exit(1)

def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Rename movie featurettes and extras according to Plex naming conventions",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Preview what would be renamed in current directory (dry-run mode, default)
  %(prog)s
  
  # Preview what would be renamed in specific directory (dry-run mode, default)
  %(prog)s "./Featurettes"
  
  # Actually rename files in current directory with confirmation
  %(prog)s --execute --movie-name "Movie Title"
  
  # Actually rename files in specific directory with confirmation
  %(prog)s "./Deleted Scenes" --execute --movie-name "Movie Title"
  
  # Rename files without confirmation (for automation)
  %(prog)s --execute -y
  
  # Rename files in specific directory without confirmation (for automation)
  %(prog)s "./Behind the Scenes" --execute -y

Cron Usage:
  # Run daily to rename movie extras (non-interactive)
  0 3 * * * /usr/local/bin/plex_movie_subdir_renamer "/movies/Featurettes" --execute -y
  

"""
    )
    
    parser.add_argument(
        "directory", 
        nargs='?',
        default='.',
        help="Directory containing video files to rename (default: current directory)"
    )
    parser.add_argument(
        "--movie-name", 
        help="Movie name (auto-detected from parent directory if not provided)"
    )
    parser.add_argument(
        "--dry-run", 
        action="store_true",
        default=True,
        help="Preview changes without modifying files (default: true)"
    )
    parser.add_argument(
        "--execute", 
        action="store_true", 
        help="Actually perform operations (overrides --dry-run)"
    )
    parser.add_argument(
        "-y", "--yes", 
        action="store_true", 
        help="Skip confirmation prompts (useful for automation/cron)"
    )
    parser.add_argument(
        "--force", 
        action="store_true", 
        help="Force execution even if another instance is running"
    )
    parser.add_argument(
        "--verbose", "-v", 
        action="store_true", 
        help="Enable verbose output for debugging"
    )
    parser.add_argument(
        "--debug", 
        action="store_true", 
        help="Enable debug output (implies --verbose)"
    )
    parser.add_argument(
        "--no-banner",
        action="store_true",
        help="Suppress banner display"
    )
    parser.add_argument(
        "--version", 
        action="version", 
        version=f"%(prog)s {VERSION}"
    )
    
    args = parser.parse_args()
    
    # Handle debug mode
    if args.debug:
        args.verbose = True
    
    # Validate arguments and get dry_run_mode
    dry_run_mode = validate_args(args)
    
    # Display banner
    display_banner("plex_movie_subdir_renamer", VERSION, 
                  "rename movie featurettes and extras according to Plex naming conventions",
                  args.no_banner, getattr(args, 'quiet_mode', False))
    
    # Display mode information
    mode_info = {
        'Mode': 'DRY-RUN (No changes will be made)' if dry_run_mode else 'EXECUTE (Files will be renamed)'
    }
    
    if args.debug:
        mode_info['Debug'] = 'ENABLED'
    elif args.verbose:
        mode_info['Verbose'] = 'ENABLED'
    
    display_summary_list(mode_info, 'Execution Mode')
    
    # Create renamer instance
    renamer = PlexMovieSubdirRenamer(
        dry_run=dry_run_mode,
        force=args.force,
        verbose=args.verbose
    )
    
    # Acquire lock
    if not renamer.acquire_lock():
        sys.exit(1)
    
    try:
        # Show what will be done
        if args.verbose:
            verbose_info = {
                'Directory': args.directory,
                'Movie name': args.movie_name or 'auto-detect',
                'Mode': 'DRY RUN' if dry_run_mode else 'EXECUTE'
            }
            display_summary_list(verbose_info, 'Operation Details')
        
        # Handle confirmation
        handle_confirmation(args, dry_run_mode)
        
        # Execute the renaming
        success = renamer.rename_featurettes(args.directory, args.movie_name)
        
        # Handle result
        handle_result(args, dry_run_mode, success)
            
    except KeyboardInterrupt:
        print(format_status_message("Operation cancelled by user", "❌", "Error"))
        sys.exit(1)
    except Exception as e:
        print(format_status_message(f"Unexpected error: {e}", "❌", "Error"))
        if args.debug:
            import traceback
            traceback.print_exc()
        sys.exit(1)
    finally:
        renamer.release_lock()

if __name__ == "__main__":
    main()
