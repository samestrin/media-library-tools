#!/usr/bin/env python3
"""
Plex Directory Creator

A Python tool for converting loose media files into proper directory structures.
This script creates a directory for each file (named after the file without extension)
and moves the file into its corresponding directory, which is ideal for Plex media
organization where each movie should be in its own directory.

Features:
- Converts files to directory structure automatically
- Supports multiple file types with filtering
- File-based locking mechanism
- Dry-run mode for safe testing
- Collision detection and handling
- Progress tracking and statistics
- Cron-friendly operation

Author: Media Library Tools Project
Version: 2.0.0
"""

import argparse
import fcntl
import os
import shutil
import sys
import tempfile
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple


def format_size(size_bytes: int) -> str:
    """Format size in bytes to human readable format.
    
    Args:
        size_bytes: Size in bytes
        
    Returns:
        Human readable size string
    """
    for unit in ['B', 'K', 'M', 'G', 'T']:
        if size_bytes < 1024.0:
            if unit == 'B':
                return f"{size_bytes:.0f}{unit}"
            else:
                return f"{size_bytes:.1f}{unit}"
        size_bytes /= 1024.0
    return f"{size_bytes:.1f}P"


def is_non_interactive() -> bool:
    """Detect if running in non-interactive environment (cron, etc.).
    
    Returns:
        True if non-interactive, False otherwise
    """
    # Check if stdin is not a TTY (common in cron jobs)
    if not sys.stdin.isatty():
        return True
        
    # Check for common non-interactive environment variables
    non_interactive_vars = ['CRON', 'CI', 'AUTOMATED', 'NON_INTERACTIVE']
    for var in non_interactive_vars:
        if os.environ.get(var):
            return True
            
    # Check if TERM is not set or is 'dumb' (common in automated environments)
    term = os.environ.get('TERM', '')
    if not term or term == 'dumb':
        return True
        
    return False


class PlexDirectoryCreator:
    """Main class for creating directory structures from files."""
    
    def __init__(self, dry_run: bool = False, force: bool = False, 
                 file_types: Optional[Set[str]] = None, exclude_types: Optional[Set[str]] = None):
        self.dry_run = dry_run
        self.force = force
        self.lock_file = None
        
        # Default media file extensions
        self.default_media_types = {
            # Video files
            '.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v',
            '.mpg', '.mpeg', '.3gp', '.ogv', '.ts', '.m2ts', '.vob', '.divx',
            '.xvid', '.rm', '.rmvb', '.asf', '.f4v', '.m4p', '.m4v',
            
            # Audio files
            '.mp3', '.flac', '.wav', '.aac', '.ogg', '.wma', '.m4a', '.opus',
            '.aiff', '.au', '.ra', '.ac3', '.dts',
            
            # Image files
            '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.tif', '.webp',
            '.svg', '.ico', '.psd', '.raw', '.cr2', '.nef', '.arw',
            
            # Document files
            '.pdf', '.doc', '.docx', '.txt', '.rtf', '.odt', '.pages',
            
            # Archive files
            '.zip', '.rar', '.7z', '.tar', '.gz', '.bz2', '.xz'
        }
        
        # Set file types to process
        if file_types:
            self.file_types = {ext.lower() if ext.startswith('.') else f'.{ext.lower()}' 
                             for ext in file_types}
        else:
            self.file_types = self.default_media_types
        
        # Set file types to exclude
        if exclude_types:
            self.exclude_types = {ext.lower() if ext.startswith('.') else f'.{ext.lower()}' 
                                for ext in exclude_types}
            self.file_types = self.file_types - self.exclude_types
        
        # Statistics tracking
        self.stats = {
            'total_files': 0,
            'processed_files': 0,
            'skipped_files': 0,
            'created_directories': 0,
            'errors': []
        }
    
    def acquire_lock(self) -> bool:
        """Acquire file lock to prevent multiple instances."""
        if self.force:
            return True
            
        try:
            self.lock_file = tempfile.NamedTemporaryFile(
                mode='w',
                prefix='plex_make_dirs_',
                suffix='.lock',
                delete=False
            )
            fcntl.flock(self.lock_file.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
            self.lock_file.write(str(os.getpid()))
            self.lock_file.flush()
            return True
        except (IOError, OSError) as e:
            if self.lock_file:
                self.lock_file.close()
                try:
                    os.unlink(self.lock_file.name)
                except OSError:
                    pass
                self.lock_file = None
            print(f"Error: Another instance is already running. Use --force to override.")
            print(f"Lock error: {e}")
            return False
    
    def release_lock(self) -> None:
        """Release the file lock."""
        if self.lock_file:
            try:
                fcntl.flock(self.lock_file.fileno(), fcntl.LOCK_UN)
                self.lock_file.close()
                os.unlink(self.lock_file.name)
            except (IOError, OSError):
                pass
            finally:
                self.lock_file = None
    
    def should_process_file(self, file_path: Path) -> bool:
        """Determine if a file should be processed based on its extension."""
        return file_path.suffix.lower() in self.file_types
    
    def generate_directory_name(self, file_path: Path) -> str:
        """Generate directory name from file name (without extension)."""
        return file_path.stem
    
    def handle_collision(self, target_dir: Path, file_path: Path) -> Tuple[Path, str]:
        """Handle directory name collisions by generating unique names."""
        if not target_dir.exists():
            return target_dir, "no_collision"
        
        if target_dir.is_file():
            # If a file exists with the same name, we need to rename it first
            original_file = target_dir
            backup_name = f"{original_file.stem}_backup{original_file.suffix}"
            backup_path = original_file.parent / backup_name
            
            counter = 1
            while backup_path.exists():
                backup_name = f"{original_file.stem}_backup_{counter}{original_file.suffix}"
                backup_path = original_file.parent / backup_name
                counter += 1
            
            if self.dry_run:
                return target_dir, f"would_rename_file_to_{backup_path.name}"
            else:
                original_file.rename(backup_path)
                print(f"  Renamed conflicting file: {original_file.name} ‚Üí {backup_path.name}")
                return target_dir, "renamed_conflicting_file"
        
        elif target_dir.is_dir():
            # Directory already exists, check if it's empty or contains the same file
            existing_files = list(target_dir.iterdir())
            
            if not existing_files:
                # Empty directory, we can use it
                return target_dir, "empty_directory_reused"
            
            elif len(existing_files) == 1 and existing_files[0].name == file_path.name:
                # Directory contains the same file, skip
                return target_dir, "file_already_in_directory"
            
            else:
                # Directory contains other files, create unique name
                base_name = target_dir.name
                counter = 1
                while True:
                    new_name = f"{base_name}_{counter}"
                    new_path = target_dir.parent / new_name
                    if not new_path.exists():
                        return new_path, f"renamed_to_{new_name}"
                    counter += 1
        
        return target_dir, "unknown_collision"
    
    def process_file(self, file_path: Path) -> Tuple[bool, str]:
        """Process a single file by creating directory and moving file."""
        try:
            # Generate directory name
            dir_name = self.generate_directory_name(file_path)
            target_dir = file_path.parent / dir_name
            
            # Handle collisions
            final_dir, collision_status = self.handle_collision(target_dir, file_path)
            
            # Skip if file is already in the correct directory
            if collision_status == "file_already_in_directory":
                print(f"  Skipping: {file_path.name} (already in directory {final_dir.name})")
                self.stats['skipped_files'] += 1
                return True, "already_in_directory"
            
            # Create directory and move file
            if self.dry_run:
                print(f"  [DRY RUN] Would create directory: {final_dir.name}")
                print(f"  [DRY RUN] Would move: {file_path.name} ‚Üí {final_dir.name}/{file_path.name}")
                if collision_status != "no_collision":
                    print(f"    Collision handling: {collision_status}")
            else:
                # Create directory
                final_dir.mkdir(exist_ok=True)
                
                # Move file
                target_file = final_dir / file_path.name
                shutil.move(str(file_path), str(target_file))
                
                print(f"  Created directory: {final_dir.name}")
                print(f"  Moved: {file_path.name} ‚Üí {final_dir.name}/{file_path.name}")
                
                if collision_status != "no_collision":
                    print(f"    Collision handling: {collision_status}")
                
                self.stats['created_directories'] += 1
            
            self.stats['processed_files'] += 1
            return True, "success"
            
        except Exception as e:
            error_msg = f"Error processing {file_path.name}: {e}"
            self.stats['errors'].append(error_msg)
            print(f"  ‚ùå {error_msg}")
            return False, str(e)
    
    def process_directory(self, target_dir: Path) -> bool:
        """Process all files in the specified directory."""
        if not target_dir.exists():
            print(f"Error: Directory '{target_dir}' does not exist.")
            return False
        
        if not target_dir.is_dir():
            print(f"Error: '{target_dir}' is not a directory.")
            return False
        
        print(f"Processing files in: {target_dir}")
        if self.dry_run:
            print("DRY RUN MODE - No files will be moved")
        print(f"File types to process: {', '.join(sorted(self.file_types))}")
        print()
        
        # Get all files in the directory (not subdirectories)
        all_files = [f for f in target_dir.iterdir() if f.is_file()]
        files_to_process = [f for f in all_files if self.should_process_file(f)]
        
        self.stats['total_files'] = len(all_files)
        
        if not files_to_process:
            print("No files found to process.")
            return True
        
        print(f"Found {len(files_to_process)} files to process (out of {len(all_files)} total files):")
        
        # Process each file
        for i, file_path in enumerate(files_to_process, 1):
            print(f"[{i}/{len(files_to_process)}] Processing: {file_path.name}")
            success, message = self.process_file(file_path)
            
            if not success:
                self.stats['skipped_files'] += 1
        
        # Print summary
        self.print_summary()
        return True
    
    def print_summary(self) -> None:
        """Print processing summary and statistics."""
        print("\n" + "=" * 50)
        print("PROCESSING SUMMARY")
        print("=" * 50)
        
        print(f"Total files found: {self.stats['total_files']}")
        
        if self.dry_run:
            print(f"Files that would be processed: {self.stats['processed_files']}")
            print(f"Directories that would be created: {self.stats['created_directories']}")
        else:
            print(f"Files successfully processed: {self.stats['processed_files']}")
            print(f"Directories created: {self.stats['created_directories']}")
        
        print(f"Files skipped: {self.stats['skipped_files']}")
        print(f"Errors encountered: {len(self.stats['errors'])}")
        
        if self.stats['errors']:
            print("\nErrors:")
            for error in self.stats['errors']:
                print(f"  - {error}")
        
        if len(self.stats['errors']) == 0 and self.stats['processed_files'] > 0:
            print("\nüéâ Processing completed successfully!")
        elif len(self.stats['errors']) > 0:
            print("\n‚ö†Ô∏è  Processing completed with errors.")
        else:
            print("\n‚ö™ No files were processed.")


def main():
    """Main function with argument parsing and execution."""
    parser = argparse.ArgumentParser(
        description="Plex Directory Creator - Convert files to directory structure",
        epilog="""
Examples:
  %(prog)s /path/to/media                    # Process all supported file types (interactive)
  %(prog)s /path/to/media --dry-run          # Preview changes
  %(prog)s /path/to/media -y                 # Process without confirmation
  %(prog)s /path/to/media --types mp4 mkv   # Only process MP4 and MKV files
  %(prog)s /path/to/media --exclude txt pdf # Exclude text and PDF files
  %(prog)s /path/to/media --force            # Force run (bypass lock)
  
Cron Usage:
  # Run daily at 4 AM (non-interactive)
  0 4 * * * /usr/local/bin/plex_make_dirs /path/to/media -y
        """,
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument(
        'directory',
        help='Directory containing files to process'
    )
    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='Show what would be done without making changes'
    )
    parser.add_argument(
        '--force',
        action='store_true',
        help='Force execution even if another instance is running'
    )
    parser.add_argument(
        '-y', '--yes',
        action='store_true',
        help='Skip confirmation prompts (for non-interactive use)'
    )
    parser.add_argument(
        '--types',
        nargs='+',
        metavar='EXT',
        help='File extensions to process (e.g., mp4 mkv avi). If not specified, processes all supported media types.'
    )
    parser.add_argument(
        '--exclude',
        nargs='+',
        metavar='EXT',
        help='File extensions to exclude from processing'
    )
    parser.add_argument(
        '--list-types',
        action='store_true',
        help='List all supported file types and exit'
    )
    parser.add_argument(
        '--version',
        action='version',
        version='%(prog)s 2.1.0'
    )
    
    args = parser.parse_args()
    
    # Handle --list-types
    if args.list_types:
        creator = PlexDirectoryCreator()
        print("Supported file types:")
        for ext in sorted(creator.default_media_types):
            print(f"  {ext}")
        sys.exit(0)
    
    # Validate arguments
    if args.yes and args.dry_run:
        print("Warning: -y/--yes flag has no effect in dry-run mode", file=sys.stderr)
    
    # Create creator instance
    creator = PlexDirectoryCreator(
        dry_run=args.dry_run,
        force=args.force,
        file_types=set(args.types) if args.types else None,
        exclude_types=set(args.exclude) if args.exclude else None
    )
    
    try:
        # Acquire lock
        if not creator.acquire_lock():
            sys.exit(1)
        
        # Confirmation prompt for non-dry-run operations
        if not args.dry_run and not args.yes and not is_non_interactive():
            print("\nThis will create directories and move files to organize your media.")
            print("Files will be moved into directories named after the file (without extension).")
            try:
                response = input("\nDo you want to proceed? (yes/no): ").strip().lower()
                if response not in ['yes', 'y']:
                    print("Operation cancelled.")
                    sys.exit(0)
            except (EOFError, KeyboardInterrupt):
                print("\nOperation cancelled.")
                sys.exit(0)
        elif not args.dry_run and (args.yes or is_non_interactive()):
            if args.yes:
                print("Proceeding with directory creation (--yes flag)...")
            else:
                print("Proceeding with directory creation (non-interactive environment)...")
        
        # Process directory
        target_dir = Path(args.directory).resolve()
        success = creator.process_directory(target_dir)
        
        sys.exit(0 if success else 1)
        
    except KeyboardInterrupt:
        print("\nOperation cancelled by user.")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)
    finally:
        creator.release_lock()


if __name__ == '__main__':
    main()