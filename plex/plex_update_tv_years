#!/usr/bin/env python3
"""
Plex TV Show Year Updater
Version: 2.0
Purpose: Update TV show directories with correct release years using TVDB API

This refactored version uses modular components from lib/ for better code reuse:
- lib/tvdb_client.py: TVDB v4 API client with JWT authentication
- lib/cache_manager.py: Generic JSON-based caching with TTL support
- lib/retry_utils.py: Exponential backoff decorator for network resilience
- lib/media_name_utils.py: Media name parsing and year extraction
- lib/credential_manager.py: Multi-source credential resolution

The script has been reduced from 1,080 lines to ~600 lines through DRY refactoring
while maintaining all original functionality including zero external dependencies,
comprehensive caching, and robust error handling.
"""

import os
import sys
import argparse
import tempfile
import time
from pathlib import Path
from typing import Optional, Dict, Any

# ======================================================

# ======================================================
# INJECTED MODULE - START
# Generated by build.py v3.0.0
# Source: utils.py
# ======================================================

"""
Shared Utility Module for Media Library Tools

This module provides backward compatibility by re-exporting functions from the
new modular library structure. New development should use the lib/ modules directly.

DEPRECATED: This module is maintained for backward compatibility only.
New tools should use the modular lib/ structure:
- lib/core.py: Essential utilities (locking, config, platform detection)
- lib/ui.py: User interface functions (banners, formatting, confirmations)
- lib/filesystem.py: File operations
- lib/validation.py: Input validation and error handling

Author: Media Library Tools Project
Version: 1.0.0
"""

import sys
import warnings
from pathlib import Path

# Add lib directory to path for imports
lib_path = Path(__file__).parent / "lib"
if str(lib_path) not in sys.path:
    sys.path.insert(0, str(lib_path))

# Import all functions from modular libraries
try:
    from core import (
        ConfigCache,
        FileLock,
        acquire_lock,
        debug_config_resolution,
        get_config_source,
        is_non_interactive,
        is_windows,
        read_config_bool,
        read_config_value,
        read_global_config_bool,
        read_local_env_file,
        release_lock,
        should_use_emojis,
        validate_config_setup,
    )
    from filesystem import (
        get_directory_size,
        validate_directory_path,
    )
    from ui import (
        confirm_action,
        display_banner,
        format_size,
        format_status_message,
    )
    from validation import (
        validate_path_argument,
    )
except ImportError as e:
    # Fallback warning if lib modules are not available
    warnings.warn(
        f"Could not import from lib modules: {e}. Using legacy implementations.",
        DeprecationWarning,
        stacklevel=2,
    )

    # Keep legacy implementations as fallback
    import contextlib
    import os
    import platform
    import tempfile
    from typing import Optional, Tuple

    # Platform-specific imports
    try:
        import fcntl  # Unix/Linux/macOS
    except ImportError:
        fcntl = None  # Windows

    try:
        import msvcrt  # Windows
    except ImportError:
        msvcrt = None  # Unix/Linux/macOS

    # Legacy function implementations (fallback only)
    def display_banner(
        script_name: str,
        version: str,
        description: str,
        no_banner_flag: bool = False,
        quiet_mode: bool = False,
    ) -> None:
        """
        Display standardized banner for media library tools.

        Args:
            script_name: Name of the script
            version: Version string
            description: Brief description of the script
            no_banner_flag: If True, suppress banner display
            quiet_mode: If True, suppress banner display
        """
        # Check suppression conditions (highest to lowest priority)
        if no_banner_flag or quiet_mode or is_non_interactive():
            return

        try:
            # Display standardized ASCII art
            print("┏┳┓┏━╸╺┳┓╻┏━┓╻  ╻┏┓ ┏━┓┏━┓┏━┓╻ ╻╺┳╸┏━┓┏━┓╻  ┏━┓")
            print("┃┃┃┣╸  ┃┃┃┣━┫┃  ┃┣┻┓┣┳┛┣━┫┣┳┛┗┳┛ ┃ ┃ ┃┃ ┃┃  ┗━┓")
            print("╹ ╹┗━╸╺┻┛╹╹ ╹┗━╸╹┗━┛╹┗╸╹ ╹╹┗╸ ╹  ╹ ┗━┛┗━┛┗━╸┗━┛")
            print(f"{script_name} v{version}: {description}")
            print()  # Blank line for separation
        except Exception:
            # Banner display errors should not prevent script execution
            pass

    def is_non_interactive() -> bool:
        """
        Detect if running in non-interactive environment (cron, etc.).

        Returns:
            True if non-interactive, False otherwise
        """
        # Check if stdin is not a TTY (common in cron jobs)
        if not sys.stdin.isatty():
            return True

        # Check for common non-interactive environment variables
        non_interactive_vars = ["CRON", "CI", "AUTOMATED", "NON_INTERACTIVE"]
        for var in non_interactive_vars:
            if os.environ.get(var):
                return True

        # Check if TERM is not set or is 'dumb' (common in automated environments)
        term = os.environ.get("TERM", "")
        return bool(not term or term == "dumb")

    def read_global_config_bool(var_name: str, default: bool = False) -> bool:
        """
        Read a boolean environment variable with support for .env files.

        Args:
            var_name: Name of the environment variable
            default: Default value if not found

        Returns:
            Boolean value of the environment variable
        """
        # Check environment variable directly
        value = os.environ.get(var_name)
        if value is not None:
            return value.lower() in ("true", "1", "yes", "on")

        # Check local .env file
        env_file = ".env"
        if os.path.exists(env_file):
            try:
                with open(env_file) as f:
                    for line in f:
                        line = line.strip()
                        if line.startswith(f"{var_name}="):
                            value = line.split("=", 1)[1].strip()
                            return value.lower() in ("true", "1", "yes", "on")
            except OSError:
                pass

        # Check global .env file
        global_env_path = Path.home() / ".media-library-tools" / ".env"
        if global_env_path.exists():
            try:
                with open(global_env_path) as f:
                    for line in f:
                        line = line.strip()
                        if line.startswith(f"{var_name}="):
                            value = line.split("=", 1)[1].strip()
                            return value.lower() in ("true", "1", "yes", "on")
            except OSError:
                pass

        return default

    def is_windows() -> bool:
        """
        Detect if running on Windows platform.

        Returns:
            True if running on Windows, False otherwise
        """
        return platform.system().lower() == "windows"

    def should_use_emojis() -> bool:
        """
        Determine if emojis should be used based on platform and environment.

        Returns:
            True if emojis should be used, False otherwise
        """
        # Don't use emojis on Windows to avoid encoding issues
        if is_windows():
            return False

        # Don't use emojis in non-interactive environments
        if is_non_interactive():
            return False

        # Check for explicit emoji suppression
        return not read_global_config_bool("NO_EMOJIS", False)

    def format_size(size_bytes: int) -> str:
        """
        Format size in bytes to human readable format.

        Args:
            size_bytes: Size in bytes

        Returns:
            Human readable size string
        """
        for unit in ["B", "K", "M", "G", "T"]:
            if size_bytes < 1024.0:
                if unit == "B":
                    return f"{size_bytes:.0f}{unit}"
                else:
                    return f"{size_bytes:.1f}{unit}"
            size_bytes /= 1024.0
        return f"{size_bytes:.1f}P"

    def confirm_action(message: str, skip_confirmation: bool = False) -> bool:
        """
        Ask for user confirmation unless skipped.

        Args:
            message: Confirmation message to display
            skip_confirmation: If True, automatically confirm

        Returns:
            True if confirmed, False otherwise
        """
        if skip_confirmation:
            return True

        try:
            response = input(f"{message} (y/N): ").strip().lower()
            return response in ["y", "yes"]
        except (EOFError, KeyboardInterrupt):
            print("\nOperation cancelled.")
            return False

    class FileLock:
        """
        File locking utility class for preventing concurrent executions.
        """

        def __init__(self, lock_prefix: str = "media_library_tool"):
            """
            Initialize file lock.

            Args:
                lock_prefix: Prefix for lock file name
            """
            self.lock_prefix = lock_prefix
            self.lock_file = None

        def acquire_lock(self, force: bool = False) -> bool:
            """
            Acquire file lock to prevent multiple instances.

            Args:
                force: If True, skip locking mechanism

            Returns:
                True if lock acquired successfully, False otherwise
            """
            if force:
                return True

            try:
                with tempfile.NamedTemporaryFile(
                    mode="w",
                    prefix=f"{self.lock_prefix}_",
                    suffix=".lock",
                    delete=False,
                ) as temp_file:
                    self.lock_file = temp_file

                    # Platform-specific file locking
                    if fcntl is not None:  # Unix/Linux/macOS
                        fcntl.flock(
                            self.lock_file.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB
                        )
                    elif msvcrt is not None:  # Windows
                        msvcrt.locking(self.lock_file.fileno(), msvcrt.LK_NBLCK, 1)
                    else:
                        # Fallback: no locking available, just proceed
                        pass

                    self.lock_file.write(str(os.getpid()))
                    self.lock_file.flush()
                return True
            except OSError as e:
                if self.lock_file:
                    self.lock_file.close()
                    with contextlib.suppress(OSError):
                        os.unlink(self.lock_file.name)
                    self.lock_file = None
                print(
                    "Error: Another instance is already running. Use --force to override."
                )
                print(f"Lock error: {e}")
                return False

        def release_lock(self) -> None:
            """
            Release the file lock.
            """
            if self.lock_file:
                try:
                    # Only unlock if file is still open
                    if not self.lock_file.closed:
                        # Platform-specific file unlocking
                        if fcntl is not None:  # Unix/Linux/macOS
                            fcntl.flock(self.lock_file.fileno(), fcntl.LOCK_UN)
                        elif msvcrt is not None:  # Windows
                            msvcrt.locking(self.lock_file.fileno(), msvcrt.LK_UNLCK, 1)
                        # No explicit unlock needed for fallback case

                        self.lock_file.close()
                except (OSError, ValueError):
                    # Handle both file system errors and closed file errors
                    pass

                # Always try to remove lock file if it exists
                try:
                    if os.path.exists(self.lock_file.name):
                        os.unlink(self.lock_file.name)
                except OSError:
                    pass
                finally:
                    self.lock_file = None

    # Legacy standalone functions for backward compatibility
    def acquire_lock(
        lock_prefix: str = "media_library_tool", force: bool = False
    ) -> Tuple[bool, Optional[FileLock]]:
        """
        Legacy function for acquiring file locks.

        Args:
            lock_prefix: Prefix for lock file name
            force: If True, skip locking mechanism

        Returns:
            Tuple of (success: bool, lock_instance: FileLock or None)
        """
        lock = FileLock(lock_prefix)
        success = lock.acquire_lock(force)
        return success, lock if success else None

    def release_lock(lock_instance: FileLock) -> None:
        """
        Legacy function for releasing file locks.

        Args:
            lock_instance: FileLock instance to release
        """
        if lock_instance:
            lock_instance.release_lock()

    def format_status_message(
        message: str, emoji: str = "", fallback_prefix: str = ""
    ) -> str:
        """
        Format a status message with emoji on supported platforms or fallback text.

        Args:
            message: The main message text
            emoji: The emoji to use on supported platforms
            fallback_prefix: Text prefix to use instead of emoji on unsupported platforms

        Returns:
            Formatted message string
        """
        if should_use_emojis() and emoji:
            return f"{emoji} {message}"
        elif fallback_prefix:
            return f"{fallback_prefix}: {message}"
        else:
            return message

    # Add any missing functions that might be needed for backward compatibility
    def get_directory_size(path: str) -> int:
        """Legacy fallback for directory size calculation."""
        total_size = 0
        try:
            for dirpath, _dirnames, filenames in os.walk(path):
                for filename in filenames:
                    filepath = os.path.join(dirpath, filename)
                    try:
                        total_size += os.path.getsize(filepath)
                    except OSError:
                        continue
        except OSError:
            pass
        return total_size

    def validate_directory_path(path: str) -> Tuple[bool, str]:
        """Legacy fallback for directory path validation."""
        if not path:
            return False, "Path cannot be empty"

        path_obj = Path(path)

        if not path_obj.exists():
            return False, f"Path does not exist: {path}"

        if not path_obj.is_dir():
            return False, f"Path is not a directory: {path}"

        return True, ""

    def validate_path_argument(path: str) -> Tuple[bool, str]:
        """Legacy fallback for path argument validation."""
        return validate_directory_path(path)


# ======================================================
# INJECTED MODULE - END
# Source: utils.py
# ======================================================



# ======================================================

# Import shared modules (will be included by build system)
# {{include retry_utils.py}}
# {{include cache_manager.py}}
# {{include tvdb_client.py}}
# {{include media_name_utils.py}}
# {{include credential_manager.py}}


VERSION = "2.0"


class TVShowYearUpdater:
    """Main class for updating TV show directories with correct years."""

    def __init__(self, tvdb_key: str, dry_run: bool = False, force: bool = False,
                 verbose: bool = False, debug: bool = False, yes: bool = False,
                 cache_dir: Optional[str] = None, cache_refresh: bool = False):
        """
        Initialize the TV Show Year Updater.

        Args:
            tvdb_key: TVDB API key
            dry_run: If True, only show what would be done
            force: Force execution even if another instance is running
            verbose: Enable verbose output
            debug: Enable debug output
            yes: Skip confirmation prompts
            cache_dir: Custom cache directory, defaults to ~/.cache
            cache_refresh: Force refresh of cached data
        """
        self.tvdb_key = tvdb_key
        self.dry_run = dry_run
        self.force = force
        self.verbose = verbose
        self.debug = debug
        self.yes = yes
        self.cache_refresh = cache_refresh
        self.file_lock = FileLock('plex_update_tv_years')

        # Initialize cache if not forcing refresh
        self.cache = None if cache_refresh else CacheManager('plex_tv_shows', cache_dir)
        self.tvdb_client = TVDBClient(tvdb_key, debug, self.cache)

        # Initialize media name parser
        self.name_parser = MediaNameParser(debug=debug)

        # Statistics
        self.stats = {
            'directories_processed': 0,
            'directories_renamed': 0,
            'directories_would_rename': 0,
            'directories_skipped': 0,
            'api_errors': 0,
            'file_errors': 0
        }

    def log_verbose(self, message: str) -> None:
        """Log verbose message if verbose mode is enabled."""
        if self.verbose:
            print(f"VERBOSE: {message}")

    def log_debug(self, message: str) -> None:
        """Log debug message if debug mode is enabled."""
        if self.debug:
            print(f"DEBUG: {message}")

    def acquire_lock(self, lock_dir: Path) -> bool:
        """
        Acquire file lock to prevent concurrent executions.

        Args:
            lock_dir: Directory to store lock file

        Returns:
            bool: True if lock acquired, False otherwise
        """
        return self.file_lock.acquire_lock(self.force)

    def release_lock(self) -> None:
        """Release the file lock."""
        self.file_lock.release_lock()

    def process_directory(self, target_path: Path) -> None:
        """
        Process the target directory to update TV show years.

        Args:
            target_path: Path to directory containing TV shows
        """
        self.log_verbose(f"Processing directory: {target_path}")

        # Acquire lock
        lock_dir = Path(tempfile.gettempdir())
        if not self.acquire_lock(lock_dir):
            return

        try:
            # Get all subdirectories (potential TV shows)
            tv_directories = [d for d in target_path.iterdir()
                            if d.is_dir() and not d.name.startswith('.')]

            if not tv_directories:
                print("No directories found to process")
                return

            print(f"Found {len(tv_directories)} directories to analyze")

            if not self.dry_run and not self.yes and not is_non_interactive():
                response = input(f"\nProceed with analyzing {len(tv_directories)} directories? [y/N]: ")
                if response.lower() not in ['y', 'yes']:
                    print("Operation cancelled.")
                    return
            elif self.yes or is_non_interactive():
                print("Proceeding with directory analysis...")

            # Process each directory
            for i, tv_dir in enumerate(tv_directories, 1):
                self.stats['directories_processed'] += 1

                print(f"\n[{i}/{len(tv_directories)}] {tv_dir.name}")
                self.log_verbose(f"Processing: {tv_dir.name}")

                # Extract clean show name for TVDB search
                clean_name = self.name_parser.clean_show_name(tv_dir.name)
                self.log_debug(f"Clean name for search: '{clean_name}'")

                if not clean_name:
                    print("  WARNING: Could not extract show name, skipping")
                    self.stats['directories_skipped'] += 1
                    continue

                # Search TVDB for show information
                try:
                    show_data = self.tvdb_client.search_show(clean_name)
                    if not show_data:
                        print(f"  ERROR: No TVDB results found for '{clean_name}'")
                        self.stats['api_errors'] += 1
                        continue

                    tvdb_year = show_data.get('year')
                    if not tvdb_year:
                        print(f"  WARNING: No year information available in TVDB")
                        self.stats['api_errors'] += 1
                        continue

                    # Check if update is needed using name parser
                    needs_update, current_year = self.name_parser.needs_year_update(
                        tv_dir.name, tvdb_year
                    )

                    if not needs_update:
                        print(f"  Already has correct year ({tvdb_year})")
                        continue

                    # Generate new name using name parser
                    new_name = self.name_parser.format_name_with_year(clean_name, tvdb_year)
                    new_path = tv_dir.parent / new_name

                    if current_year:
                        print(f"  Would change year: {current_year} → {tvdb_year}")
                    else:
                        print(f"  Would add year: {tvdb_year}")

                    print(f"  New name: {new_name}")

                    # Check if target already exists
                    if new_path.exists():
                        print(f"  ERROR: Target directory already exists: {new_name}")
                        self.stats['file_errors'] += 1
                        continue

                    # Perform the rename (if not dry-run)
                    if not self.dry_run:
                        try:
                            tv_dir.rename(new_path)
                            print(f"  SUCCESS: Renamed successfully")
                            self.stats['directories_renamed'] += 1
                        except OSError as e:
                            print(f"  ERROR: Failed to rename: {e}")
                            self.stats['file_errors'] += 1
                    else:
                        print(f"  DRY RUN: Would rename to '{new_name}'")
                        self.stats['directories_would_rename'] += 1

                    # Small delay to be respectful to TVDB API
                    time.sleep(0.5)

                except Exception as e:
                    print(f"  ERROR: Error processing directory: {e}")
                    self.stats['api_errors'] += 1
                    self.log_debug(f"Error details: {e}")

            # Display final statistics
            self.display_statistics()

        finally:
            self.release_lock()

    def display_statistics(self) -> None:
        """Display processing statistics."""
        print(f"\nProcessing complete!")
        print(f"Statistics:")
        print(f"   Directories processed: {self.stats['directories_processed']}")
        if self.dry_run:
            print(f"   Directories would rename: {self.stats['directories_would_rename']}")
        else:
            print(f"   Directories renamed: {self.stats['directories_renamed']}")
        print(f"   Directories skipped: {self.stats['directories_skipped']}")
        print(f"   API errors: {self.stats['api_errors']}")
        print(f"   File errors: {self.stats['file_errors']}")

        # Display cache statistics if cache is enabled
        if self.cache and (self.tvdb_client.cache_hits > 0 or self.tvdb_client.cache_misses > 0):
            total_requests = self.tvdb_client.cache_hits + self.tvdb_client.cache_misses
            hit_rate = (self.tvdb_client.cache_hits / total_requests * 100) if total_requests > 0 else 0
            print(f"   Cache hits: {self.tvdb_client.cache_hits}")
            print(f"   Cache misses: {self.tvdb_client.cache_misses}")
            print(f"   Cache hit rate: {hit_rate:.1f}%")

        # Display retry statistics if retries occurred
        if self.tvdb_client.retry_attempts > 0:
            print(f"   Retry attempts: {self.tvdb_client.retry_attempts}")
            print(f"   Successful retries: {self.tvdb_client.retry_successes}")
            retry_success_rate = (self.tvdb_client.retry_successes / self.tvdb_client.retry_attempts * 100) if self.tvdb_client.retry_attempts > 0 else 0
            print(f"   Retry success rate: {retry_success_rate:.1f}%")

    def display_cache_statistics(self) -> None:
        """Display detailed cache statistics."""
        if not self.cache:
            print("Caching is disabled.")
            return

        stats = self.cache.get_stats()
        print(f"Cache Statistics:")
        print(f"  Cache file: {stats['cache_file']}")
        print(f"  Total entries: {stats['total_entries']}")
        print(f"  Expired entries: {stats['expired_entries']}")
        print(f"  Cache size: {self.format_bytes(stats['cache_size_bytes'])}")
        if stats['total_entries'] > 0:
            print(f"  Oldest entry: {stats['oldest_entry_age_days']:.1f} days old")

        # Show hit rate from current session if available
        if hasattr(self, 'tvdb_client'):
            total_requests = self.tvdb_client.cache_hits + self.tvdb_client.cache_misses
            if total_requests > 0:
                hit_rate = (self.tvdb_client.cache_hits / total_requests * 100)
                print(f"  Session hit rate: {hit_rate:.1f}% ({self.tvdb_client.cache_hits}/{total_requests})")

    def format_bytes(self, bytes_count: int) -> str:
        """Format byte count in human readable format."""
        for unit in ['B', 'KB', 'MB', 'GB']:
            if bytes_count < 1024.0:
                return f"{bytes_count:.1f} {unit}"
            bytes_count /= 1024.0
        return f"{bytes_count:.1f} TB"


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description='Update TV show directories with correct release years using TVDB API',
        epilog='''
Examples:
  %(prog)s /path/to/tv/shows --dry-run
  %(prog)s /path/to/tv/shows --tvdb-key YOUR_API_KEY
  %(prog)s /path/to/tv/shows -y --verbose

Cache Management:
  %(prog)s --cache-stats                     # Show cache statistics
  %(prog)s --cache-clear                     # Clear cache (with confirmation)
  %(prog)s --cache-clear -y                  # Clear cache (no confirmation)
  %(prog)s --cache-refresh /path/to/shows    # Force refresh cached data
  %(prog)s --cache-dir /custom/cache/path    # Use custom cache directory

Cron Usage:
  # Run daily at 3 AM (non-interactive)
  0 3 * * * /usr/local/bin/plex_update_tv_years /path/to/tv/shows -y

The script will scan TV show directories, look up correct years via TVDB API,
and rename directories to "Show Title (YEAR)" format. Results are cached for
14 days to reduce API calls on subsequent runs.
        ''',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    parser.add_argument('path', nargs='?', default='.',
                        help='Directory to process (default: current directory)')
    parser.add_argument('--tvdb-key',
                        help='TVDB API key (can also use TVDB_API_KEY env var, local .env, or ~/.media-library-tools/.env)')
    parser.add_argument('--dry-run', action='store_true', default=True,
                        help='Show what would be renamed without making changes (default: true)')
    parser.add_argument('--execute', action='store_true',
                        help='Actually perform the renaming operations (overrides --dry-run)')
    parser.add_argument('-y', '--yes', action='store_true',
                        help='Skip confirmation prompts (for non-interactive use)')
    parser.add_argument('--force', action='store_true',
                        help='Force execution even if another instance is running')
    parser.add_argument('--verbose', '-v', action='store_true',
                        help='Show verbose output')
    parser.add_argument('--debug', action='store_true',
                        help='Show detailed debug output')
    parser.add_argument('--no-banner', action='store_true',
                        help='Suppress banner display')

    # Cache management options
    parser.add_argument('--cache-stats', action='store_true',
                        help='Show cache statistics (hits, misses, size, entries)')
    parser.add_argument('--cache-refresh', action='store_true',
                        help='Force refresh of cached data during processing')
    parser.add_argument('--cache-clear', action='store_true',
                        help='Clear all cached data and exit')
    parser.add_argument('--cache-dir',
                        help='Specify custom cache directory (default: ~/.cache)')

    parser.add_argument('--version', action='version', version=f'%(prog)s v{VERSION}')

    args = parser.parse_args()

    # Read configuration with CLI > ENV > Local .env > Global .env priority
    auto_execute = read_config_bool('AUTO_EXECUTE', cli_args=args, default=False)
    auto_confirm = read_config_bool('AUTO_CONFIRM', cli_args=args, default=False)
    quiet_mode = read_config_bool('QUIET_MODE', cli_args=args, default=False)

    # Apply configuration (CLI arguments already have highest priority via read_config_bool)
    if auto_execute and not args.execute:
        args.execute = True  # Set execute flag if AUTO_EXECUTE is set
    if auto_confirm and not args.yes:
        args.yes = True  # Set yes flag if AUTO_CONFIRM is set

    # Handle dry-run/execute logic
    if args.execute:
        dry_run_mode = False
    else:
        dry_run_mode = args.dry_run  # This is True by default

    # Validate arguments
    if args.yes and dry_run_mode:
        print("Warning: -y/--yes flag has no effect in dry-run mode", file=sys.stderr)

    # Get TVDB API key using credential manager
    cred_manager = CredentialManager(debug=args.debug)
    tvdb_key = cred_manager.get_credential('TVDB_API_KEY', args.tvdb_key)
    if not tvdb_key:
        print("Error: TVDB_API_KEY not found. Please provide via --tvdb-key argument, "
              "TVDB_API_KEY environment variable, local .env file, or ~/.media-library-tools/.env file", file=sys.stderr)
        sys.exit(1)

    # Handle cache-specific operations that exit early
    if args.cache_clear or args.cache_stats:
        # Initialize cache for these operations
        cache = CacheManager('plex_tv_shows', args.cache_dir)

        if args.cache_clear:
            display_banner("plex_update_tv_years", VERSION,
                          "add/correct tv show years in directories using TVDB API",
                          args.no_banner, quiet_mode)
            print("Clearing cache...")

            if not args.yes and not is_non_interactive():
                stats = cache.get_stats()
                print(f"Cache location: {stats['cache_file']}")
                print(f"Cache entries: {stats['total_entries']}")
                print(f"Cache size: {stats['cache_size_bytes']} bytes")
                response = input("\nConfirm cache clear? [y/N]: ")
                if response.lower() not in ['y', 'yes']:
                    print("Cache clear cancelled.")
                    sys.exit(0)

            if cache.clear():
                print("Cache cleared successfully.")
            else:
                print("Error: Failed to clear cache.", file=sys.stderr)
                sys.exit(1)
            sys.exit(0)

        if args.cache_stats:
            display_banner("plex_update_tv_years", VERSION,
                          "add/correct tv show years in directories using TVDB API",
                          args.no_banner, quiet_mode)
            updater = TVShowYearUpdater(
                tvdb_key=tvdb_key,
                dry_run=True,
                force=args.force,
                verbose=args.verbose,
                debug=args.debug,
                yes=args.yes,
                cache_dir=args.cache_dir
            )
            updater.display_cache_statistics()
            sys.exit(0)

    # Display banner
    display_banner("plex_update_tv_years", VERSION,
                  "add/correct tv show years in directories using TVDB API",
                  args.no_banner, quiet_mode)

    if dry_run_mode:
        print("DRY-RUN MODE: No changes will be made")
    else:
        print("EXECUTE MODE: Changes will be made to directories")

    try:
        updater = TVShowYearUpdater(
            tvdb_key=tvdb_key,
            dry_run=dry_run_mode,
            force=args.force,
            verbose=args.verbose,
            debug=args.debug,
            yes=args.yes,
            cache_dir=args.cache_dir,
            cache_refresh=args.cache_refresh
        )

        # Process the target directory
        target_path = Path(args.path).resolve()
        if not target_path.exists():
            print(f"Error: Path '{target_path}' does not exist", file=sys.stderr)
            sys.exit(1)

        if not target_path.is_dir():
            print(f"Error: Path '{target_path}' is not a directory", file=sys.stderr)
            sys.exit(1)

        updater.process_directory(target_path)

    except KeyboardInterrupt:
        print("\nOperation cancelled by user")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
