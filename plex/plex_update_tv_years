#!/usr/bin/env python3
"""
Plex TV Show Year Updater
Version: 1.0
Purpose: Update TV show directories with correct release years using TVDB API
"""

import os
import sys
import argparse
import json
import urllib.request
import urllib.parse
import urllib.error
import re
import fcntl
import tempfile
import time
from pathlib import Path
from typing import Optional, Dict, Any, List, Tuple

VERSION = "1.0"


def is_non_interactive() -> bool:
    """
    Detect if we're running in a non-interactive environment (e.g., cron job).
    
    Returns:
        bool: True if running non-interactively, False otherwise
    """
    # Check if stdin is not a TTY (common in cron jobs)
    if not sys.stdin.isatty():
        return True
    
    # Check common environment variables that indicate automation
    automation_vars = ['CRON', 'CI', 'AUTOMATED', 'NON_INTERACTIVE']
    for var in automation_vars:
        if os.environ.get(var):
            return True
    
    # Check if TERM is not set (common in cron)
    if not os.environ.get('TERM'):
        return True
    
    return False


class TVDBClient:
    """Client for interacting with TVDB v4 API."""
    
    def __init__(self, api_key: str, debug: bool = False):
        """
        Initialize TVDB client with API key.
        
        Args:
            api_key: TVDB API key
            debug: Enable debug output
        """
        self.api_key = api_key
        self.debug = debug
        self.base_url = "https://api4.thetvdb.com/v4"
        self.token = None
        self.token_expires = 0
    
    def login(self) -> bool:
        """
        Login to TVDB API and obtain JWT token.
        
        Returns:
            bool: True if login successful, False otherwise
        """
        login_url = f"{self.base_url}/login"
        login_data = {"apikey": self.api_key}
        
        try:
            req = urllib.request.Request(
                login_url,
                data=json.dumps(login_data).encode('utf-8'),
                headers={'Content-Type': 'application/json'}
            )
            
            with urllib.request.urlopen(req) as response:
                if response.status == 200:
                    data = json.loads(response.read().decode('utf-8'))
                    self.token = data['data']['token']
                    # Token expires in 1 month, we'll cache for 24 hours to be safe
                    self.token_expires = time.time() + (24 * 60 * 60)
                    if self.debug:
                        print("Successfully logged in to TVDB API")
                    return True
                else:
                    if self.debug:
                        print(f"Login failed with status {response.status}")
                    return False
                    
        except urllib.error.URLError as e:
            if self.debug:
                print(f"Login failed with network error: {e}")
            return False
        except (json.JSONDecodeError, KeyError) as e:
            if self.debug:
                print(f"Login failed with data error: {e}")
            return False
    
    def _ensure_authenticated(self) -> bool:
        """Ensure we have a valid authentication token."""
        if not self.token or time.time() >= self.token_expires:
            return self.login()
        return True
    
    def search_show(self, show_name: str) -> Optional[Dict[str, Any]]:
        """
        Search for a TV show by name.
        
        Args:
            show_name: Name of the show to search for
            
        Returns:
            dict: Show data with year information, or None if not found
        """
        if not self._ensure_authenticated():
            return None
        
        # Clean up show name for search
        clean_name = re.sub(r'[^\w\s-]', '', show_name).strip()
        search_url = f"{self.base_url}/search"
        params = {'query': clean_name, 'type': 'series'}
        
        try:
            url_with_params = f"{search_url}?{urllib.parse.urlencode(params)}"
            req = urllib.request.Request(
                url_with_params,
                headers={'Authorization': f'Bearer {self.token}'}
            )
            
            with urllib.request.urlopen(req) as response:
                if response.status == 200:
                    data = json.loads(response.read().decode('utf-8'))
                    results = data.get('data', [])
                    
                    if results:
                        # Return first result with year info
                        best_match = results[0]
                        if self.debug:
                            print(f"Found show: {best_match.get('name')} ({best_match.get('year')})")
                        return best_match
                    else:
                        if self.debug:
                            print(f"No results found for '{show_name}'")
                        return None
                else:
                    if self.debug:
                        print(f"Search failed with status {response.status}")
                    return None
                    
        except urllib.error.URLError as e:
            if self.debug:
                print(f"Search failed with network error: {e}")
            return None
        except (json.JSONDecodeError, KeyError) as e:
            if self.debug:
                print(f"Search failed with data error: {e}")
            return None


class TVShowYearUpdater:
    """Main class for updating TV show directories with correct years."""
    
    def __init__(self, tvdb_key: str, dry_run: bool = False, force: bool = False, 
                 verbose: bool = False, debug: bool = False, yes: bool = False):
        """
        Initialize the TV Show Year Updater.
        
        Args:
            tvdb_key: TVDB API key
            dry_run: If True, only show what would be done
            force: Force execution even if another instance is running
            verbose: Enable verbose output
            debug: Enable debug output
            yes: Skip confirmation prompts
        """
        self.tvdb_key = tvdb_key
        self.dry_run = dry_run
        self.force = force
        self.verbose = verbose
        self.debug = debug
        self.yes = yes
        self.lock_file = None
        self.tvdb_client = TVDBClient(tvdb_key, debug)
        
        # Year detection patterns (from plex_make_years)
        self.year_patterns = [
            (r'\((\d{4})\)', 'Parentheses format (YYYY)'),
            (r'\[(\d{4})\]', 'Brackets format [YYYY]'),
            (r'\.(\d{4})\.', 'Dot separated .YYYY.'),
            (r'\s(\d{4})\s', 'Space separated YYYY'),
            (r'-(\d{4})-', 'Dash separated -YYYY-'),
            (r'_(\d{4})_', 'Underscore separated _YYYY_'),
            (r'\.(\d{4})$', 'Dot ending .YYYY'),
            (r'\s(\d{4})$', 'Space ending YYYY'),
            (r'-(\d{4})$', 'Dash ending -YYYY'),
            (r'_(\d{4})$', 'Underscore ending _YYYY'),
            (r'^(\d{4})\.', 'Dot beginning YYYY.'),
            (r'^(\d{4})\s', 'Space beginning YYYY '),
            (r'^(\d{4})-', 'Dash beginning YYYY-'),
            (r'^(\d{4})_', 'Underscore beginning YYYY_'),
            (r'\b(\d{4})\b', 'Standalone year YYYY'),
        ]
        
        # Statistics
        self.stats = {
            'directories_processed': 0,
            'directories_renamed': 0,
            'directories_skipped': 0,
            'api_errors': 0,
            'file_errors': 0
        }
    
    def log_verbose(self, message: str) -> None:
        """Log verbose message if verbose mode is enabled."""
        if self.verbose:
            print(f"VERBOSE: {message}")
    
    def log_debug(self, message: str) -> None:
        """Log debug message if debug mode is enabled."""
        if self.debug:
            print(f"DEBUG: {message}")
    
    def _get_credential_from_sources(self, credential_name: str, cli_value: Optional[str]) -> Optional[str]:
        """
        Get credential from CLI argument, environment variable, local .env file, or global .env file.
        
        Args:
            credential_name: Name of the credential (e.g., 'TVDB_API_KEY')
            cli_value: Value from CLI argument (takes priority)
            
        Returns:
            str: The credential value, or None if not found
            
        Priority order: CLI > Environment > Local .env > Global .env
        """
        # First check CLI argument
        if cli_value:
            self.log_debug(f"Found {credential_name} from CLI argument")
            return cli_value.strip('"\'')
        
        # Then check environment variable
        env_value = os.environ.get(credential_name)
        if env_value:
            self.log_debug(f"Found {credential_name} in environment variable")
            return env_value.strip('"\'')
        
        # Check local .env file
        env_file = '.env'
        if os.path.exists(env_file):
            try:
                with open(env_file, 'r') as f:
                    for line in f:
                        line = line.strip()
                        if line.startswith(f'{credential_name}='):
                            value = line.split('=', 1)[1].strip()
                            self.log_debug(f"Found {credential_name} in local .env file")
                            return value.strip('"\'')
            except (IOError, OSError) as e:
                self.log_debug(f"Could not read local .env file: {e}")
        
        # Finally check global .env file
        global_env_path = Path.home() / '.media-library-tool' / '.env'
        if global_env_path.exists():
            try:
                with open(global_env_path, 'r') as f:
                    for line in f:
                        line = line.strip()
                        if line.startswith(f'{credential_name}='):
                            value = line.split('=', 1)[1].strip()
                            self.log_debug(f"Found {credential_name} in global .env file")
                            return value.strip('"\'')
            except (IOError, OSError) as e:
                self.log_debug(f"Could not read global .env file: {e}")
        
        return None
    
    def extract_year_from_name(self, directory_name: str) -> Optional[int]:
        """
        Extract year from directory name using regex patterns.
        
        Args:
            directory_name: Name of the directory
            
        Returns:
            int: Extracted year, or None if no year found
        """
        for pattern, description in self.year_patterns:
            match = re.search(pattern, directory_name)
            if match:
                year = int(match.group(1))
                if 1900 <= year <= 2030:  # Reasonable year range
                    self.log_debug(f"Extracted year {year} using {description}")
                    return year
        return None
    
    def clean_show_name(self, directory_name: str) -> str:
        """
        Clean show name for TVDB search by removing year and common patterns.
        
        Args:
            directory_name: Original directory name
            
        Returns:
            str: Cleaned show name suitable for searching
        """
        # Remove year patterns
        cleaned = directory_name
        for pattern, _ in self.year_patterns:
            cleaned = re.sub(pattern, '', cleaned)
        
        # Clean up extra spaces and punctuation
        cleaned = re.sub(r'\s+', ' ', cleaned).strip()
        cleaned = re.sub(r'[._-]+$', '', cleaned)  # Remove trailing punctuation
        cleaned = re.sub(r'^[._-]+', '', cleaned)  # Remove leading punctuation
        
        return cleaned
    
    def acquire_lock(self, lock_dir: Path) -> bool:
        """
        Acquire file lock to prevent concurrent executions.
        
        Args:
            lock_dir: Directory to store lock file
            
        Returns:
            bool: True if lock acquired, False otherwise
        """
        try:
            lock_file_path = lock_dir / f"plex_update_tv_years_{os.getpid()}.lock"
            self.lock_file = open(lock_file_path, 'w')
            fcntl.flock(self.lock_file.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
            self.lock_file.write(f"{os.getpid()}\n{time.time()}")
            self.lock_file.flush()
            self.log_debug(f"Lock acquired: {lock_file_path}")
            return True
        except (OSError, IOError) as e:
            if not self.force:
                print(f"Error: Another instance is running. Use --force to override. ({e})")
                return False
            else:
                self.log_debug(f"Forced execution despite lock error: {e}")
                return True
    
    def release_lock(self) -> None:
        """Release the file lock."""
        if self.lock_file:
            try:
                fcntl.flock(self.lock_file.fileno(), fcntl.LOCK_UN)
                self.lock_file.close()
                # Clean up lock file
                if hasattr(self.lock_file, 'name'):
                    os.unlink(self.lock_file.name)
                self.log_debug("Lock released")
            except (OSError, IOError) as e:
                self.log_debug(f"Error releasing lock: {e}")
            finally:
                self.lock_file = None
    
    def needs_year_update(self, directory_name: str, tvdb_year: int) -> Tuple[bool, Optional[int]]:
        """
        Check if directory needs year update.
        
        Args:
            directory_name: Current directory name
            tvdb_year: Year from TVDB
            
        Returns:
            tuple: (needs_update, current_year_or_none)
        """
        current_year = self.extract_year_from_name(directory_name)
        
        if current_year is None:
            # No year in current name, needs update
            return True, None
        
        if current_year != tvdb_year:
            # Wrong year, needs update
            return True, current_year
        
        # Correct year already present
        return False, current_year
    
    def generate_new_name(self, clean_show_name: str, year: int) -> str:
        """
        Generate new directory name in 'Show Title (YEAR)' format.
        
        Args:
            clean_show_name: Clean show name without year
            year: Year to add
            
        Returns:
            str: New directory name
        """
        return f"{clean_show_name} ({year})"
    
    def process_directory(self, target_path: Path) -> None:
        """
        Process the target directory to update TV show years.
        
        Args:
            target_path: Path to directory containing TV shows
        """
        self.log_verbose(f"Processing directory: {target_path}")
        
        # Acquire lock
        lock_dir = Path(tempfile.gettempdir())
        if not self.acquire_lock(lock_dir):
            return
        
        try:
            # Get all subdirectories (potential TV shows)
            tv_directories = [d for d in target_path.iterdir() 
                            if d.is_dir() and not d.name.startswith('.')]
            
            if not tv_directories:
                print("No directories found to process")
                return
            
            print(f"Found {len(tv_directories)} directories to analyze")
            
            if not self.dry_run and not self.yes and not is_non_interactive():
                response = input(f"\nProceed with analyzing {len(tv_directories)} directories? [y/N]: ")
                if response.lower() not in ['y', 'yes']:
                    print("Operation cancelled.")
                    return
            elif self.yes or is_non_interactive():
                print("Proceeding with directory analysis...")
            
            # Process each directory
            for i, tv_dir in enumerate(tv_directories, 1):
                self.stats['directories_processed'] += 1
                
                print(f"\n[{i}/{len(tv_directories)}] {tv_dir.name}")
                self.log_verbose(f"Processing: {tv_dir.name}")
                
                # Extract clean show name for TVDB search
                clean_name = self.clean_show_name(tv_dir.name)
                self.log_debug(f"Clean name for search: '{clean_name}'")
                
                if not clean_name:
                    print("  WARNING: Could not extract show name, skipping")
                    self.stats['directories_skipped'] += 1
                    continue
                
                # Search TVDB for show information
                try:
                    show_data = self.tvdb_client.search_show(clean_name)
                    if not show_data:
                        print(f"  ERROR: No TVDB results found for '{clean_name}'")
                        self.stats['api_errors'] += 1
                        continue
                    
                    tvdb_year = show_data.get('year')
                    if not tvdb_year:
                        print(f"  WARNING: No year information available in TVDB")
                        self.stats['api_errors'] += 1
                        continue
                    
                    # Check if update is needed
                    needs_update, current_year = self.needs_year_update(tv_dir.name, tvdb_year)
                    
                    if not needs_update:
                        print(f"  Already has correct year ({tvdb_year})")
                        continue
                    
                    # Generate new name
                    new_name = self.generate_new_name(clean_name, tvdb_year)
                    new_path = tv_dir.parent / new_name
                    
                    if current_year:
                        print(f"  Would change year: {current_year} → {tvdb_year}")
                    else:
                        print(f"  Would add year: {tvdb_year}")
                    
                    print(f"  New name: {new_name}")
                    
                    # Check if target already exists
                    if new_path.exists():
                        print(f"  ERROR: Target directory already exists: {new_name}")
                        self.stats['file_errors'] += 1
                        continue
                    
                    # Perform the rename (if not dry-run)
                    if not self.dry_run:
                        try:
                            tv_dir.rename(new_path)
                            print(f"  SUCCESS: Renamed successfully")
                            self.stats['directories_renamed'] += 1
                        except OSError as e:
                            print(f"  ERROR: Failed to rename: {e}")
                            self.stats['file_errors'] += 1
                    else:
                        print(f"  DRY RUN: Would rename to '{new_name}'")
                        self.stats['directories_renamed'] += 1
                    
                    # Small delay to be respectful to TVDB API
                    time.sleep(0.5)
                    
                except Exception as e:
                    print(f"  ERROR: Error processing directory: {e}")
                    self.stats['api_errors'] += 1
                    self.log_debug(f"Error details: {e}")
            
            # Display final statistics
            self.display_statistics()
            
        finally:
            self.release_lock()
    
    def display_statistics(self) -> None:
        """Display processing statistics."""
        print(f"\nProcessing complete!")
        print(f"Statistics:")
        print(f"   Directories processed: {self.stats['directories_processed']}")
        print(f"   Directories renamed: {self.stats['directories_renamed']}")
        print(f"   Directories skipped: {self.stats['directories_skipped']}")
        print(f"   API errors: {self.stats['api_errors']}")
        print(f"   File errors: {self.stats['file_errors']}")


def get_tvdb_key_from_sources(cli_key: Optional[str] = None, debug: bool = False) -> Optional[str]:
    """
    Get TVDB API key from CLI argument, environment variable, local .env file, or global .env file.
    
    Args:
        cli_key: API key from CLI argument
        debug: Enable debug output
        
    Returns:
        str: The API key, or None if not found
        
    Priority order: CLI > Environment > Local .env > Global .env
    """
    # First check CLI argument
    if cli_key:
        if debug:
            print("DEBUG: Found TVDB_API_KEY from CLI argument")
        return cli_key.strip('"\'')
    
    # Then check environment variable
    env_key = os.environ.get('TVDB_API_KEY')
    if env_key:
        if debug:
            print("DEBUG: Found TVDB_API_KEY in environment variable")
        return env_key.strip('"\'')
    
    # Check local .env file
    env_file = '.env'
    if os.path.exists(env_file):
        try:
            with open(env_file, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line.startswith('TVDB_API_KEY='):
                        key = line.split('=', 1)[1].strip()
                        if debug:
                            print("DEBUG: Found TVDB_API_KEY in local .env file")
                        return key.strip('"\'')
        except (IOError, OSError) as e:
            if debug:
                print(f"DEBUG: Could not read local .env file: {e}")
    
    # Finally check global .env file
    global_env_path = Path.home() / '.media-library-tool' / '.env'
    if global_env_path.exists():
        try:
            with open(global_env_path, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line.startswith('TVDB_API_KEY='):
                        key = line.split('=', 1)[1].strip()
                        if debug:
                            print("DEBUG: Found TVDB_API_KEY in global .env file")
                        return key.strip('"\'')
        except (IOError, OSError) as e:
            if debug:
                print(f"DEBUG: Could not read global .env file: {e}")
    
    return None


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description='Update TV show directories with correct release years using TVDB API',
        epilog='''
Examples:
  %(prog)s /path/to/tv/shows --dry-run
  %(prog)s /path/to/tv/shows --tvdb-key YOUR_API_KEY
  %(prog)s /path/to/tv/shows -y --verbose

Cron Usage:
  # Run daily at 3 AM (non-interactive)
  0 3 * * * /usr/local/bin/plex_update_tv_years /path/to/tv/shows -y

The script will scan TV show directories, look up correct years via TVDB API,
and rename directories to "Show Title (YEAR)" format.
        ''',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument('path', nargs='?', default='.',
                        help='Directory to process (default: current directory)')
    parser.add_argument('--tvdb-key', 
                        help='TVDB API key (can also use TVDB_API_KEY env var, local .env, or ~/.media-library-tool/.env)')
    parser.add_argument('--dry-run', action='store_true', default=True,
                        help='Show what would be renamed without making changes (default: true)')
    parser.add_argument('--execute', action='store_true',
                        help='Actually perform the renaming operations (overrides --dry-run)')
    parser.add_argument('-y', '--yes', action='store_true',
                        help='Skip confirmation prompts (for non-interactive use)')
    parser.add_argument('--force', action='store_true',
                        help='Force execution even if another instance is running')
    parser.add_argument('--verbose', '-v', action='store_true',
                        help='Show verbose output')
    parser.add_argument('--debug', action='store_true',
                        help='Show detailed debug output')
    parser.add_argument('--version', action='version', version=f'%(prog)s v{VERSION}')
    
    args = parser.parse_args()
    
    # Handle dry-run/execute logic
    if args.execute:
        dry_run_mode = False
    else:
        dry_run_mode = args.dry_run  # This is True by default
    
    # Validate arguments
    if args.yes and dry_run_mode:
        print("Warning: -y/--yes flag has no effect in dry-run mode", file=sys.stderr)
    
    # Get TVDB API key
    tvdb_key = get_tvdb_key_from_sources(args.tvdb_key, args.debug)
    if not tvdb_key:
        print("Error: TVDB_API_KEY not found. Please provide via --tvdb-key argument, "
              "TVDB_API_KEY environment variable, local .env file, or ~/.media-library-tool/.env file", file=sys.stderr)
        sys.exit(1)
    
    # Display header
    print(f"Plex TV Show Year Updater v{VERSION}")
    print("=" * 50)
    
    if dry_run_mode:
        print("DRY-RUN MODE: No changes will be made")
    else:
        print("EXECUTE MODE: Changes will be made to directories")
    
    try:
        updater = TVShowYearUpdater(
            tvdb_key=tvdb_key,
            dry_run=dry_run_mode,
            force=args.force,
            verbose=args.verbose,
            debug=args.debug,
            yes=args.yes
        )
        
        # Process the target directory
        target_path = Path(args.path).resolve()
        if not target_path.exists():
            print(f"❌ Error: Path '{target_path}' does not exist", file=sys.stderr)
            sys.exit(1)
        
        if not target_path.is_dir():
            print(f"❌ Error: Path '{target_path}' is not a directory", file=sys.stderr)
            sys.exit(1)
        
        updater.process_directory(target_path)
        
    except KeyboardInterrupt:
        print("\nOperation cancelled by user")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()