#!/usr/bin/env python3
"""
Plex Season Organizer (Batch)

A comprehensive tool for organizing TV show episodes into season directories across
multiple show directories. This script processes all subdirectories in a target
directory and organizes video files into proper season structures.

Features:
- Batch processing of multiple TV show directories
- Parallel processing for improved performance
- Progress tracking and detailed reporting
- File-based locking mechanism
- Comprehensive error handling and recovery
- Dry-run mode for safe testing
- Cron-friendly operation

Author: Media Library Tools Project
Version: 2.1.0
"""

import argparse
import concurrent.futures
import fcntl
import os
import re
import shutil
import sys
import tempfile
import time
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union


def display_banner(script_name: str, version: str, description: str, 
                  no_banner_flag: bool = False, quiet_mode: bool = False) -> None:
    """
    Display standardized banner for media library tools.
    """
    # Check suppression conditions (highest to lowest priority)
    if no_banner_flag or quiet_mode or is_non_interactive():
        return
    
    try:
        # Display standardized ASCII art
        print("┏┳┓┏━╸╺┳┓╻┏━┓╻  ╻┏┓ ┏━┓┏━┓┏━┓╻ ╻╺┳╸┏━┓┏━┓╻  ┏━┓")
        print("┃┃┃┣╸  ┃┃┃┣━┫┃  ┃┣┻┓┣┳┛┣━┫┣┳┛┗┳┛ ┃ ┃ ┃┃ ┃┃  ┗━┓")
        print("╹ ╹┗━╸╺┻┛╹╹ ╹┗━╸╹┗━┛╹┗╸╹ ╹╹┗╸ ╹  ╹ ┗━┛┗━┛┗━╸┗━┛")
        print(f"{script_name} v{version}: {description}")
        print()  # Blank line for separation
    except Exception:
        # Banner display errors should not prevent script execution
        pass


def read_global_config_bool(var_name: str, default: bool = False) -> bool:
    """Read a boolean environment variable with support for .env files.
    
    Args:
        var_name: Name of the environment variable
        default: Default value if not found
        
    Returns:
        Boolean value of the environment variable
    """
    # Check environment variable directly
    value = os.environ.get(var_name)
    if value is not None:
        return value.lower() in ('true', '1', 'yes', 'on')
    
    # Check local .env file
    env_file = '.env'
    if os.path.exists(env_file):
        try:
            with open(env_file, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line.startswith(f'{var_name}='):
                        value = line.split('=', 1)[1].strip()
                        return value.lower() in ('true', '1', 'yes', 'on')
        except (IOError, OSError):
            pass
    
    # Check global .env file
    global_env_path = Path.home() / '.media-library-tools' / '.env'
    if global_env_path.exists():
        try:
            with open(global_env_path, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line.startswith(f'{var_name}='):
                        value = line.split('=', 1)[1].strip()
                        return value.lower() in ('true', '1', 'yes', 'on')
        except (IOError, OSError):
            pass
    
    return default


def format_size(size_bytes: int) -> str:
    """Format size in bytes to human readable format.
    
    Args:
        size_bytes: Size in bytes
        
    Returns:
        Human readable size string
    """
    for unit in ['B', 'K', 'M', 'G', 'T']:
        if size_bytes < 1024.0:
            if unit == 'B':
                return f"{size_bytes:.0f}{unit}"
            else:
                return f"{size_bytes:.1f}{unit}"
        size_bytes /= 1024.0
    return f"{size_bytes:.1f}P"


def is_non_interactive() -> bool:
    """Detect if running in non-interactive environment (cron, etc.).
    
    Returns:
        True if non-interactive, False otherwise
    """
    # Check if stdin is not a TTY (common in cron jobs)
    if not sys.stdin.isatty():
        return True
        
    # Check for common non-interactive environment variables
    non_interactive_vars = ['CRON', 'CI', 'AUTOMATED', 'NON_INTERACTIVE']
    for var in non_interactive_vars:
        if os.environ.get(var):
            return True
            
    # Check if TERM is not set or is 'dumb' (common in automated environments)
    term = os.environ.get('TERM', '')
    if not term or term == 'dumb':
        return True
        
    return False


class SeasonOrganizer:
    """Organizes video files into season directories."""
    
    def __init__(self, dry_run: bool = False):
        self.dry_run = dry_run
        self.video_extensions = {
            '.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', 
            '.m4v', '.mpg', '.mpeg', '.3gp', '.ogv', '.ts', '.m2ts'
        }
        
        # Enhanced season detection patterns (ordered by specificity)
        self.season_patterns = [
            # Standard patterns (highest priority)
            re.compile(r'[Ss](\d{1,2})[Ee](\d{1,2})', re.IGNORECASE),
            re.compile(r'Season\s*(\d{1,2})\s*Episode\s*(\d{1,2})', re.IGNORECASE),
            
            # Extended season patterns (high priority) - NEW
            re.compile(r'[Ss](\d{3,4})[Ee](\d{1,3})', re.IGNORECASE),
            re.compile(r'Season\s*(\d{3,4})\s*Episode\s*(\d{1,3})', re.IGNORECASE),
            
            # Enhanced alternative patterns (medium-high priority)
            re.compile(r'(\d{1,3})x(\d{1,3})', re.IGNORECASE),  # Updated range
            
            # Numeric-only patterns (medium priority) - NEW
            re.compile(r'(?:ep|episode)[\s\-_.]*(\d{1,2})(?:[^\d]|$)', re.IGNORECASE),
            re.compile(r'(?:^|[\s\-_.])[^\d]*[\s\-_.](\d{1,2})[\s\-_.](?!\d*(?:p|fps|kbps))', re.IGNORECASE),
            
            # Season-only pattern (existing, updated range)
            re.compile(r'[Ss](\d{1,4})(?![Ee])', re.IGNORECASE),  # Updated range
        ]
    
    def is_video_file(self, file_path: Path) -> bool:
        """Check if file is a video file based on extension."""
        return file_path.suffix.lower() in self.video_extensions
    
    def validate_season_match(self, filename: str, match_text: str, season_num: int, 
                            pattern_index: int) -> Tuple[bool, float]:
        """
        Validate that a season match is valid, preventing false positives.
        
        Args:
            filename: Full filename being analyzed
            match_text: The matched text from regex
            season_num: Extracted season number
            pattern_index: Index of pattern in season_patterns list
        
        Returns:
            Tuple[bool, float]: (is_valid, confidence_score)
        """
        confidence = 0.0
        
        # Quality indicator detection (major false positive source)
        quality_patterns = [
            r'720p', r'1080p', r'480p', r'2160p', r'4K', 
            r'\d+kbps', r'\d+fps', r'HDR', r'DTS', r'AC3',
            r'H\.?264', r'H\.?265', r'x264', r'x265',
            r'HEVC', r'AVC', r'BluRay', r'WEBRip', r'DVDRip'
        ]
        
        filename_lower = filename.lower()
        for pattern in quality_patterns:
            if re.search(pattern, filename_lower, re.IGNORECASE):
                return False, 0.0  # Immediate rejection for quality indicators
        
        # Position validation - avoid numbers at end of filename
        match_pos = filename.find(match_text)
        filename_length = len(filename)
        relative_position = match_pos / filename_length if filename_length > 0 else 0
        
        if relative_position > 0.8:  # Last 20% of filename
            confidence -= 0.5
        elif relative_position < 0.3:  # First 30% of filename
            confidence += 0.3
        
        # Range validation based on pattern type (by index)
        if pattern_index in [0, 1]:  # Standard patterns
            if not (1 <= season_num <= 50):
                return False, 0.0
            confidence += 0.4  # High confidence for standard patterns
        elif pattern_index in [2, 3]:  # Extended season patterns
            if not (100 <= season_num <= 2050):
                return False, 0.0
            confidence += 0.4  # High confidence for extended patterns
        elif pattern_index == 4:  # Enhanced alternative pattern (##x##)
            if not (1 <= season_num <= 500):
                return False, 0.0
            confidence += 0.3
        elif pattern_index in [5, 6]:  # Numeric-only patterns
            if not (1 <= season_num <= 50):
                return False, 0.0
            confidence += 0.2  # Lower confidence, need more validation
        elif pattern_index == 7:  # Season-only pattern
            if season_num >= 100:
                if not (100 <= season_num <= 2050):  # Extended range
                    return False, 0.0
                confidence += 0.3
            else:
                if not (1 <= season_num <= 50):  # Standard range
                    return False, 0.0
                confidence += 0.3
        
        # Context character analysis for numeric patterns
        if pattern_index in [5, 6]:  # Numeric-only patterns need more validation
            context_start = max(0, match_pos - 3)
            context_end = min(filename_length, match_pos + len(match_text) + 3)
            context = filename[context_start:context_end].lower()
            
            # Positive context indicators
            positive_indicators = ['ep', 'episode', 'season', 'series', '-', '_', '.', ' ']
            negative_indicators = ['p', 'fps', 'kbps', 'bit', 'mb', 'gb']
            
            for indicator in positive_indicators:
                if indicator in context:
                    confidence += 0.1
            
            for indicator in negative_indicators:
                if indicator in context:
                    confidence -= 0.2
            
            # Minimum confidence threshold for numeric patterns
            min_confidence = 0.3
        else:
            min_confidence = 0.2
        
        # Final confidence scoring
        confidence = max(0.0, min(1.0, confidence))  # Clamp to [0.0, 1.0]
        
        return confidence >= min_confidence, confidence
    
    def extract_season_episode(self, filename: str) -> Tuple[Optional[int], Optional[int]]:
        """Extract season and episode numbers from filename."""
        for pattern_index, pattern in enumerate(self.season_patterns):
            match = pattern.search(filename)
            if match:
                groups = match.groups()
                try:
                    season = int(groups[0]) if groups[0] else None
                    episode = int(groups[1]) if len(groups) > 1 and groups[1] else None
                    
                    if season is not None:
                        # Validate the match using the validation function
                        matched_text = match.group(0)
                        is_valid, confidence = self.validate_season_match(
                            filename, matched_text, season, pattern_index)
                        
                        if is_valid:
                            return season, episode
                        # If not valid, continue to next pattern
                    
                except (ValueError, IndexError):
                    continue
                    
        return None, None
    
    def generate_unique_filename(self, target_path: Path) -> Path:
        """Generate unique filename if collision exists."""
        if not target_path.exists():
            return target_path
        
        base_name = target_path.stem
        extension = target_path.suffix
        parent = target_path.parent
        counter = 1
        
        while True:
            new_name = f"{base_name}_{counter}{extension}"
            new_path = parent / new_name
            if not new_path.exists():
                return new_path
            counter += 1
    
    def organize_directory(self, show_dir: Path) -> Dict[str, Union[int, List[str]]]:
        """Organize a single TV show directory."""
        stats = {
            'total_files': 0,
            'moved_files': 0,
            'skipped_files': 0,
            'created_seasons': 0,
            'errors': []
        }
        
        if not show_dir.is_dir():
            stats['errors'].append(f"Not a directory: {show_dir}")
            return stats
        
        try:
            # Get all video files in the directory (not in subdirectories)
            video_files = [f for f in show_dir.iterdir() 
                          if f.is_file() and self.is_video_file(f)]
            
            stats['total_files'] = len(video_files)
            
            if not video_files:
                return stats
            
            created_seasons = set()
            
            for video_file in video_files:
                try:
                    season_num, episode_num = self.extract_season_episode(video_file.name)
                    
                    if season_num is None:
                        stats['skipped_files'] += 1
                        if not self.dry_run:
                            print(f"  Skipping (no season pattern): {video_file.name}")
                        continue
                    
                    # Create season directory
                    season_dir_name = f"Season {season_num}"
                    season_dir = show_dir / season_dir_name
                    
                    if not season_dir.exists():
                        if season_dir_name not in created_seasons:
                            if self.dry_run:
                                print(f"  [DRY RUN] Would create: {season_dir_name}")
                            else:
                                season_dir.mkdir(exist_ok=True)
                                print(f"  Created: {season_dir_name}")
                            created_seasons.add(season_dir_name)
                            stats['created_seasons'] += 1
                    
                    # Determine target file path
                    target_file = season_dir / video_file.name
                    
                    # Handle collisions
                    if target_file.exists():
                        original_target = target_file
                        target_file = self.generate_unique_filename(target_file)
                        if not self.dry_run:
                            print(f"  Collision detected: {video_file.name}")
                            print(f"    Renaming to: {target_file.name}")
                    
                    # Move the file
                    if self.dry_run:
                        print(f"  [DRY RUN] Would move: {video_file.name} → {season_dir_name}/{target_file.name}")
                        stats['moved_files'] += 1
                    else:
                        shutil.move(str(video_file), str(target_file))
                        print(f"  Moved: {video_file.name} → {season_dir_name}/{target_file.name}")
                        stats['moved_files'] += 1
                
                except Exception as e:
                    stats['errors'].append(f"Error processing {video_file.name}: {e}")
                    stats['skipped_files'] += 1
        
        except Exception as e:
            stats['errors'].append(f"Error processing directory {show_dir}: {e}")
        
        return stats


class PlexSeasonBatchOrganizer:
    """Main class for batch season organization."""
    
    def __init__(self, dry_run: bool = False, force: bool = False, 
                 max_workers: int = 4, recursive: bool = False):
        self.dry_run = dry_run
        self.force = force
        self.max_workers = max_workers
        self.recursive = recursive
        self.lock_file = None
        self.organizer = SeasonOrganizer(dry_run=dry_run)
    
    def acquire_lock(self) -> bool:
        """Acquire file lock to prevent multiple instances."""
        if self.force:
            return True
            
        try:
            self.lock_file = tempfile.NamedTemporaryFile(
                mode='w',
                prefix='plex_make_all_seasons_',
                suffix='.lock',
                delete=False
            )
            fcntl.flock(self.lock_file.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
            self.lock_file.write(str(os.getpid()))
            self.lock_file.flush()
            return True
        except (IOError, OSError) as e:
            if self.lock_file:
                self.lock_file.close()
                try:
                    os.unlink(self.lock_file.name)
                except OSError:
                    pass
                self.lock_file = None
            print(f"Error: Another instance is already running. Use --force to override.")
            print(f"Lock error: {e}")
            return False
    
    def release_lock(self) -> None:
        """Release the file lock."""
        if self.lock_file:
            try:
                fcntl.flock(self.lock_file.fileno(), fcntl.LOCK_UN)
                self.lock_file.close()
                os.unlink(self.lock_file.name)
            except (IOError, OSError):
                pass
            finally:
                self.lock_file = None
    
    def find_show_directories(self, base_dir: Path) -> List[Path]:
        """Find all show directories to process."""
        show_dirs = []
        
        try:
            if self.recursive:
                # Recursively find directories with video files
                for item in base_dir.rglob('*'):
                    if (item.is_dir() and 
                        any(f.is_file() and self.organizer.is_video_file(f) 
                            for f in item.iterdir())):
                        show_dirs.append(item)
            else:
                # Only immediate subdirectories
                for item in base_dir.iterdir():
                    if item.is_dir():
                        show_dirs.append(item)
        
        except Exception as e:
            print(f"Error scanning directories: {e}")
        
        return sorted(show_dirs)
    
    def process_show_sequential(self, show_dir: Path) -> Tuple[Path, Dict]:
        """Process a single show directory (for sequential processing)."""
        return show_dir, self.organizer.organize_directory(show_dir)
    
    def process_shows_parallel(self, show_dirs: List[Path]) -> List[Tuple[Path, Dict]]:
        """Process multiple show directories in parallel."""
        results = []
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            # Submit all tasks
            future_to_dir = {
                executor.submit(self.organizer.organize_directory, show_dir): show_dir 
                for show_dir in show_dirs
            }
            
            # Collect results as they complete
            for future in concurrent.futures.as_completed(future_to_dir):
                show_dir = future_to_dir[future]
                try:
                    stats = future.result()
                    results.append((show_dir, stats))
                except Exception as e:
                    error_stats = {
                        'total_files': 0, 'moved_files': 0, 'skipped_files': 0,
                        'created_seasons': 0, 'errors': [f"Processing error: {e}"]
                    }
                    results.append((show_dir, error_stats))
        
        return results
    
    def print_summary(self, results: List[Tuple[Path, Dict]]) -> None:
        """Print comprehensive summary of processing results."""
        total_stats = {
            'directories_processed': len(results),
            'total_files': 0,
            'moved_files': 0,
            'skipped_files': 0,
            'created_seasons': 0,
            'directories_with_errors': 0,
            'total_errors': 0
        }
        
        print("\n" + "=" * 60)
        print("PROCESSING SUMMARY")
        print("=" * 60)
        
        for show_dir, stats in results:
            total_stats['total_files'] += stats['total_files']
            total_stats['moved_files'] += stats['moved_files']
            total_stats['skipped_files'] += stats['skipped_files']
            total_stats['created_seasons'] += stats['created_seasons']
            
            if stats['errors']:
                total_stats['directories_with_errors'] += 1
                total_stats['total_errors'] += len(stats['errors'])
                print(f"\n❌ {show_dir.name}:")
                for error in stats['errors']:
                    print(f"   Error: {error}")
            elif stats['moved_files'] > 0:
                print(f"\n✅ {show_dir.name}: {stats['moved_files']} files organized into {stats['created_seasons']} seasons")
            elif stats['total_files'] == 0:
                print(f"\n⚪ {show_dir.name}: No video files found")
            else:
                print(f"\n⚠️  {show_dir.name}: {stats['skipped_files']} files skipped (no season pattern)")
        
        print("\n" + "=" * 60)
        print("OVERALL STATISTICS")
        print("=" * 60)
        print(f"Directories processed: {total_stats['directories_processed']}")
        print(f"Total video files found: {total_stats['total_files']}")
        
        if self.dry_run:
            print(f"Files that would be moved: {total_stats['moved_files']}")
            print(f"Seasons that would be created: {total_stats['created_seasons']}")
        else:
            print(f"Files successfully moved: {total_stats['moved_files']}")
            print(f"Season directories created: {total_stats['created_seasons']}")
        
        print(f"Files skipped: {total_stats['skipped_files']}")
        print(f"Directories with errors: {total_stats['directories_with_errors']}")
        print(f"Total errors: {total_stats['total_errors']}")
        
        if total_stats['total_errors'] == 0:
            print("\n🎉 Processing completed successfully!")
        else:
            print("\n⚠️  Processing completed with errors. See details above.")
    
    def handle_confirmation(self, skip_confirmation: bool) -> bool:
        """Handle user confirmation for the operation."""
        # Confirmation prompt for non-dry-run operations
        if not self.dry_run and not skip_confirmation and not is_non_interactive():
            print("\nThis will organize video files into season directories.")
            print("Files will be moved to create proper Plex library structure.")
            try:
                response = input("\nDo you want to proceed? (yes/no): ").strip().lower()
                if response not in ['yes', 'y']:
                    print("Operation cancelled.")
                    return False
            except (EOFError, KeyboardInterrupt):
                print("\nOperation cancelled.")
                return False
        elif not self.dry_run and (skip_confirmation or is_non_interactive()):
            if skip_confirmation:
                print("Proceeding with season organization (--yes flag)...")
            else:
                print("Proceeding with season organization (non-interactive environment)...")
        
        return True

    def process_directories(self, show_dirs: List[Path]) -> List[Tuple[Path, Dict]]:
        """Process the directories either sequentially or in parallel."""
        start_time = time.time()
        
        if self.max_workers == 1:
            # Sequential processing
            results = []
            for i, show_dir in enumerate(show_dirs, 1):
                print(f"[{i}/{len(show_dirs)}] Processing: {show_dir.name}")
                result = self.process_show_sequential(show_dir)
                results.append(result)
        else:
            # Parallel processing
            print(f"Processing {len(show_dirs)} directories in parallel...")
            results = self.process_shows_parallel(show_dirs)
        
        end_time = time.time()
        processing_time = end_time - start_time
        
        # Print summary
        self.print_summary(results)
        print(f"\nProcessing time: {processing_time:.2f} seconds")
        
        return results

    def process_directory(self, base_dir: Path, skip_confirmation: bool = False) -> bool:
        """Process all show directories in the base directory."""
        if not base_dir.exists():
            print(f"Error: Directory '{base_dir}' does not exist.")
            return False
        
        if not base_dir.is_dir():
            print(f"Error: '{base_dir}' is not a directory.")
            return False
        
        print(f"Processing TV shows in: {base_dir}")
        if self.recursive:
            print("RECURSIVE MODE - Processing all subdirectories")
        print(f"Using {self.max_workers} worker threads")
        print()
        
        # Handle confirmation
        if not self.handle_confirmation(skip_confirmation):
            return False
        
        # Find all show directories
        show_dirs = self.find_show_directories(base_dir)
        
        if not show_dirs:
            print("No directories found to process.")
            return True
        
        print(f"Found {len(show_dirs)} directories to process:")
        for show_dir in show_dirs:
            print(f"  - {show_dir.name}")
        print()
        
        # Process directories
        self.process_directories(show_dirs)
        
        return True


def main():
    """Main function with argument parsing and execution."""
    parser = argparse.ArgumentParser(
        description="Plex Season Organizer (Batch) - Organize TV show episodes into season directories",
        epilog="""
Examples:
  %(prog)s /path/to/tv/shows                    # Preview changes (dry-run mode)
  %(prog)s /path/to/tv/shows --execute          # Actually organize files
  %(prog)s /path/to/tv/shows --execute -y       # Execute without confirmation
  %(prog)s /path/to/tv/shows --parallel 8       # Use 8 worker threads
  %(prog)s /path/to/tv/shows --recursive        # Process all subdirectories
  %(prog)s /path/to/tv/shows --verbose          # Show verbose output
  %(prog)s /path/to/tv/shows --debug            # Show debug output
  %(prog)s /path/to/tv/shows --force            # Force run (bypass lock)
  
Cron Usage:
  # Run daily at 3 AM (non-interactive)
  0 3 * * * /usr/local/bin/plex_make_all_seasons /path/to/tv/shows --execute -y
        """,
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument(
        'directory',
        nargs='?',
        default='.',
        help='Base directory containing TV show directories (default: current directory)'
    )
    parser.add_argument(
        '--dry-run',
        action='store_true',
        default=True,
        help='Show what would be done without making changes (default: true)'
    )
    parser.add_argument(
        '--execute',
        action='store_true',
        help='Actually perform operations (overrides --dry-run)'
    )
    parser.add_argument(
        '-y', '--yes',
        action='store_true',
        help='Skip confirmation prompt (for non-interactive use)'
    )
    parser.add_argument(
        '--verbose',
        action='store_true',
        help='Show verbose output'
    )
    parser.add_argument(
        '--debug',
        action='store_true',
        help='Show detailed debug output'
    )
    parser.add_argument(
        '--force',
        action='store_true',
        help='Force execution even if another instance is running'
    )
    parser.add_argument(
        '--parallel', '--workers',
        type=int,
        default=4,
        metavar='N',
        help='Number of worker threads for parallel processing (default: 4, use 1 for sequential)'
    )
    parser.add_argument(
        '--recursive',
        action='store_true',
        help='Recursively process all subdirectories (not just immediate children)'
    )
    parser.add_argument(
        '--no-banner',
        action='store_true',
        help='Suppress banner display'
    )
    parser.add_argument(
        '--version',
        action='version',
        version='%(prog)s 2.1.0'
    )
    
    args = parser.parse_args()
    
    # Handle debug mode (enables verbose)
    if args.debug:
        args.verbose = True
    
    # Read global configuration
    auto_execute = read_global_config_bool('AUTO_EXECUTE', False)
    auto_confirm = read_global_config_bool('AUTO_CONFIRM', False)
    quiet_mode = read_global_config_bool('QUIET_MODE', False)
    
    # Apply global configuration (CLI arguments take precedence)
    if auto_execute and not args.execute:
        args.execute = True  # Set execute flag if AUTO_EXECUTE is set
    if auto_confirm and not args.yes:
        args.yes = True  # Set yes flag if AUTO_CONFIRM is set
    
    # Determine dry-run mode
    if args.execute:
        dry_run_mode = False
    else:
        dry_run_mode = args.dry_run  # This is True by default
    
    # Validate arguments
    if args.parallel < 1:
        print("Error: Number of workers must be at least 1")
        sys.exit(1)
    
    if args.yes and dry_run_mode:
        print("Warning: -y/--yes flag has no effect in dry-run mode", file=sys.stderr)
    
    # Display banner
    display_banner("plex_make_all_seasons", "2.1.0", 
                  "create season directories for TV shows with parallel processing support",
                  args.no_banner, quiet_mode)
    
    if dry_run_mode:
        print("DRY-RUN MODE: No changes will be made")
    else:
        print("EXECUTE MODE: Episodes will be organized")
    
    if args.debug:
        print("Debug: ENABLED")
    elif args.verbose:
        print("Verbose: ENABLED")
    print()
    
    # Create organizer instance
    organizer = PlexSeasonBatchOrganizer(
        dry_run=dry_run_mode,
        force=args.force,
        max_workers=args.parallel,
        recursive=args.recursive
    )
    
    try:
        # Acquire lock
        if not organizer.acquire_lock():
            sys.exit(1)
        
        # Process directory
        base_dir = Path(args.directory).resolve()
        success = organizer.process_directory(base_dir, skip_confirmation=args.yes)
        
        sys.exit(0 if success else 1)
        
    except KeyboardInterrupt:
        print("\nOperation cancelled by user.")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)
    finally:
        organizer.release_lock()


if __name__ == '__main__':
    main()