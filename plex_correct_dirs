#!/usr/bin/env python3
"""
Plex Directory Name Corrector

A comprehensive tool for sanitizing and organizing Plex media directory names.
This script processes directory names to ensure they follow Plex naming conventions
by removing unwanted tags, standardizing formats, and organizing files into directories.

Features:
- Enhanced regex patterns for comprehensive tag removal
- Standardizes resolution and year formats
- Converts files to directory structure
- File-based locking mechanism
- Dry-run mode for safe testing
- Cron-friendly operation

Author: Media Library Tools Project
Version: 2.0.0
"""

import argparse
import os
import re
import shutil
import sys
from pathlib import Path
from typing import List, Optional, Tuple

VERSION = "2.1.0"

# ======================================================


# ======================================================
# INJECTED MODULE - START
# Generated by build.py v3.0.0
# Source: lib/core.py
# ======================================================

"""
Core Utilities Module for Media Library Tools
Version: 1.0

This module contains essential utility functions including:
- Platform detection and environment handling
- Configuration management and global settings
- File locking mechanisms for concurrent execution
- Interactive mode detection for automation support

This is part of the modular library structure that enables selective inclusion
in built tools while maintaining the self-contained principle.
"""

import contextlib
import os
import platform
import sys
import tempfile
from pathlib import Path
from typing import Optional, Tuple

# Platform-specific imports
try:
    import fcntl  # Unix/Linux/macOS
except ImportError:
    fcntl = None  # Windows

try:
    import msvcrt  # Windows
except ImportError:
    msvcrt = None  # Unix/Linux/macOS


def is_non_interactive() -> bool:
    """
    Detect if running in non-interactive environment (cron, etc.).

    Returns:
        True if non-interactive, False otherwise
    """
    # Check if stdin is not a TTY (common in cron jobs)
    if not sys.stdin.isatty():
        return True

    # Check for common non-interactive environment variables
    non_interactive_vars = ["CRON", "CI", "AUTOMATED", "NON_INTERACTIVE"]
    for var in non_interactive_vars:
        if os.environ.get(var):
            return True

    # Check if TERM is not set or is 'dumb' (common in automated environments)
    term = os.environ.get("TERM", "")
    return bool(not term or term == "dumb")


def read_global_config_bool(var_name: str, default: bool = False) -> bool:
    """
    Read a boolean environment variable with support for .env files.

    Args:
        var_name: Name of the environment variable
        default: Default value if not found

    Returns:
        Boolean value of the environment variable
    """
    # Check environment variable directly
    value = os.environ.get(var_name)
    if value is not None:
        return value.lower() in ("true", "1", "yes", "on")

    # Check local .env file
    env_file = ".env"
    if os.path.exists(env_file):
        try:
            with open(env_file) as f:
                for line in f:
                    line = line.strip()
                    if line.startswith(f"{var_name}="):
                        value = line.split("=", 1)[1].strip()
                        return value.lower() in ("true", "1", "yes", "on")
        except OSError:
            pass

    # Check global .env file
    global_env_path = Path.home() / ".media-library-tools" / ".env"
    if global_env_path.exists():
        try:
            with open(global_env_path) as f:
                for line in f:
                    line = line.strip()
                    if line.startswith(f"{var_name}="):
                        value = line.split("=", 1)[1].strip()
                        return value.lower() in ("true", "1", "yes", "on")
        except OSError:
            pass

    return default


def is_windows() -> bool:
    """
    Detect if running on Windows platform.

    Returns:
        True if running on Windows, False otherwise
    """
    return platform.system().lower() == "windows"


def should_use_emojis() -> bool:
    """
    Determine if emojis should be used based on platform and environment.

    Returns:
        True if emojis should be used, False otherwise
    """
    # Don't use emojis on Windows to avoid encoding issues
    if is_windows():
        return False

    # Don't use emojis in non-interactive environments
    if is_non_interactive():
        return False

    # Check for explicit emoji suppression
    return not read_global_config_bool("NO_EMOJIS", False)


class FileLock:
    """
    File locking utility class for preventing concurrent executions.
    """

    def __init__(self, lock_prefix: str = "media_library_tool"):
        """
        Initialize file lock.

        Args:
            lock_prefix: Prefix for lock file name
        """
        self.lock_prefix = lock_prefix
        self.lock_file = None

    def acquire_lock(self, force: bool = False) -> bool:
        """
        Acquire file lock to prevent multiple instances.

        Args:
            force: If True, skip locking mechanism

        Returns:
            True if lock acquired successfully, False otherwise
        """
        if force:
            return True

        try:
            with tempfile.NamedTemporaryFile(
                mode="w", prefix=f"{self.lock_prefix}_", suffix=".lock", delete=False
            ) as temp_file:
                self.lock_file = temp_file
                
                # Platform-specific file locking
                if fcntl is not None:  # Unix/Linux/macOS
                    fcntl.flock(self.lock_file.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
                elif msvcrt is not None:  # Windows
                    msvcrt.locking(self.lock_file.fileno(), msvcrt.LK_NBLCK, 1)
                else:
                    # Fallback: no locking available, just proceed
                    pass
                    
                self.lock_file.write(str(os.getpid()))
                self.lock_file.flush()
            return True
        except (OSError, IOError) as e:
            if self.lock_file:
                self.lock_file.close()
                with contextlib.suppress(OSError):
                    os.unlink(self.lock_file.name)
                self.lock_file = None
            print(
                "Error: Another instance is already running. Use --force to override."
            )
            print(f"Lock error: {e}")
            return False

    def release_lock(self) -> None:
        """
        Release the file lock.
        """
        if self.lock_file:
            try:
                # Only unlock if file is still open
                if not self.lock_file.closed:
                    # Platform-specific file unlocking
                    if fcntl is not None:  # Unix/Linux/macOS
                        fcntl.flock(self.lock_file.fileno(), fcntl.LOCK_UN)
                    elif msvcrt is not None:  # Windows
                        msvcrt.locking(self.lock_file.fileno(), msvcrt.LK_UNLCK, 1)
                    # No explicit unlock needed for fallback case
                    
                    self.lock_file.close()
            except (OSError, ValueError, IOError):
                # Handle both file system errors and closed file errors
                pass

            # Always try to remove lock file if it exists
            try:
                if os.path.exists(self.lock_file.name):
                    os.unlink(self.lock_file.name)
            except OSError:
                pass
            finally:
                self.lock_file = None


# Legacy standalone functions for backward compatibility
def acquire_lock(
    lock_prefix: str = "media_library_tool", force: bool = False
) -> Tuple[bool, Optional[FileLock]]:
    """
    Legacy function for acquiring file locks.

    Args:
        lock_prefix: Prefix for lock file name
        force: If True, skip locking mechanism

    Returns:
        Tuple of (success: bool, lock_instance: FileLock or None)
    """
    lock = FileLock(lock_prefix)
    success = lock.acquire_lock(force)
    return success, lock if success else None


def release_lock(lock_instance: FileLock) -> None:
    """
    Legacy function for releasing file locks.

    Args:
        lock_instance: FileLock instance to release
    """
    if lock_instance:
        lock_instance.release_lock()

# ======================================================
# INJECTED MODULE - END
# Source: lib/core.py
# ======================================================


# ======================================================
# INJECTED MODULE - START
# Generated by build.py v3.0.0
# Source: lib/ui.py
# ======================================================

"""
User Interface Module for Media Library Tools
Version: 1.0

This module contains user interface functions including:
- Banner display and application branding
- Size formatting for human-readable output  
- User confirmation prompts

This is part of the modular library structure that enables selective inclusion
in built tools while maintaining the self-contained principle.
"""

import sys
from pathlib import Path

# Import dependencies from core module
try:
    from core import is_non_interactive, should_use_emojis
except ImportError:
    # Fallback for when core module is not available
    # This happens when modules are injected together during build
    def is_non_interactive():
        """Fallback implementation - will be overridden by injected core module"""
        return not sys.stdin.isatty()
    
    def should_use_emojis():
        """Fallback implementation - will be overridden by injected core module"""
        return sys.platform != "win32" and not is_non_interactive()


def display_banner(
    script_name: str,
    version: str,
    description: str,
    no_banner_flag: bool = False,
    quiet_mode: bool = False,
) -> None:
    """
    Display standardized banner for media library tools.

    Args:
        script_name: Name of the script
        version: Version string
        description: Brief description of the script
        no_banner_flag: If True, suppress banner display
        quiet_mode: If True, suppress banner display
    """
    # Check suppression conditions (highest to lowest priority)
    if no_banner_flag or quiet_mode or is_non_interactive():
        return

    try:
        # Display standardized ASCII art
        print("┏┳┓┏━╸╺┳┓╻┏━┓╻  ╻┏┓ ┏━┓┏━┓┏━┓╻ ╻╺┳╸┏━┓┏━┓╻  ┏━┓")
        print("┃┃┃┣╸  ┃┃┃┣━┫┃  ┃┣┻┓┣┳┛┣━┫┣┳┛┗┳┛ ┃ ┃ ┃┃ ┃┃  ┗━┓")
        print("╹ ╹┗━╸╺┻┛╹╹ ╹┗━╸╹┗━┛╹┗╸╹ ╹╹┗╸ ╹  ╹ ┗━┛┗━┛┗━╸┗━┛")
        print(f"{script_name} v{version}: {description}")
        print()  # Blank line for separation
    except Exception:
        # Banner display errors should not prevent script execution
        pass


def format_size(size_bytes: int) -> str:
    """
    Format size in bytes to human readable format.

    Args:
        size_bytes: Size in bytes

    Returns:
        Human readable size string
    """
    for unit in ["B", "K", "M", "G", "T"]:
        if size_bytes < 1024.0:
            if unit == "B":
                return f"{size_bytes:.0f}{unit}"
            else:
                return f"{size_bytes:.1f}{unit}"
        size_bytes /= 1024.0
    return f"{size_bytes:.1f}P"


def confirm_action(message: str, skip_confirmation: bool = False) -> bool:
    """
    Ask for user confirmation unless skipped.

    Args:
        message: Confirmation message to display
        skip_confirmation: If True, automatically confirm

    Returns:
        True if confirmed, False otherwise
    """
    if skip_confirmation:
        return True

    try:
        response = input(f"{message} (y/N): ").strip().lower()
        return response in ["y", "yes"]
    except (EOFError, KeyboardInterrupt):
        print("\nOperation cancelled.")
        return False


def format_status_message(
    message: str, emoji: str = "", fallback_prefix: str = ""
) -> str:
    """
    Format a status message with optional emoji or fallback prefix.

    Args:
        message: The message to format
        emoji: Emoji to use if emojis are supported
        fallback_prefix: Text prefix to use if emojis are not supported

    Returns:
        Formatted message string
    """
    if emoji and should_use_emojis():
        return f"{emoji} {message}"
    elif fallback_prefix:
        return f"{fallback_prefix}: {message}"
    else:
        return message


def display_item_list(items, title: str = None, numbered: bool = False, 
                     show_count: bool = True, indent: str = "  ") -> None:
    """
    Display a list of items with consistent formatting.
    
    Args:
        items: List of items to display (strings or objects with __str__)
        title: Optional title to display above the list
        numbered: Whether to number the items (default: False for bullet points)
        show_count: Whether to show total count in title (default: True)
        indent: Indentation string for list items (default: "  ")
    
    Example:
        display_item_list(['file1.mp4', 'file2.mkv'], 'Files to process', numbered=True)
        # Output:
        # Files to process (2):
        #   1. file1.mp4
        #   2. file2.mkv
    """
    if not items:
        if title:
            print(f"{title}: None found")
        return
    
    # Display title with optional count
    if title:
        count_text = f" ({len(items)})" if show_count else ""
        print(f"{title}{count_text}:")
    
    # Display items
    for i, item in enumerate(items, 1):
        if numbered:
            print(f"{indent}{i}. {item}")
        else:
            print(f"{indent}- {item}")


def display_summary_list(summary_data: dict, title: str = None) -> None:
    """
    Display a summary with categorized counts and totals.
    
    Args:
        summary_data: Dictionary with category names as keys and counts as values
        title: Optional title to display above the summary
    
    Example:
        display_summary_list({
            'Files processed': 15,
            'Files skipped': 3,
            'Errors encountered': 1
        }, 'Processing Summary')
        # Output:
        # Processing Summary:
        #   Files processed: 15
        #   Files skipped: 3
        #   Errors encountered: 1
    """
    if title:
        print(f"{title}:")
    
    # Find the longest key for alignment
    max_key_length = max(len(str(key)) for key in summary_data.keys()) if summary_data else 0
    
    for key, value in summary_data.items():
        print(f"  {str(key).ljust(max_key_length)}: {value}")


def display_progress_item(current: int, total: int, item_name: str, 
                         prefix: str = "Processing") -> None:
    """
    Display current progress for an item being processed.
    
    Args:
        current: Current item number (1-based)
        total: Total number of items
        item_name: Name of the current item being processed
        prefix: Prefix text (default: "Processing")
    
    Example:
        display_progress_item(3, 10, 'movie.mp4')
        # Output: [3/10] Processing: movie.mp4
    """
    print(f"[{current}/{total}] {prefix}: {item_name}")


def display_stats_table(stats: dict, title: str = None, 
                       value_formatter=None) -> None:
    """
    Display statistics in a formatted table with aligned columns.
    
    Args:
        stats: Dictionary with statistic names as keys and values
        title: Optional title to display above the table
        value_formatter: Optional function to format values (e.g., format_size for bytes)
    
    Example:
        display_stats_table({
            'Total files': 1250,
            'Total size': 15728640,
            'Average size': 12582
        }, 'File Statistics', format_size)
    """
    if not stats:
        return
    
    if title:
        print(f"\n{title}:")
    
    # Find the longest key for alignment
    max_key_length = max(len(str(key)) for key in stats.keys())
    
    for key, value in stats.items():
        formatted_value = value_formatter(value) if value_formatter else str(value)
        print(f"  {str(key).ljust(max_key_length)}: {formatted_value}")


def display_results_table(data: list, headers: list, title: str = None,
                         max_width: int = 80) -> None:
    """
    Display structured data in a formatted table with headers and proper alignment.
    
    Args:
        data: List of lists/tuples containing row data
        headers: List of column headers
        title: Optional title to display above the table
        max_width: Maximum width for the table (default: 80)
    
    Example:
        display_results_table([
            ['file1.mp4', '1.2 GB', 'Processed'],
            ['file2.mkv', '850 MB', 'Skipped']
        ], ['Filename', 'Size', 'Status'], 'Processing Results')
    """
    if not data or not headers:
        if title:
            print(f"{title}: No data to display")
        return
    
    if title:
        print(f"\n{title}:")
    
    # Calculate column widths
    col_widths = []
    for i, header in enumerate(headers):
        # Start with header width
        max_width_col = len(header)
        
        # Check data column widths
        for row in data:
            if i < len(row):
                max_width_col = max(max_width_col, len(str(row[i])))
        
        col_widths.append(min(max_width_col, max_width // len(headers)))
    
    # Print header
    header_row = "  " + " | ".join(header.ljust(col_widths[i]) for i, header in enumerate(headers))
    print(header_row)
    print("  " + "-" * (len(header_row) - 2))
    
    # Print data rows
    for row in data:
        formatted_row = []
        for i, cell in enumerate(row):
            if i < len(col_widths):
                cell_str = str(cell)
                if len(cell_str) > col_widths[i]:
                    cell_str = cell_str[:col_widths[i]-3] + "..."
                formatted_row.append(cell_str.ljust(col_widths[i]))
        
        print("  " + " | ".join(formatted_row))

# ======================================================
# INJECTED MODULE - END
# Source: lib/ui.py
# ======================================================


# ======================================================
# Modular includes will be injected here by build.py

# ======================================================

# Source: lib/ui.py
# ======================================================


# ======================================================


class PlexDirectoryCorrector:
    """Main class for correcting Plex directory names."""

    def __init__(self, dry_run: bool = False, force: bool = False, max_items: int = 5,
                 verbose: bool = False, debug: bool = False):
        self.dry_run = dry_run
        self.force = force
        self.max_items = max_items if dry_run else float('inf')
        self.verbose = verbose
        self.debug = debug
        self.processed_count = 0
        self.file_lock = FileLock('plex_correct_dirs')

        # Enhanced regex patterns for comprehensive tag removal
        self.patterns = {
            # Resolution patterns - enclose in brackets
            'resolution': re.compile(r'(?<!\[)(\b\d{3,4}p\b)(?=(\W|$))', re.IGNORECASE),

            # Year patterns - enclose in parentheses
            'year': re.compile(r'(?<!\()(\b(19|20)\d{2}\b)(?!\))', re.IGNORECASE),

            # 4K to 2160p conversion
            'four_k': re.compile(r'\[4k\]', re.IGNORECASE),

            # Release group tags
            'release_groups': re.compile(
                r'\[(YTS\.[A-Z]{2,3}|RARBG|YIFY|FGT|ION10|STUTTERSHIT|RMTEAM|PSA|KOGi|'
                r'SPARKS|DEFLATE|BLOW|Scene|CMRG|EVO|FXG|MiGHTY|QOQ|SiNNERS|UTR|'
                r'YAWNiNG|SAMPA|ION265|BONSAI|YTS|MeGusta|LAMA|SUBSCRiBE|RAWR|NOW|'
                r'ETRG|AMIABLE|GALAXY|GECKOS|HONE|KILLERS|ROVERS|SWTYBLZ|TGx|'
                r'TORRENTGALAXY|VARYG|YIFY|ZMNT)\]', re.IGNORECASE
            ),

            # Video source/quality tags
            'video_quality': re.compile(
                r'\[(BluRay|BDRip|WEBRip|DVDRip|BRRip|HDRip|WEB-DL|WEB|HDTV|CAM|TS|'
                r'TC|SCR|R5|DVDScr|HDCAM|HDTS|WORKPRINT|TELECINE|TELESYNC|'
                r'SCREENER|DVDSCREENER|BDRIP|BRRIP|HDRIP|WEBRIP|WEBDL)\]', re.IGNORECASE
            ),

            # Audio format tags
            'audio_format': re.compile(
                r'\[(5\.1|7\.1|2\.0|AC3|AAC|DTS|DOLBY|Atmos|DTS-HD|AAC2\.0|'
                r'DD5\.1|DD7\.1|TrueHD|FLAC|MP3|OGG|PCM|LPCM)\]', re.IGNORECASE
            ),

            # Codec tags
            'codec': re.compile(
                r'\[(H\.264|H\.265|x264|x265|HEVC|AVC|XviD|DivX|VP9|AV1|'
                r'MPEG2|MPEG4)\]', re.IGNORECASE
            ),

            # HDR and enhancement tags
            'enhancement': re.compile(
                r'\[(HDR|HDR10|HDR10\+|DV|DOLBY.VISION|IMAX|REMASTERED|UNRATED|'
                r'DC|EXTENDED|DIRECTOR.S.CUT|THEATRICAL|ULTIMATE|SPECIAL.EDITION|'
                r'CRITERION|ANNIVERSARY)\]', re.IGNORECASE
            ),

            # Streaming service tags
            'streaming': re.compile(
                r'\[(AMZN|NFLX|HULU|DSNP|ATVP|HMAX|PCOK|PMTP|STAN|CRAV|'
                r'AMAZON|NETFLIX|DISNEY|APPLE|HBO|PEACOCK|PARAMOUNT)\]', re.IGNORECASE
            ),

            # Technical tags
            'technical': re.compile(
                r'\[(10bit|8bit|12bit|HDR|WEB|INTERNAL|PROPER|REPACK|READ\.NFO|'
                r'RERiP|SUBBED|DUBBED|MULTI|DUAL|REMUX|HYBRID)\]', re.IGNORECASE
            ),

            # Dots to spaces
            'dots': re.compile(r'\.'),

            # Duplicate resolution tags
            'duplicate_resolution': re.compile(r'\[2160p\]\s*\[2160p\]'),

            # Empty brackets
            'empty_brackets': re.compile(r'\[\s*\]'),

            # Multiple spaces
            'multiple_spaces': re.compile(r'[ \t]+'),

            # Leading/trailing whitespace and punctuation
            'trim': re.compile(r'^[\s\.\-_]+|[\s\.\-_]+$')
        }

    def log_verbose(self, msg: str):
        """Log verbose message."""
        if self.verbose or self.debug:
            print(f"[VERBOSE] {msg}", file=sys.stderr)

    def log_debug(self, msg: str):
        """Log debug message."""
        if self.debug:
            print(f"[DEBUG] {msg}", file=sys.stderr)

    def acquire_lock(self) -> bool:
        """Acquire file lock to prevent multiple instances."""
        return self.file_lock.acquire_lock(self.force)

    def release_lock(self) -> None:
        """Release the file lock."""
        self.file_lock.release_lock()

    def sanitize_name(self, name: str) -> str:
        """Sanitize directory name using enhanced regex patterns."""
        result = name

        # Step 1: Enclose resolutions in brackets
        result = self.patterns['resolution'].sub(r'[\1]', result)

        # Step 2: Enclose years in parentheses
        result = self.patterns['year'].sub(r'(\1)', result)

        # Step 3: Convert [4K] to [2160p]
        result = self.patterns['four_k'].sub('[2160p]', result)

        # Step 4: Remove unwanted tags (before dot replacement)
        for pattern_name in ['release_groups', 'video_quality', 'audio_format',
                           'codec', 'enhancement', 'streaming', 'technical']:
            result = self.patterns[pattern_name].sub('', result)

        # Step 5: Replace dots with spaces
        result = self.patterns['dots'].sub(' ', result)

        # Step 6: Remove duplicate resolution tags
        result = self.patterns['duplicate_resolution'].sub('[2160p]', result)

        # Step 7: Remove remaining unwanted terms after resolution/year
        # Split on resolution or year markers and clean suffix
        match = re.search(r'(.*(?:\(\d{4}\)|\[\d{3,4}p\]))(.*)', result, re.DOTALL)
        if match:
            prefix, suffix = match.groups()
            # Remove remaining unwanted terms from suffix
            suffix = re.sub(
                r'(AMZN|NFLX|HULU|DSNP|ATVP|HMAX|PCOK|PMTP|STAN|10bit|8bit|HDR|'
                r'WEB|INTERNAL|PROPER|REPACK|READ\.NFO|RERiP)', '', suffix, flags=re.IGNORECASE
            )
            suffix = re.sub(r'^[\s\.\-_]+|[\s\.\-_]+$', '', suffix)
            result = prefix + suffix

        # Step 8: Remove empty brackets
        result = self.patterns['empty_brackets'].sub('', result)

        # Step 9: Final cleanup
        result = self.patterns['multiple_spaces'].sub(' ', result)
        result = self.patterns['trim'].sub('', result)

        return result

    def process_entry(self, entry_path: Path) -> Tuple[bool, str]:
        """Process a single file or directory entry."""
        if self.processed_count >= self.max_items:
            return False, "Dry-run limit reached"

        original_path = entry_path

        # If it's a file, create directory and move file into it
        if entry_path.is_file():
            base_name = entry_path.stem  # filename without extension
            new_dir = entry_path.parent / base_name

            if self.dry_run:
                print(f"Would create directory '{new_dir}' and move file '{entry_path}' into it.")
            else:
                new_dir.mkdir(exist_ok=True)
                shutil.move(str(entry_path), str(new_dir / entry_path.name))
                print(f"Created directory '{new_dir}' and moved file '{entry_path}' into it.")

            entry_path = new_dir  # Update to process the new directory

        # Process directory renaming
        if entry_path.is_dir():
            base_name = entry_path.name
            sanitized_name = self.sanitize_name(base_name)
            sanitized_path = entry_path.parent / sanitized_name

            if base_name == sanitized_name:
                print(f"No renaming needed for '{entry_path}'.")
            elif sanitized_path.exists():
                print(format_status_message(f"A directory with the sanitized name '{sanitized_name}' already exists. Skipping '{entry_path}'", "❌", "Error"))
            else:
                if self.dry_run:
                    print(f"Would rename directory '{entry_path}' to '{sanitized_name}'")
                else:
                    entry_path.rename(sanitized_path)
                    print(f"Renamed directory '{entry_path}' to '{sanitized_name}'")

        self.processed_count += 1
        return True, "Success"

    def process_directory(self, input_dir: Path) -> bool:
        """Process all entries in the specified directory."""
        if not input_dir.exists():
            print(format_status_message(f"Directory '{input_dir}' does not exist", "❌", "Error"))
            return False

        if not input_dir.is_dir():
            print(f"Error: '{input_dir}' is not a directory.")
            return False

        print(f"Processing directory: {input_dir}")
        if self.dry_run:
            print(f"DRY-RUN MODE - Limited to {self.max_items} items")
        print()

        # Get immediate child entries (files and directories)
        entries = list(input_dir.iterdir())

        for entry in entries:
            success, message = self.process_entry(entry)
            if not success and "limit reached" in message:
                print(f"Dry-run limit of {self.max_items} items reached. Exiting.")
                break

        print(f"\nProcessed {self.processed_count} items.")
        return True


def main():
    """Main function with argument parsing and execution."""
    parser = argparse.ArgumentParser(
        description="Plex Directory Name Corrector - Sanitize and organize Plex media directory names",
        epilog="""
Examples:
  %(prog)s                                   # Process current directory (interactive)
  %(prog)s /path/to/media                    # Process specific directory (interactive)
  %(prog)s --dry-run                         # Preview changes in current directory
  %(prog)s /path/to/media --dry-run          # Preview changes in specific directory
  %(prog)s -y                                # Process current directory without confirmation
  %(prog)s /path/to/media -y                 # Process specific directory without confirmation
  %(prog)s --force                           # Force run in current directory (bypass lock)
  %(prog)s --verbose                         # Show verbose output
  %(prog)s --debug                           # Show detailed debug output

Global Configuration:
  Set AUTO_CONFIRM=true to skip confirmation prompts automatically
  Set QUIET_MODE=true to suppress banner display

Cron Usage:
  # Run daily at 2 AM (non-interactive)
  0 2 * * * /usr/local/bin/plex_correct_dirs /path/to/media -y
        """,
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    parser.add_argument(
        'directory',
        nargs='?',
        default='.',
        help='Directory to process (default: current directory)'
    )
    parser.add_argument(
        '--dry-run',
        action='store_true',
        default=True,
        help='Show what would be done without making changes (limited to 5 items)'
    )
    parser.add_argument(
        '--execute',
        action='store_true',
        help='Actually perform the directory corrections (overrides --dry-run)'
    )
    parser.add_argument(
        '-y', '--yes',
        action='store_true',
        help='Skip confirmation prompt (for non-interactive use)'
    )
    parser.add_argument(
        '--force',
        action='store_true',
        help='Force execution even if another instance is running'
    )
    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        help='Show verbose output'
    )
    parser.add_argument(
        '--debug',
        action='store_true',
        help='Show detailed debug output'
    )
    parser.add_argument(
        '--no-banner',
        action='store_true',
        help='Suppress banner display'
    )
    parser.add_argument(
        '--max-items',
        type=int,
        default=5,
        help='Maximum items to process in dry-run mode (default: 5)'
    )
    parser.add_argument(
        '--version',
        action='version',
        version=f'%(prog)s v{VERSION}'
    )

    args = parser.parse_args()

    # Handle execute flag (overrides dry-run default)
    if args.execute:
        args.dry_run = False

    # Handle debug mode
    if args.debug:
        args.verbose = True

    # Read global configuration
    auto_execute = read_global_config_bool('AUTO_EXECUTE', False)
    auto_confirm = read_global_config_bool('AUTO_CONFIRM', False)
    quiet_mode = read_global_config_bool('QUIET_MODE', False)

    # Apply global configuration (CLI arguments take precedence)
    if auto_confirm and not args.yes:
        args.yes = True  # Set yes flag if AUTO_CONFIRM is set

    # Display banner (respecting suppression flags)
    display_banner(
        "Plex Directory Name Corrector",
        "2.1.0",
        "Sanitize and organize Plex media directory names",
        args.no_banner,
        quiet_mode
    )

    # Validate arguments
    if args.yes and args.dry_run:
        print("Warning: -y/--yes flag has no effect in dry-run mode", file=sys.stderr)

    # Create corrector instance
    corrector = PlexDirectoryCorrector(
        dry_run=args.dry_run,
        force=args.force,
        max_items=args.max_items,
        verbose=args.verbose,
        debug=args.debug
    )

    try:
        # Acquire lock
        if not corrector.acquire_lock():
            sys.exit(1)

        # Get confirmation for non-dry-run operations
        if not args.dry_run and not args.yes and not is_non_interactive():
            print("\nThis will modify directory names and file locations.")
            print("Consider running with --dry-run first to preview changes.")
            try:
                response = input("\nDo you want to proceed? (yes/no): ").strip().lower()
            except (EOFError, KeyboardInterrupt):
                print(format_status_message("Operation cancelled", "❌", "Error"))
                sys.exit(0)

            if response not in ['yes', 'y']:
                print("Operation cancelled.")
                sys.exit(0)
        elif not args.dry_run and (args.yes or is_non_interactive()):
            if args.yes:
                print("Proceeding with directory processing (--yes flag)...")
            else:
                print("Proceeding with directory processing (non-interactive environment)...")

        # Process directory
        input_dir = Path(args.directory).resolve()
        success = corrector.process_directory(input_dir)

        sys.exit(0 if success else 1)

    except KeyboardInterrupt:
        print("\nOperation cancelled by user.")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)
    finally:
        corrector.release_lock()


if __name__ == '__main__':
    main()