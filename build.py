#!/usr/bin/env python3
"""
Build Script for Media Library Tools

This script concatenates the shared utility module (utils.py) with individual tool scripts
to create standalone, self-contained scripts for distribution. It uses marker-based injection
to insert the shared code at the appropriate location within each tool script.

Features:
- Marker-based code injection (# {{include utils.py}})
- Comment insertion for debugging and identification
- Preserves executable nature of tool scripts
- Handles multiple tool scripts
- Error handling for file operations
- Command-line interface for flexibility

Author: Media Library Tools Project
Version: 1.0.0
"""

import argparse
import os
import sys
from pathlib import Path
from typing import List, Optional


VERSION = "1.0.0"
MARKER = "# {{include utils.py}}"
UTILS_FILE = "utils.py"


def read_utils_content() -> str:
    """
    Read the content of the utils.py file.
    
    Returns:
        Content of utils.py as a string
        
    Raises:
        FileNotFoundError: If utils.py is not found
        IOError: If there's an error reading the file
    """
    utils_path = Path(UTILS_FILE)
    if not utils_path.exists():
        raise FileNotFoundError(f"Utils file not found: {UTILS_FILE}")
    
    try:
        with open(utils_path, 'r', encoding='utf-8') as f:
            content = f.read()
        return content
    except IOError as e:
        raise IOError(f"Error reading utils file: {e}")


def process_script(script_path: Path, output_dir: Optional[Path] = None) -> bool:
    """
    Process a single script by injecting utils.py content at the marker location.
    
    Args:
        script_path: Path to the script to process
        output_dir: Directory to write the built script (default: build/ subdirectory)
        
    Returns:
        True if successful, False otherwise
    """
    if not script_path.exists():
        print(f"Error: Script not found: {script_path}")
        return False
    
    # Read the original script
    try:
        with open(script_path, 'r', encoding='utf-8') as f:
            script_content = f.read()
    except IOError as e:
        print(f"Error reading script {script_path}: {e}")
        return False
    
    # Check if marker exists
    if MARKER not in script_content:
        print(f"Warning: No marker found in {script_path} - script will be copied as-is")
        built_content = script_content
    else:
        # Read utils content
        try:
            utils_content = read_utils_content()
        except (FileNotFoundError, IOError) as e:
            print(f"Error: {e}")
            return False
        
        # Prepare the injected content with comments
        injected_content = f"""
# ======================================================
# INJECTED SHARED UTILITIES - START
# Generated by build.py v{VERSION}
# Source: {UTILS_FILE}
# ======================================================

{utils_content}

# ======================================================
# INJECTED SHARED UTILITIES - END
# ======================================================
"""
        
        # Replace the marker with the injected content
        built_content = script_content.replace(MARKER, injected_content)
    
    # Determine output path
    if output_dir is None:
        output_dir = Path("build")
    
    output_dir.mkdir(exist_ok=True)
    output_path = output_dir / script_path.name
    
    # Write the built script
    try:
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(built_content)
        
        # Preserve executable permissions
        if script_path.stat().st_mode & 0o111:  # If original is executable
            output_path.chmod(0o755)
            
        print(f"Built: {script_path} -> {output_path}")
        return True
        
    except IOError as e:
        print(f"Error writing built script {output_path}: {e}")
        return False


def find_scripts(search_paths: List[str]) -> List[Path]:
    """
    Find all script files in the given search paths.
    
    Args:
        search_paths: List of paths to search for scripts
        
    Returns:
        List of Path objects for found scripts
    """
    scripts = []
    
    for search_path in search_paths:
        path = Path(search_path)
        
        if path.is_file():
            # Single file specified
            scripts.append(path)
        elif path.is_dir():
            # Directory specified - find scripts
            for script_path in path.rglob("*"):
                if (script_path.is_file() and 
                    not script_path.name.startswith('.') and
                    script_path.suffix == '' and  # Extensionless files
                    script_path.name not in ['build.py', 'utils.py']):  # Exclude build system files
                    
                    # Basic check if it's a Python script
                    try:
                        with open(script_path, 'r', encoding='utf-8') as f:
                            first_line = f.readline()
                            if first_line.startswith('#!') and 'python' in first_line:
                                scripts.append(script_path)
                    except (IOError, UnicodeDecodeError):
                        continue
    
    return scripts


def main():
    """Main entry point for the build script."""
    parser = argparse.ArgumentParser(
        description="Build script for Media Library Tools",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s                          # Build all scripts in current directory
  %(prog)s plex/plex_correct_dirs   # Build a specific script
  %(prog)s plex/                    # Build all scripts in plex directory
  %(prog)s --output-dir dist plex/  # Build to custom output directory

The build script looks for the marker '# {{include utils.py}}' in source scripts
and replaces it with the content of utils.py surrounded by comment blocks.
Scripts without the marker are copied as-is.
        """
    )
    
    parser.add_argument(
        'paths',
        nargs='*',
        default=['.'],
        help='Paths to scripts or directories to build (default: current directory)'
    )
    
    parser.add_argument(
        '-o', '--output-dir',
        type=Path,
        default=Path('build'),
        help='Output directory for built scripts (default: build/)'
    )
    
    parser.add_argument(
        '--version',
        action='version',
        version=f'%(prog)s v{VERSION}'
    )
    
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Show verbose output'
    )
    
    args = parser.parse_args()
    
    # Find scripts to build
    scripts = find_scripts(args.paths)
    
    if not scripts:
        print("No scripts found to build.")
        return 1
    
    if args.verbose:
        print(f"Found {len(scripts)} script(s) to build:")
        for script in scripts:
            print(f"  {script}")
        print()
    
    # Process each script
    success_count = 0
    total_count = len(scripts)
    
    for script in scripts:
        if process_script(script, args.output_dir):
            success_count += 1
        else:
            print(f"Failed to build: {script}")
    
    # Summary
    print(f"\nBuild complete: {success_count}/{total_count} scripts built successfully")
    
    if success_count < total_count:
        return 1
    
    return 0


if __name__ == '__main__':
    sys.exit(main())