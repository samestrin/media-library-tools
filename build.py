#!/usr/bin/env python3
"""
Build Script for Media Library Tools

This script concatenates the shared utility module (utils.py) with individual tool scripts
to create standalone, self-contained scripts for distribution. It uses marker-based injection
to insert the shared code at the appropriate location within each tool script.

Features:
- Marker-based code injection (# {{include utils.py}})
- Comment insertion for debugging and identification
- Preserves executable nature of tool scripts
- Batch processing of all tools at once
- Enhanced error handling and reporting
- Command-line arguments for flexibility
- Performance optimization for multiple builds
- Detailed logging for build process
- Summary statistics and reporting

Author: Media Library Tools Project
Version: 1.0.0
"""

import argparse
import os
import sys
import time
import logging
from pathlib import Path
from typing import List, Optional, Dict


VERSION = "2.0.0"
MARKER = "# {{include utils.py}}"
UTILS_FILE = "utils.py"


def read_utils_content() -> str:
    """
    Read the content of the utils.py file.
    
    Returns:
        Content of utils.py as a string
        
    Raises:
        FileNotFoundError: If utils.py is not found
        IOError: If there's an error reading the file
    """
    utils_path = Path(UTILS_FILE)
    if not utils_path.exists():
        raise FileNotFoundError(f"Utils file not found: {UTILS_FILE}")
    
    try:
        with open(utils_path, 'r', encoding='utf-8') as f:
            content = f.read()
        return content
    except IOError as e:
        raise IOError(f"Error reading utils file: {e}")


def process_script(script_path: Path, output_dir: Optional[Path] = None) -> bool:
    """
    Process a single script by injecting utils.py content at the marker location.
    
    Args:
        script_path: Path to the script to process
        output_dir: Directory to write the built script (default: build/ subdirectory)
        
    Returns:
        True if successful, False otherwise
    """
    if not script_path.exists():
        print(f"Error: Script not found: {script_path}")
        return False
    
    # Read the original script
    try:
        with open(script_path, 'r', encoding='utf-8') as f:
            script_content = f.read()
    except IOError as e:
        print(f"Error reading script {script_path}: {e}")
        return False
    
    # Check if marker exists
    if MARKER not in script_content:
        print(f"Warning: No marker found in {script_path} - script will be copied as-is")
        built_content = script_content
    else:
        # Read utils content
        try:
            utils_content = read_utils_content()
        except (FileNotFoundError, IOError) as e:
            print(f"Error: {e}")
            return False
        
        # Prepare the injected content with comments
        injected_content = f"""
# ======================================================
# INJECTED SHARED UTILITIES - START
# Generated by build.py v{VERSION}
# Source: {UTILS_FILE}
# ======================================================

{utils_content}

# ======================================================
# INJECTED SHARED UTILITIES - END
# ======================================================
"""
        
        # Replace the marker with the injected content
        built_content = script_content.replace(MARKER, injected_content)
    
    # Determine output path
    if output_dir is None:
        output_dir = Path("build")
    
    output_dir.mkdir(exist_ok=True)
    output_path = output_dir / script_path.name
    
    # Write the built script
    try:
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(built_content)
        
        # Preserve executable permissions
        if script_path.stat().st_mode & 0o111:  # If original is executable
            output_path.chmod(0o755)
            
        print(f"Built: {script_path} -> {output_path}")
        return True
        
    except IOError as e:
        print(f"Error writing built script {output_path}: {e}")
        return False


def validate_built_script(script_path: Path) -> bool:
    """
    Validate that a built script is syntactically correct.
    
    Args:
        script_path: Path to the built script to validate
        
    Returns:
        True if valid, False otherwise
    """
    if not script_path.exists():
        print(f"Error: Built script not found for validation: {script_path}")
        return False
    
    try:
        # Try to compile the script to check for syntax errors
        with open(script_path, 'r', encoding='utf-8') as f:
            script_content = f.read()
        
        compile(script_content, str(script_path), 'exec')
        return True
    except SyntaxError as e:
        print(f"Syntax error in built script {script_path}: {e}")
        return False
    except Exception as e:
        print(f"Error validating built script {script_path}: {e}")
        return False


def find_scripts(search_paths: List[str]) -> List[Path]:
    """
    Find all script files in the given search paths.
    
    Args:
        search_paths: List of paths to search for scripts
        
    Returns:
        List of Path objects for found scripts
    """
    scripts = []
    
    for search_path in search_paths:
        path = Path(search_path)
        
        if path.is_file():
            # Single file specified
            scripts.append(path)
        elif path.is_dir():
            # Directory specified - find scripts
            for script_path in path.rglob("*"):
                if (script_path.is_file() and 
                    not script_path.name.startswith('.') and
                    script_path.suffix == '' and  # Extensionless files
                    script_path.name not in ['build.py', 'utils.py']):  # Exclude build system files
                    
                    # Basic check if it's a Python script
                    try:
                        with open(script_path, 'r', encoding='utf-8') as f:
                            first_line = f.readline()
                            if first_line.startswith('#!') and 'python' in first_line:
                                scripts.append(script_path)
                    except (IOError, UnicodeDecodeError):
                        continue
    
    return scripts


def setup_logging(verbose: bool = False, log_file: Optional[Path] = None) -> None:
    """Setup logging configuration for the build process."""
    log_level = logging.DEBUG if verbose else logging.INFO
    log_format = '%(asctime)s - %(levelname)s - %(message)s'
    
    handlers = [logging.StreamHandler()]
    if log_file:
        handlers.append(logging.FileHandler(log_file))
    
    logging.basicConfig(
        level=log_level,
        format=log_format,
        handlers=handlers
    )


def generate_build_summary(results: Dict[str, bool], start_time: float) -> None:
    """Generate and display build summary statistics."""
    total_time = time.time() - start_time
    success_count = sum(1 for success in results.values() if success)
    total_count = len(results)
    
    print(f"\n{'='*60}")
    print(f"BUILD SUMMARY")
    print(f"{'='*60}")
    print(f"Total scripts processed: {total_count}")
    print(f"Successfully built: {success_count}")
    print(f"Failed: {total_count - success_count}")
    print(f"Success rate: {(success_count/total_count)*100:.1f}%")
    print(f"Total build time: {total_time:.2f} seconds")
    
    if success_count < total_count:
        print(f"\nFAILED SCRIPTS:")
        for script, success in results.items():
            if not success:
                print(f"  ❌ {script}")
    
    if success_count > 0:
        print(f"\nSUCCESSFUL SCRIPTS:")
        for script, success in results.items():
            if success:
                print(f"  ✅ {script}")
    
    print(f"{'='*60}")


def build_all_tools(output_dir: Path, verbose: bool = False, validate: bool = False) -> Dict[str, bool]:
    """Build all tools in the project automatically."""
    results = {}
    
    # Define standard tool directories
    tool_dirs = ['plex', 'SABnzbd', 'plex-api']
    
    for tool_dir in tool_dirs:
        tool_path = Path(tool_dir)
        if tool_path.exists() and tool_path.is_dir():
            scripts = find_scripts([str(tool_path)])
            for script in scripts:
                script_name = f"{tool_dir}/{script.name}"
                if verbose:
                    print(f"Building {script_name}...")
                success = process_script(script, output_dir)
                results[script_name] = success
                
                # Validate the built script if requested
                if success and validate:
                    built_script_path = output_dir / script.name
                    if not validate_built_script(built_script_path):
                        print(f"Validation failed for {script_name}")
                        results[script_name] = False
        else:
            if verbose:
                print(f"Directory not found: {tool_dir}")
    
    return results


def main():
    """Main entry point for the build script."""
    parser = argparse.ArgumentParser(
        description="Build script for Media Library Tools",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s                          # Build all scripts in standard directories
  %(prog)s --all                    # Build all tools in project
  %(prog)s plex/plex_correct_dirs   # Build a specific script
  %(prog)s plex/                    # Build all scripts in plex directory
  %(prog)s --output-dir dist --all  # Build all tools to custom output directory
  %(prog)s --log-file build.log --verbose --all  # Verbose build with logging

The build script looks for the marker '# {{include utils.py}}' in source scripts
and replaces it with the content of utils.py surrounded by comment blocks.
Scripts without the marker are copied as-is.

Standard tool directories: plex/, sabnzbd/, plex-api/
        """
    )
    
    parser.add_argument(
        'paths',
        nargs='*',
        help='Paths to scripts or directories to build (default: none when using --all)'
    )
    
    parser.add_argument(
        '-o', '--output-dir',
        type=Path,
        default=Path('build'),
        help='Output directory for built scripts (default: build/)'
    )
    
    parser.add_argument(
        '--all',
        action='store_true',
        help='Build all tools in standard directories (plex/, sabnzbd/, plex-api/)'
    )
    
    parser.add_argument(
        '--log-file',
        type=Path,
        help='Log file for build process'
    )
    
    parser.add_argument(
        '--version',
        action='version',
        version=f'%(prog)s v{VERSION}'
    )
    
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Show verbose output'
    )
    
    parser.add_argument(
        '--clean',
        action='store_true',
        help='Clean output directory before building'
    )
    
    parser.add_argument(
        '--validate',
        action='store_true',
        help='Validate built scripts for syntax errors'
    )
    
    args = parser.parse_args()
    
    # Setup logging
    setup_logging(args.verbose, args.log_file)
    logging.info(f"Starting build process with Media Library Tools Build Script v{VERSION}")
    
    # Clean output directory if requested
    if args.clean and args.output_dir.exists():
        import shutil
        shutil.rmtree(args.output_dir)
        logging.info(f"Cleaned output directory: {args.output_dir}")
    
    start_time = time.time()
    
    # Determine what to build
    if args.all:
        # Build all tools automatically
        if args.paths:
            logging.warning("--all flag specified, ignoring individual paths")
        
        logging.info("Building all tools in standard directories")
        results = build_all_tools(args.output_dir, args.verbose, args.validate)
        
        if not results:
            print("No scripts found to build in standard directories.")
            return 1
    
    else:
        # Build specified paths or default behavior
        if not args.paths:
            args.paths = ['.']
        
        # Find scripts to build
        scripts = find_scripts(args.paths)
        
        if not scripts:
            print("No scripts found to build.")
            return 1
        
        if args.verbose:
            print(f"Found {len(scripts)} script(s) to build:")
            for script in scripts:
                print(f"  {script}")
            print()
        
        # Process each script
        results = {}
        for script in scripts:
            script_name = str(script)
            if args.verbose:
                print(f"Building {script_name}...")
            success = process_script(script, args.output_dir)
            results[script_name] = success
            
            # Validate the built script if requested
            if success and args.validate:
                built_script_path = args.output_dir / script.name
                if not validate_built_script(built_script_path):
                    print(f"Validation failed for {script_name}")
                    results[script_name] = False
    
    # Generate summary
    generate_build_summary(results, start_time)
    
    success_count = sum(1 for success in results.values() if success)
    total_count = len(results)
    
    logging.info(f"Build completed: {success_count}/{total_count} scripts built successfully")
    
    if success_count < total_count:
        return 1
    
    return 0


if __name__ == '__main__':
    sys.exit(main())