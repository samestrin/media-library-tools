#!/usr/bin/env python3
"""
Plex Movie Extras Organizer

A tool for organizing movie extras (featurettes, deleted scenes, etc.) according to
Plex naming conventions. This script moves and renames extra files from subdirectories
into the main movie directory with proper Plex-compatible naming.

Features:
- Moves extras from subdirectories to main movie directory
- Renames files with Plex-compatible naming conventions
- Handles multiple files with sequential numbering
- Dry-run mode for safe testing
- Cron-friendly operation with non-interactive detection
- File locking to prevent concurrent executions

Author: Media Library Tools Project
Version: 2.1.0
"""

import argparse
import os
import shutil
import sys
from pathlib import Path
from typing import List, Optional, Tuple


# ======================================================

# ======================================================
# INJECTED SHARED UTILITIES - START
# Generated by build.py v2.0.0
# Source: utils.py
# ======================================================

"""
Shared Utility Module for Media Library Tools

This module contains common functions used across multiple media library tools.
It consolidates duplicated functionality to improve maintainability and consistency.

Functions:
- display_banner(): Display standardized banner with script information
- is_non_interactive(): Detect non-interactive environments (cron, CI, etc.)
- read_global_config_bool(): Read boolean configuration from environment variables and .env files
- format_size(): Convert bytes to human-readable format
- confirm_action(): Prompt user for confirmation with skip option
- acquire_lock(): File locking functionality for preventing concurrent executions
- release_lock(): Release file locks with proper cleanup

Author: Media Library Tools Project
Version: 1.0.0
"""

import contextlib
import os
import platform
import sys
import tempfile
from pathlib import Path
from typing import Optional, Tuple

# Platform-specific imports
try:
    import fcntl  # Unix/Linux/macOS
except ImportError:
    fcntl = None  # Windows

try:
    import msvcrt  # Windows
except ImportError:
    msvcrt = None  # Unix/Linux/macOS


def display_banner(
    script_name: str,
    version: str,
    description: str,
    no_banner_flag: bool = False,
    quiet_mode: bool = False,
) -> None:
    """
    Display standardized banner for media library tools.

    Args:
        script_name: Name of the script
        version: Version string
        description: Brief description of the script
        no_banner_flag: If True, suppress banner display
        quiet_mode: If True, suppress banner display
    """
    # Check suppression conditions (highest to lowest priority)
    if no_banner_flag or quiet_mode or is_non_interactive():
        return

    try:
        # Display standardized ASCII art
        print("┏┳┓┏━╸╺┳┓╻┏━┓╻  ╻┏┓ ┏━┓┏━┓┏━┓╻ ╻╺┳╸┏━┓┏━┓╻  ┏━┓")
        print("┃┃┃┣╸  ┃┃┃┣━┫┃  ┃┣┻┓┣┳┛┣━┫┣┳┛┗┳┛ ┃ ┃ ┃┃ ┃┃  ┗━┓")
        print("╹ ╹┗━╸╺┻┛╹╹ ╹┗━╸╹┗━┛╹┗╸╹ ╹╹┗╸ ╹  ╹ ┗━┛┗━┛┗━╸┗━┛")
        print(f"{script_name} v{version}: {description}")
        print()  # Blank line for separation
    except Exception:
        # Banner display errors should not prevent script execution
        pass


def is_non_interactive() -> bool:
    """
    Detect if running in non-interactive environment (cron, etc.).

    Returns:
        True if non-interactive, False otherwise
    """
    # Check if stdin is not a TTY (common in cron jobs)
    if not sys.stdin.isatty():
        return True

    # Check for common non-interactive environment variables
    non_interactive_vars = ["CRON", "CI", "AUTOMATED", "NON_INTERACTIVE"]
    for var in non_interactive_vars:
        if os.environ.get(var):
            return True

    # Check if TERM is not set or is 'dumb' (common in automated environments)
    term = os.environ.get("TERM", "")
    return bool(not term or term == "dumb")


def read_global_config_bool(var_name: str, default: bool = False) -> bool:
    """
    Read a boolean environment variable with support for .env files.

    Args:
        var_name: Name of the environment variable
        default: Default value if not found

    Returns:
        Boolean value of the environment variable
    """
    # Check environment variable directly
    value = os.environ.get(var_name)
    if value is not None:
        return value.lower() in ("true", "1", "yes", "on")

    # Check local .env file
    env_file = ".env"
    if os.path.exists(env_file):
        try:
            with open(env_file) as f:
                for line in f:
                    line = line.strip()
                    if line.startswith(f"{var_name}="):
                        value = line.split("=", 1)[1].strip()
                        return value.lower() in ("true", "1", "yes", "on")
        except OSError:
            pass

    # Check global .env file
    global_env_path = Path.home() / ".media-library-tools" / ".env"
    if global_env_path.exists():
        try:
            with open(global_env_path) as f:
                for line in f:
                    line = line.strip()
                    if line.startswith(f"{var_name}="):
                        value = line.split("=", 1)[1].strip()
                        return value.lower() in ("true", "1", "yes", "on")
        except OSError:
            pass

    return default


def is_windows() -> bool:
    """
    Detect if running on Windows platform.

    Returns:
        True if running on Windows, False otherwise
    """
    return platform.system().lower() == "windows"


def should_use_emojis() -> bool:
    """
    Determine if emojis should be used based on platform and environment.

    Returns:
        True if emojis should be used, False otherwise
    """
    # Don't use emojis on Windows to avoid encoding issues
    if is_windows():
        return False

    # Don't use emojis in non-interactive environments
    if is_non_interactive():
        return False

    # Check for explicit emoji suppression
    return not read_global_config_bool("NO_EMOJIS", False)


def format_size(size_bytes: int) -> str:
    """
    Format size in bytes to human readable format.

    Args:
        size_bytes: Size in bytes

    Returns:
        Human readable size string
    """
    for unit in ["B", "K", "M", "G", "T"]:
        if size_bytes < 1024.0:
            if unit == "B":
                return f"{size_bytes:.0f}{unit}"
            else:
                return f"{size_bytes:.1f}{unit}"
        size_bytes /= 1024.0
    return f"{size_bytes:.1f}P"


def confirm_action(message: str, skip_confirmation: bool = False) -> bool:
    """
    Ask for user confirmation unless skipped.

    Args:
        message: Confirmation message to display
        skip_confirmation: If True, automatically confirm

    Returns:
        True if confirmed, False otherwise
    """
    if skip_confirmation:
        return True

    try:
        response = input(f"{message} (y/N): ").strip().lower()
        return response in ["y", "yes"]
    except (EOFError, KeyboardInterrupt):
        print("\nOperation cancelled.")
        return False


class FileLock:
    """
    File locking utility class for preventing concurrent executions.
    """

    def __init__(self, lock_prefix: str = "media_library_tool"):
        """
        Initialize file lock.

        Args:
            lock_prefix: Prefix for lock file name
        """
        self.lock_prefix = lock_prefix
        self.lock_file = None

    def acquire_lock(self, force: bool = False) -> bool:
        """
        Acquire file lock to prevent multiple instances.

        Args:
            force: If True, skip locking mechanism

        Returns:
            True if lock acquired successfully, False otherwise
        """
        if force:
            return True

        try:
            with tempfile.NamedTemporaryFile(
                mode="w", prefix=f"{self.lock_prefix}_", suffix=".lock", delete=False
            ) as temp_file:
                self.lock_file = temp_file
                
                # Platform-specific file locking
                if fcntl is not None:  # Unix/Linux/macOS
                    fcntl.flock(self.lock_file.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
                elif msvcrt is not None:  # Windows
                    msvcrt.locking(self.lock_file.fileno(), msvcrt.LK_NBLCK, 1)
                else:
                    # Fallback: no locking available, just proceed
                    pass
                    
                self.lock_file.write(str(os.getpid()))
                self.lock_file.flush()
            return True
        except (OSError, IOError) as e:
            if self.lock_file:
                self.lock_file.close()
                with contextlib.suppress(OSError):
                    os.unlink(self.lock_file.name)
                self.lock_file = None
            print(
                "Error: Another instance is already running. Use --force to override."
            )
            print(f"Lock error: {e}")
            return False

    def release_lock(self) -> None:
        """
        Release the file lock.
        """
        if self.lock_file:
            try:
                # Only unlock if file is still open
                if not self.lock_file.closed:
                    # Platform-specific file unlocking
                    if fcntl is not None:  # Unix/Linux/macOS
                        fcntl.flock(self.lock_file.fileno(), fcntl.LOCK_UN)
                    elif msvcrt is not None:  # Windows
                        msvcrt.locking(self.lock_file.fileno(), msvcrt.LK_UNLCK, 1)
                    # No explicit unlock needed for fallback case
                    
                    self.lock_file.close()
            except (OSError, ValueError, IOError):
                # Handle both file system errors and closed file errors
                pass

            # Always try to remove lock file if it exists
            try:
                if os.path.exists(self.lock_file.name):
                    os.unlink(self.lock_file.name)
            except OSError:
                pass
            finally:
                self.lock_file = None


# Legacy standalone functions for backward compatibility
def acquire_lock(
    lock_prefix: str = "media_library_tool", force: bool = False
) -> Tuple[bool, Optional[FileLock]]:
    """
    Legacy function for acquiring file locks.

    Args:
        lock_prefix: Prefix for lock file name
        force: If True, skip locking mechanism

    Returns:
        Tuple of (success: bool, lock_instance: FileLock or None)
    """
    lock = FileLock(lock_prefix)
    success = lock.acquire_lock(force)
    return success, lock if success else None


def release_lock(lock_instance: FileLock) -> None:
    """
    Legacy function for releasing file locks.

    Args:
        lock_instance: FileLock instance to release
    """
    if lock_instance:
        lock_instance.release_lock()


# ======================================================
# INJECTED SHARED UTILITIES - END
# ======================================================



# ======================================================


# Version constant
VERSION = "2.1.0"










class PlexMovieExtrasOrganizer:
    """Main class for organizing Plex movie extras."""
    
    def __init__(self, dry_run: bool = False, force: bool = False, verbose: bool = False):
        self.dry_run = dry_run
        self.force = force
        self.verbose = verbose
        self.file_lock = FileLock('plex_move_movie_extras')
        
        # Video file extensions for validation
        self.video_extensions = {
            '.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v',
            '.mpg', '.mpeg', '.3gp', '.ogv', '.ts', '.m2ts', '.vob', '.divx',
            '.xvid', '.rm', '.rmvb', '.asf', '.f4v', '.m4p'
        }
    
    def acquire_lock(self) -> bool:
        """Acquire file lock to prevent multiple instances."""
        return self.file_lock.acquire_lock(self.force)
    
    def release_lock(self) -> None:
        """Release the file lock."""
        self.file_lock.release_lock()
    
    def is_video_file(self, file_path: str) -> bool:
        """Check if a file is a video file based on its extension.
        
        Args:
            file_path: Path to the file to check
            
        Returns:
            True if file is a video file, False otherwise
        """
        file_extension = os.path.splitext(file_path)[1].lower()
        return file_extension in self.video_extensions

    def organize_extras(self, main_file: str, sub_dir: str) -> bool:
        """Organize movie extras from subdirectory to main directory."""
        if not os.path.isfile(main_file):
            print(f"Error: main file '{main_file}' does not exist.")
            return False

        # Validate main file is a video file
        if not self.is_video_file(main_file):
            print(f"Error: main file '{main_file}' is not a supported video file.")
            print(f"Supported video extensions: {', '.join(sorted(self.video_extensions))}")
            return False

        movie_dir = os.path.dirname(main_file)
        base_name = os.path.splitext(os.path.basename(main_file))[0]
        extras_dir = os.path.join(movie_dir, sub_dir)

        if not os.path.isdir(extras_dir):
            print(f"Error: sub-directory '{sub_dir}' does not exist.")
            return False

        files = sorted(os.listdir(extras_dir))
        count = 1

        for file in files:
            src_path = os.path.join(extras_dir, file)
            if os.path.isdir(src_path):
                continue  # skip nested folders

            # Validate file is a video file
            if not self.is_video_file(src_path):  # Use src_path to check the full path
                print(f"Warning: Skipping non-video file '{file}'")
                continue

            ext = os.path.splitext(file)[1]
            safe_sub = sub_dir.lower().replace(" ", "")
            suffix = f"-{safe_sub}"

            if len(files) > 1:
                new_name = f"{base_name} - {sub_dir} {count:02d}{suffix}{ext}"
            else:
                new_name = f"{base_name} - {sub_dir}{suffix}{ext}"

            dest_path = os.path.join(movie_dir, new_name)

            if self.dry_run:
                print(f"[DRY RUN] Would rename:\\n  '{src_path}'\\n  => '{dest_path}'")
            else:
                try:
                    shutil.move(src_path, dest_path)
                    print(f"Renamed:\n  '{src_path}'\n  => '{dest_path}'")
                except Exception as e:
                    print(f"Error moving '{src_path}' to '{dest_path}': {e}")
                    return False
            count += 1

        if not self.dry_run:
            try:
                os.rmdir(extras_dir)
                print(f"Removed empty directory: {extras_dir}")
            except OSError:
                print(f"Note: Directory not empty or not removed: {extras_dir}")
        
        return True



def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Move and rename movie extras to match Plex naming conventions",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Preview what would be moved (dry-run mode, default)
  %(prog)s "Movie (2023).mkv" "Featurettes"
  
  # Actually move files with confirmation
  %(prog)s "Movie (2023).mkv" "Deleted Scenes" --execute
  
  # Move files without confirmation (for automation)
  %(prog)s "Movie (2023).mkv" "Behind the Scenes" --execute -y
  
Cron Usage:
  # Run daily to organize movie extras (non-interactive)
  0 2 * * * /usr/local/bin/plex_move_movie_extras "/movies/Movie.mkv" "Featurettes" --execute -y
  

"""
    )
    
    parser.add_argument(
        "main_file", 
        help="Main movie file path"
    )
    parser.add_argument(
        "sub_dir", 
        help="Subdirectory name containing extras (e.g., 'Featurettes', 'Deleted Scenes')"
    )
    parser.add_argument(
        "--dry-run", 
        action="store_true",
        default=True,
        help="Preview changes without modifying files (default: true)"
    )
    parser.add_argument(
        "--execute", 
        action="store_true", 
        help="Actually perform operations (overrides --dry-run)"
    )
    parser.add_argument(
        "-y", "--yes", 
        action="store_true", 
        help="Skip confirmation prompts (useful for automation/cron)"
    )
    parser.add_argument(
        "--force", 
        action="store_true", 
        help="Force execution even if another instance is running"
    )
    parser.add_argument(
        "--verbose", 
        action="store_true", 
        help="Enable verbose output for debugging"
    )
    parser.add_argument(
        "--debug", 
        action="store_true", 
        help="Enable debug output (implies --verbose)"
    )
    parser.add_argument(
        "--no-banner",
        action="store_true",
        help="Suppress banner display"
    )
    parser.add_argument(
        "--version", 
        action="version", 
        version=f"%(prog)s {VERSION}"
    )
    
    args = parser.parse_args()
    
    # Handle debug mode
    if args.debug:
        args.verbose = True
    
    # Read global configuration
    auto_execute = read_global_config_bool('AUTO_EXECUTE', False)
    auto_confirm = read_global_config_bool('AUTO_CONFIRM', False)
    quiet_mode = read_global_config_bool('QUIET_MODE', False)
    
    # Apply global configuration (CLI arguments take precedence)
    if auto_execute and not args.execute:
        args.execute = True  # Set execute flag if AUTO_EXECUTE is set
    if auto_confirm and not args.yes:
        args.yes = True  # Set yes flag if AUTO_CONFIRM is set
    
    # Handle dry-run/execute logic
    if args.execute:
        dry_run_mode = False
    else:
        dry_run_mode = args.dry_run  # This is True by default
    
    # Validate arguments
    if not os.path.exists(args.main_file):
        print(f"Error: Main file '{args.main_file}' does not exist.")
        sys.exit(1)
    
    if not os.path.isfile(args.main_file):
        print(f"Error: '{args.main_file}' is not a file.")
        sys.exit(1)
    
    # Check if subdirectory exists relative to main file
    main_file_dir = os.path.dirname(os.path.abspath(args.main_file))
    sub_dir_path = os.path.join(main_file_dir, args.sub_dir)
    
    if not os.path.exists(sub_dir_path):
        print(f"Error: Subdirectory '{args.sub_dir}' does not exist in '{main_file_dir}'.")
        sys.exit(1)
    
    if not os.path.isdir(sub_dir_path):
        print(f"Error: '{args.sub_dir}' is not a directory.")
        sys.exit(1)
    
    # Display banner
    display_banner("plex_move_movie_extras", VERSION, 
                  "organize movie extras into proper subdirectories",
                  args.no_banner, quiet_mode)
    
    if dry_run_mode:
        print("DRY-RUN MODE: No changes will be made")
    else:
        print("EXECUTE MODE: Files will be moved and renamed")
    
    if args.debug:
        print("Debug: ENABLED")
    elif args.verbose:
        print("Verbose: ENABLED")
    print()
    
    # Create organizer instance
    organizer = PlexMovieExtrasOrganizer(
        dry_run=dry_run_mode,
        force=args.force,
        verbose=args.verbose
    )
    
    # Acquire lock
    if not organizer.acquire_lock():
        sys.exit(1)
    
    try:
        # Show what will be done
        if args.verbose:
            print(f"Main file: {args.main_file}")
            print(f"Subdirectory: {args.sub_dir}")
            print(f"Mode: {'DRY RUN' if dry_run_mode else 'EXECUTE'}")
            print("-" * 50)
        
        # Confirm action unless in dry-run mode or confirmation skipped
        if not dry_run_mode:
            if not confirm_action(
                f"Move extras from '{args.sub_dir}' to main movie directory?",
                args.yes or is_non_interactive()
            ):
                print("Operation cancelled.")
                sys.exit(0)
        
        # Execute the organization
        success = organizer.organize_extras(args.main_file, sub_dir_path)
        
        if success:
            if dry_run_mode:
                print("\nDry run completed successfully. Use --execute to make changes.")
            else:
                print("\nMovie extras organized successfully!")
        else:
            print("\nOperation failed. Check error messages above.")
            sys.exit(1)
            
    except KeyboardInterrupt:
        print("\nOperation cancelled by user.")
        sys.exit(1)
    except Exception as e:
        print(f"\nUnexpected error: {e}")
        if args.debug:
            import traceback
            traceback.print_exc()
        sys.exit(1)
    finally:
        organizer.release_lock()


if __name__ == "__main__":
    main()
