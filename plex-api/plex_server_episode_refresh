#!/usr/bin/env python3
"""
Plex Server Episode Refresh Tool
Version: 2.0

This tool forces Plex Media Server to regenerate the thumbnail image for a specific episode
using the Plex API. It does this safely without moving or deleting video files.

Requirements:
- Python 3.6+
- Valid PLEX_TOKEN (via CLI argument, environment variable, or .env file)
- Valid PLEX_SERVER (via CLI argument, environment variable, or .env file)
- No external packages required (uses only standard library)
"""

import os
import json
import urllib.request
import urllib.parse
import urllib.error
import time
import sys
import argparse
from typing import Optional, Dict, Any

VERSION = "2.0"


class PlexServerEpisodeRefresh:
    """Tool to refresh episode thumbnails in Plex Media Server."""
    
    def __init__(self, token: Optional[str] = None, server_url: Optional[str] = None, 
                 verbose: bool = False, debug: bool = False):
        """
        Initialize the Plex Server Episode Refresh tool.
        
        Args:
            token: Plex authentication token. If not provided, will check environment and .env file.
            server_url: URL of the Plex server. If not provided, will check environment and .env file.
            verbose: Enable verbose output
            debug: Enable debug output
        """
        self.verbose = verbose
        self.debug = debug
        self.token = token or self._get_token_from_sources()
        self.server_url = (server_url or self._get_server_from_sources()).rstrip('/')
        
        if not self.token:
            raise ValueError("PLEX_TOKEN not found. Please provide via --token argument, PLEX_TOKEN environment variable, local .env, or ~/.media-library-tool/.env file")
        
        if not self.server_url:
            raise ValueError("PLEX_SERVER not found. Please provide via --server argument, PLEX_SERVER environment variable, local .env, or ~/.media-library-tool/.env file")
    
    def _get_token_from_sources(self) -> Optional[str]:
        """Get PLEX_TOKEN from environment variable or .env file."""
        # First check environment variable
        token = os.environ.get('PLEX_TOKEN')
        if token:
            if self.debug:
                print("Found PLEX_TOKEN in environment variable")
            return token.strip('"\'')
        
        # Then check local .env file
        env_file = '.env'
        if os.path.exists(env_file):
            try:
                with open(env_file, 'r') as f:
                    for line in f:
                        line = line.strip()
                        if line.startswith('PLEX_TOKEN='):
                            # Remove quotes if present
                            token = line.split('=', 1)[1].strip()
                            if self.debug:
                                print("Found PLEX_TOKEN in .env file")
                            return token.strip('"\'')
            except (IOError, OSError) as e:
                if self.debug:
                    print(f"Could not read .env file: {e}")
        
        # Finally check global .env file
        from pathlib import Path
        global_env_path = Path.home() / '.media-library-tool' / '.env'
        if global_env_path.exists():
            try:
                with open(global_env_path, 'r') as f:
                    for line in f:
                        line = line.strip()
                        if line.startswith('PLEX_TOKEN='):
                            token = line.split('=', 1)[1].strip()
                            if self.debug:
                                print("Found PLEX_TOKEN in global .env file")
                            return token.strip('"\'')
            except (IOError, OSError) as e:
                if self.debug:
                    print(f"Could not read global .env file: {e}")
        
        return None
    
    def _get_server_from_sources(self) -> Optional[str]:
        """Get PLEX_SERVER from environment variable or .env file."""
        # First check environment variable
        server = os.environ.get('PLEX_SERVER')
        if server:
            if self.debug:
                print("Found PLEX_SERVER in environment variable")
            return server.strip('"\'')
        
        # Then check local .env file
        env_file = '.env'
        if os.path.exists(env_file):
            try:
                with open(env_file, 'r') as f:
                    for line in f:
                        line = line.strip()
                        if line.startswith('PLEX_SERVER='):
                            # Remove quotes if present
                            server = line.split('=', 1)[1].strip()
                            if self.debug:
                                print("Found PLEX_SERVER in .env file")
                            return server.strip('"\'')
            except (IOError, OSError) as e:
                if self.debug:
                    print(f"Could not read .env file: {e}")
        
        # Finally check global .env file
        from pathlib import Path
        global_env_path = Path.home() / '.media-library-tool' / '.env'
        if global_env_path.exists():
            try:
                with open(global_env_path, 'r') as f:
                    for line in f:
                        line = line.strip()
                        if line.startswith('PLEX_SERVER='):
                            server = line.split('=', 1)[1].strip()
                            if self.debug:
                                print("Found PLEX_SERVER in global .env file")
                            return server.strip('"\'')
            except (IOError, OSError) as e:
                if self.debug:
                    print(f"Could not read global .env file: {e}")
        
        # Default fallback
        if self.debug:
            print("Using default server: http://localhost:32400")
        return "http://localhost:32400"
    
    def log_verbose(self, message: str) -> None:
        """Print verbose message if verbose mode is enabled."""
        if self.verbose:
            print(f"[VERBOSE] {message}")
    
    def log_debug(self, message: str) -> None:
        """Print debug message if debug mode is enabled."""
        if self.debug:
            print(f"[DEBUG] {message}")
    
    def _make_request(self, url: str, method: str = 'GET', data: Optional[Dict] = None) -> Any:
        """
        Make an authenticated request to the Plex API.
        
        Args:
            url: Full URL to request
            method: HTTP method (GET, PUT, DELETE, etc.)
            data: Optional data to send with request
        
        Returns:
            Response data as dictionary or None
        """
        # Add token to URL
        separator = '&' if '?' in url else '?'
        url_with_token = f"{url}{separator}X-Plex-Token={self.token}"
        
        self.log_debug(f"Making {method} request to: {url}")
        
        request = urllib.request.Request(url_with_token)
        request.get_method = lambda: method
        
        if data:
            request.add_header('Content-Type', 'application/json')
            request.data = json.dumps(data).encode('utf-8')
            self.log_debug(f"Request data: {data}")
        
        try:
            with urllib.request.urlopen(request) as response:
                self.log_debug(f"Response status: {response.status}")
                if response.status == 200:
                    content = response.read().decode('utf-8')
                    # Try to parse as JSON, otherwise return as string
                    try:
                        return json.loads(content)
                    except json.JSONDecodeError:
                        return content
                return None
        except urllib.error.HTTPError as e:
            print(f"HTTP Error {e.code}: {e.reason}", file=sys.stderr)
            return None
        except urllib.error.URLError as e:
            print(f"URL Error: {e.reason}", file=sys.stderr)
            return None
    
    def refresh_episode_image(self, episode_hash: str) -> bool:
        """
        Refresh the thumbnail image for a specific episode.
        
        This method forces Plex to regenerate the thumbnail by:
        1. First trying to analyze the episode (regenerates thumbnail)
        2. If that doesn't work, refreshing metadata
        3. Optionally triggering a re-generation of default artwork
        
        Args:
            episode_hash: The rating key (hash/ID) of the episode
        
        Returns:
            True if successful, False otherwise
        """
        print(f"Starting image refresh for episode {episode_hash}...")
        
        # Step 1: Get episode metadata to verify it exists
        self.log_verbose("Verifying episode exists...")
        metadata_url = f"{self.server_url}/library/metadata/{episode_hash}"
        episode_data = self._make_request(metadata_url)
        
        if not episode_data:
            print(f"Error: Episode with hash {episode_hash} not found", file=sys.stderr)
            return False
        
        # Extract episode information for verbose output
        episode_title = "Unknown"
        if episode_data and 'MediaContainer' in episode_data:
            if 'Metadata' in episode_data['MediaContainer'] and episode_data['MediaContainer']['Metadata']:
                metadata = episode_data['MediaContainer']['Metadata'][0]
                episode_title = metadata.get('title', 'Unknown')
                show_title = metadata.get('grandparentTitle', 'Unknown Show')
                season_num = metadata.get('parentIndex', 'Unknown')
                episode_num = metadata.get('index', 'Unknown')
                self.log_verbose(f"Found episode: {show_title} S{season_num}E{episode_num} - {episode_title}")
        
        print(f"Found episode. Processing...")
        
        # Step 2: Force analyze to regenerate thumbnail
        # The analyze process will regenerate the thumbnail from the video file
        self.log_verbose("Triggering analysis to regenerate thumbnail...")
        analyze_url = f"{self.server_url}/library/metadata/{episode_hash}/analyze"
        
        # Use PUT method for analyze
        analyze_result = self._make_request(analyze_url, method='PUT')
        
        # Analyze typically returns empty response on success
        if analyze_result is not None or analyze_result == "":
            self.log_verbose("Analysis triggered successfully")
        else:
            print("Warning: Analysis may not have triggered properly", file=sys.stderr)
        
        # Step 3: Give Plex a moment to process
        self.log_verbose("Waiting for processing...")
        time.sleep(2)
        
        # Step 4: Refresh metadata to ensure thumbnail is updated
        self.log_verbose("Refreshing metadata...")
        refresh_url = f"{self.server_url}/library/metadata/{episode_hash}/refresh"
        
        # Force refresh even if metadata seems current
        refresh_result = self._make_request(refresh_url, method='PUT')
        
        if refresh_result is not None or refresh_result == "":
            self.log_verbose("Metadata refresh triggered successfully")
        else:
            print("Warning: Metadata refresh may not have completed", file=sys.stderr)
        
        # Step 5: Alternative method - delete existing thumb to force regeneration
        # This is a more aggressive approach but safe for thumbnails
        self.log_verbose("Attempting to clear cached thumbnail...")
        
        # Get the current thumb URL
        metadata_url = f"{self.server_url}/library/metadata/{episode_hash}"
        episode_data = self._make_request(metadata_url)
        
        if episode_data and 'MediaContainer' in episode_data:
            if 'Metadata' in episode_data['MediaContainer'] and episode_data['MediaContainer']['Metadata']:
                metadata = episode_data['MediaContainer']['Metadata'][0]
                if 'thumb' in metadata:
                    # Extract thumb ID from URL (format: /library/metadata/{key}/thumb/{id})
                    thumb_path = metadata['thumb']
                    self.log_debug(f"Current thumbnail path: {thumb_path}")
                    
                    # Delete the current thumb to force regeneration
                    # This uses the uploads endpoint to clear the thumb
                    clear_thumb_url = f"{self.server_url}/library/metadata/{episode_hash}/posters"
                    clear_result = self._make_request(clear_thumb_url, method='DELETE')
                    
                    if clear_result is not None or clear_result == "":
                        self.log_verbose("Cleared existing thumbnail")
                        
                        # Wait a moment then trigger another analyze
                        time.sleep(1)
                        self.log_verbose("Re-triggering analysis for new thumbnail...")
                        self._make_request(analyze_url, method='PUT')
        
        print(f"âœ… Episode image refresh completed for episode {episode_hash}")
        if not self.verbose:
            print("Note: Thumbnail generation may take a few moments to complete in the background.")
            print("Refresh your Plex client to see the updated thumbnail.")
        
        return True





def main() -> None:
    """
    Main entry point for the Plex Episode Image Refresh tool.
    """
    parser = argparse.ArgumentParser(
        description='Plex Server Episode Refresh Tool - Force regeneration of episode thumbnails',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s 12345                           # Refresh episode with ID 12345
  %(prog)s 12345 --verbose                 # Refresh with verbose output
  %(prog)s 12345 --token YOUR_TOKEN        # Use specific token
  %(prog)s 12345 --server http://plex:32400 # Use custom server URL
  %(prog)s 12345 --debug                   # Show debug information

Token Sources (in order of priority):
  1. --token command line argument
  2. PLEX_TOKEN environment variable
  3. PLEX_TOKEN in local .env file
  4. PLEX_TOKEN in ~/.media-library-tool/.env file

Server Sources (in order of priority):
  1. --server command line argument
  2. PLEX_SERVER environment variable
  3. PLEX_SERVER in local .env file
  4. PLEX_SERVER in ~/.media-library-tool/.env file
  5. Default: http://localhost:32400


"""
    )
    
    parser.add_argument('episode_hash', 
                       help='Episode rating key (ID) from Plex')
    parser.add_argument('--token', '-t',
                       help='Plex authentication token (overrides environment/file)')
    parser.add_argument('--server', '-s',
                       help='Plex server URL (overrides environment/file, default: http://localhost:32400)')
    parser.add_argument('--verbose', '-v', action='store_true',
                       help='Show verbose output')
    parser.add_argument('--debug', action='store_true',
                       help='Show detailed debug output')
    parser.add_argument('--version', action='version', 
                       version=f'%(prog)s v{VERSION}')
    
    args = parser.parse_args()
    
    # Print header
    print(f"Plex Server Episode Refresh Tool v{VERSION}")
    print("=" * 50)
    
    try:
        # Initialize the tool
        tool = PlexServerEpisodeRefresh(
            token=args.token,
            server_url=args.server,
            verbose=args.verbose,
            debug=args.debug
        )
        
        # Refresh the episode image
        success = tool.refresh_episode_image(args.episode_hash)
        
        if success:
            sys.exit(0)
        else:
            sys.exit(1)
            
    except ValueError as e:
        print(f"Configuration Error: {e}", file=sys.stderr)
        print("\nPlease provide required configuration via:", file=sys.stderr)
        print("  Token: --token argument, PLEX_TOKEN environment variable, local .env, or ~/.media-library-tool/.env file", file=sys.stderr)
        print("  Server: --server argument, PLEX_SERVER environment variable, local .env, or ~/.media-library-tool/.env file", file=sys.stderr)
        sys.exit(1)
    except KeyboardInterrupt:
        print("\nOperation cancelled by user", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Unexpected error: {e}", file=sys.stderr)
        if args.debug:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()