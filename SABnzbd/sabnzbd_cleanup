#!/usr/bin/env python3
"""
SABnzbd Directory Cleanup Script
Version: 2.0 (Python rewrite)
Purpose: Safely identify and remove SABnzbd temporary/incomplete directories
"""

import os
import sys
import argparse
import subprocess
import fcntl
import tempfile
from pathlib import Path
from typing import List, Tuple, Dict, Optional
import shutil

VERSION = "2.2"


def display_banner(script_name: str, version: str, description: str, 
                  no_banner_flag: bool = False, quiet_mode: bool = False) -> None:
    """
    Display standardized banner for media library tools.
    """
    # Check suppression conditions (highest to lowest priority)
    if no_banner_flag or quiet_mode or is_non_interactive():
        return
    
    try:
        # Display standardized ASCII art
        print("┏┳┓┏━╸╺┳┓╻┏━┓╻  ╻┏┓ ┏━┓┏━┓┏━┓╻ ╻╺┳╸┏━┓┏━┓╻  ┏━┓")
        print("┃┃┃┣╸  ┃┃┃┣━┫┃  ┃┣┻┓┣┳┛┣━┫┣┳┛┗┳┛ ┃ ┃ ┃┃ ┃┃  ┗━┓")
        print("╹ ╹┗━╸╺┻┛╹╹ ╹┗━╸╹┗━┛╹┗╸╹ ╹╹┗╸ ╹  ╹ ┗━┛┗━┛┗━╸┗━┛")
        print(f"{script_name} v{version}: {description}")
        print()  # Blank line for separation
    except Exception:
        # Banner display errors should not prevent script execution
        pass

class SABnzbdDetector:
    def __init__(self, verbose=False, debug=False):
        self.verbose = verbose
        self.debug = debug
        self.lock_file = None
        self.stats = {
            'total_dirs': 0,
            'checked_dirs': 0,
            'sabnzbd_dirs': 0,
            'bittorrent_dirs': 0,
            'permission_denied': 0
        }
        
    def log_verbose(self, msg):
        if self.verbose or self.debug:
            print(f"[VERBOSE] {msg}", file=sys.stderr)
    
    def log_debug(self, msg):
        if self.debug:
            print(f"[DEBUG] {msg}", file=sys.stderr)
    
    def is_bittorrent_directory(self, dir_path: Path) -> bool:
        """Check if directory appears to be a BitTorrent download"""
        try:
            indicators = []
            
            # Check for .torrent files
            if list(dir_path.glob('*.torrent')):
                indicators.append(".torrent files")
                
            # Check for BitTorrent client files
            bt_patterns = ['*.resume', '*.fastresume', '*.!ut', '*.dat']
            for pattern in bt_patterns:
                if list(dir_path.glob(pattern)):
                    indicators.append(f"{pattern} files")
                    break
                    
            # Check directory name
            dirname = dir_path.name
            if any(x in dirname.lower() for x in ['torrent', 'bt_', 'bittorrent']):
                indicators.append("BitTorrent naming")
                
            if indicators:
                self.log_verbose(f"  BitTorrent indicators in {dirname}: {', '.join(indicators)}")
                return True
            return False
        except PermissionError:
            # If we can't check, assume it's not BitTorrent
            return False
    
    def analyze_directory(self, dir_path: Path) -> Tuple[bool, int, List[str]]:
        """
        Analyze a directory to determine if it's a SABnzbd directory
        Returns: (is_sabnzbd, score, indicators)
        """
        dirname = dir_path.name
        indicators = []
        score = 0
        
        self.log_debug(f"Analyzing: {dir_path}")
        
        # Check if we can access the directory
        try:
            # Try to list directory contents to check permissions
            list(dir_path.iterdir())
        except PermissionError:
            self.log_debug(f"  → Skipping: Permission denied")
            self.stats['permission_denied'] += 1
            return False, 0, []
        except Exception as e:
            self.log_debug(f"  → Skipping: Error accessing directory: {e}")
            return False, 0, []
        
        # First check: Is this BitTorrent?
        if self.is_bittorrent_directory(dir_path):
            self.log_debug(f"  → Skipping: BitTorrent directory")
            return False, 0, []
        
        # Check for SABnzbd admin files (HIGHEST confidence)
        admin_files = ['__admin__', 'SABnzbd_nzf', 'SABnzbd_nzo']
        for admin_file in admin_files:
            try:
                if (dir_path / admin_file).exists():
                    indicators.append(f"SABnzbd file: {admin_file}")
                    score += 15
            except PermissionError:
                pass  # Skip if we can't check
        
        # Check for NZB files (HIGH confidence)
        try:
            nzb_files = list(dir_path.glob('*.nzb'))
            if nzb_files:
                indicators.append(f"NZB files ({len(nzb_files)})")
                score += 10
        except PermissionError:
            pass
            
        # Check for PAR2 files (search immediate dir and one level deep)
        try:
            # First check immediate directory
            par2_files = list(dir_path.glob('*.par2'))
            # Then check one level deep
            par2_files.extend(list(dir_path.glob('*/*.par2')))
            # Limit to prevent excessive searching
            par2_files = par2_files[:100]
            
            if par2_files:
                indicators.append(f"PAR2 files ({len(par2_files)})")
                score += 6
                if len(par2_files) > 3:
                    score += 3
        except PermissionError:
            pass
                
        # Check for RAR files
        try:
            rar_files = list(dir_path.glob('*.rar'))[:100]  # Limit search
            # Also check for split RAR files
            rar_files.extend(list(dir_path.glob('*.r[0-9][0-9]'))[:50])
            
            if rar_files:
                # RAR with PAR2 or NZB = strong indicator
                if 'par2_files' in locals() and par2_files:
                    indicators.append(f"RAR files ({len(rar_files)}) with PAR2")
                    score += 6
                elif 'nzb_files' in locals() and nzb_files:
                    indicators.append(f"RAR files ({len(rar_files)}) with NZB")
                    score += 6
                elif len(rar_files) > 10:
                    indicators.append(f"Many RAR files ({len(rar_files)})")
                    score += 2
        except PermissionError:
            pass
                
        # Check directory name patterns
        # Pattern 1: ends with .1, .2, etc (retry pattern)
        if dirname[-2:] in ['.1', '.2', '.3', '.4', '.5']:
            indicators.append("Retry suffix (.N)")
            score += 5
            
        # Pattern 2: Contains par2/yEnc/nzb in name
        if any(x in dirname for x in ['par2', 'yEnc', 'nzb']):
            indicators.append("Usenet naming pattern")
            score += 6
            
        # Pattern 3: TV show with retry suffix
        import re
        if re.search(r'S\d+E\d+.*\.\d+$', dirname):
            indicators.append("TV show retry pattern")
            score += 5
            
        # Check for _UNPACK_ or EXTRACT_ subdirectories
        try:
            for subdir in dir_path.iterdir():
                if subdir.is_dir() and ('_UNPACK_' in subdir.name or 'EXTRACT_' in subdir.name):
                    indicators.append("SABnzbd unpack directory")
                    score += 12
                    break
        except PermissionError:
            pass
                
        # Determine threshold
        threshold = 10
        
        # Special cases for lower threshold
        if 'nzb_files' in locals() and nzb_files:
            threshold = 5
            self.log_debug(f"  Threshold lowered to 5 (NZB files present)")
        elif 'par2_files' in locals() and par2_files:
            threshold = 8
            self.log_debug(f"  Threshold lowered to 8 (PAR2 files present)")
        elif any(x in dirname for x in ['par2', 'yEnc', '.1', '.2', '.3']):
            threshold = 8
            self.log_debug(f"  Threshold lowered to 8 (naming pattern)")
            
        # Override: NZB + PAR2 = definitely SABnzbd
        if ('nzb_files' in locals() and nzb_files and 
            'par2_files' in locals() and par2_files):
            self.log_debug(f"  → OVERRIDE: NZB + PAR2 = definitive SABnzbd")
            return True, score, indicators
            
        # Make decision
        is_sabnzbd = score >= threshold
        
        if self.debug:
            status = "SABnzbd" if is_sabnzbd else "Not SABnzbd"
            print(f"  → {status} (score: {score}, threshold: {threshold})", file=sys.stderr)
            if indicators:
                print(f"    Indicators: {', '.join(indicators)}", file=sys.stderr)
        elif self.verbose and is_sabnzbd:
            print(f"  → SABnzbd directory detected: {dirname}", file=sys.stderr)
            print(f"    Score: {score}, Indicators: {', '.join(indicators)}", file=sys.stderr)
            
        return is_sabnzbd, score, indicators
    
    def find_sabnzbd_directories(self, search_path: Path) -> List[Tuple[Path, int]]:
        """Find all SABnzbd directories in the given path"""
        sabnzbd_dirs = []
        
        print(f"Scanning {search_path}...", file=sys.stderr)
        
        # Get all immediate subdirectories
        try:
            subdirs = [d for d in search_path.iterdir() if d.is_dir()]
        except PermissionError:
            print(f"Error: Permission denied accessing {search_path}", file=sys.stderr)
            return []
            
        self.stats['total_dirs'] = len(subdirs)
        print(f"Found {len(subdirs)} subdirectories to check", file=sys.stderr)
        print(file=sys.stderr)
        
        # Analyze each directory
        for i, dir_path in enumerate(subdirs, 1):
            self.stats['checked_dirs'] = i
            
            # Show progress
            if i % 50 == 0 or i == len(subdirs):
                print(f"\rProgress: {i}/{len(subdirs)} checked, "
                      f"{self.stats['sabnzbd_dirs']} SABnzbd found, "
                      f"{self.stats['bittorrent_dirs']} BitTorrent skipped...", 
                      end='', file=sys.stderr)
                      
            # Check if BitTorrent
            if self.is_bittorrent_directory(dir_path):
                self.stats['bittorrent_dirs'] += 1
                continue
                
            # Analyze for SABnzbd
            is_sabnzbd, score, indicators = self.analyze_directory(dir_path)
            
            if is_sabnzbd:
                sabnzbd_dirs.append((dir_path, score))
                self.stats['sabnzbd_dirs'] += 1
                
        # Clear progress line
        print(f"\rProgress: {len(subdirs)}/{len(subdirs)} checked, "
              f"{self.stats['sabnzbd_dirs']} SABnzbd found, "
              f"{self.stats['bittorrent_dirs']} BitTorrent skipped - Complete!", 
              file=sys.stderr)
        
        if self.stats['permission_denied'] > 0:
            print(f"Skipped {self.stats['permission_denied']} directories due to permission errors", 
                  file=sys.stderr)
        print(file=sys.stderr)
        
        return sabnzbd_dirs

def get_dir_size(path: Path) -> int:
    """Get directory size in bytes using cross-platform Python approach"""
    try:
        total_size = 0
        for dirpath, dirnames, filenames in os.walk(path):
            for filename in filenames:
                try:
                    file_path = os.path.join(dirpath, filename)
                    # Use lstat to avoid following symlinks
                    total_size += os.lstat(file_path).st_size
                except (OSError, FileNotFoundError):
                    # Skip files that can't be accessed
                    continue
        return total_size
    except (OSError, PermissionError):
        return 0

def bytes_to_human(bytes_val: int) -> str:
    """Convert bytes to human readable format"""
    for unit in ['B', 'K', 'M', 'G', 'T']:
        if bytes_val < 1024:
            return f"{bytes_val}{unit}"
        bytes_val //= 1024
    return f"{bytes_val}P"

def is_non_interactive() -> bool:
    """Detect if running in non-interactive environment (cron, etc.).
    
    Returns:
        True if non-interactive, False otherwise
    """
    # Check if stdin is not a TTY (common in cron jobs)
    if not sys.stdin.isatty():
        return True
        
    # Check for common non-interactive environment variables
    non_interactive_vars = ['CRON', 'CI', 'AUTOMATED', 'NON_INTERACTIVE']
    for var in non_interactive_vars:
        if os.environ.get(var):
            return True
            
    # Check if TERM is not set or is 'dumb' (common in automated environments)
    term = os.environ.get('TERM', '')
    if not term or term == 'dumb':
        return True
        
    return False

def read_global_config_bool(var_name: str, default: bool = False) -> bool:
    """Read a boolean environment variable with support for .env files.
    
    Args:
        var_name: Name of the environment variable
        default: Default value if not found
        
    Returns:
        Boolean value of the environment variable
    """
    # Check environment variable directly
    value = os.environ.get(var_name)
    if value is not None:
        return value.lower() in ('true', '1', 'yes', 'on')
    
    # Check local .env file
    env_file = '.env'
    if os.path.exists(env_file):
        try:
            with open(env_file, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line.startswith(f'{var_name}='):
                        value = line.split('=', 1)[1].strip()
                        return value.lower() in ('true', '1', 'yes', 'on')
        except (IOError, OSError):
            pass
    
    # Check global .env file
    global_env_path = Path.home() / '.media-library-tools' / '.env'
    if global_env_path.exists():
        try:
            with open(global_env_path, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line.startswith(f'{var_name}='):
                        value = line.split('=', 1)[1].strip()
                        return value.lower() in ('true', '1', 'yes', 'on')
        except (IOError, OSError):
            pass
    
    return default

def acquire_lock() -> Optional[int]:
    """Acquire a file lock to prevent multiple instances.
    
    Returns:
        File descriptor if lock acquired, None if already locked
    """
    lock_file_path = os.path.join(tempfile.gettempdir(), 'sabnzbd_cleanup.lock')
    
    try:
        lock_fd = os.open(lock_file_path, os.O_CREAT | os.O_WRONLY | os.O_TRUNC)
        fcntl.flock(lock_fd, fcntl.LOCK_EX | fcntl.LOCK_NB)
        
        # Write PID to lock file
        os.write(lock_fd, str(os.getpid()).encode())
        os.fsync(lock_fd)
        
        return lock_fd
    except (OSError, IOError):
        return None

def release_lock(lock_fd: Optional[int]) -> None:
    """Release the file lock.
    
    Args:
        lock_fd: File descriptor from acquire_lock()
    """
    if lock_fd is not None:
        try:
            fcntl.flock(lock_fd, fcntl.LOCK_UN)
            os.close(lock_fd)
        except (OSError, IOError):
            pass  # Lock file may have been removed

def parse_size_threshold(size_str: str) -> int:
    """Parse size threshold string (e.g., '50G', '2T') to bytes.
    
    Args:
        size_str: Size string with unit (B, K, M, G, T)
        
    Returns:
        Size in bytes
        
    Raises:
        ValueError: If size string is invalid
    """
    if not size_str:
        raise ValueError("Size threshold cannot be empty")
        
    size_str = size_str.upper().strip()
    
    # Extract number and unit
    import re
    match = re.match(r'^(\d+(?:\.\d+)?)([BKMGT]?)$', size_str)
    if not match:
        raise ValueError(f"Invalid size format: {size_str}. Use format like '50G', '2T', '500M'")
        
    number, unit = match.groups()
    number = float(number)
    
    # Convert to bytes
    multipliers = {
        'B': 1,
        'K': 1024,
        'M': 1024 ** 2,
        'G': 1024 ** 3,
        'T': 1024 ** 4
    }
    
    unit = unit or 'B'  # Default to bytes if no unit
    if unit not in multipliers:
        raise ValueError(f"Invalid unit: {unit}. Use B, K, M, G, or T")
        
    return int(number * multipliers[unit])

def validate_args(args: argparse.Namespace) -> Optional[int]:
    """Validate command line arguments.
    
    Args:
        args: Parsed command line arguments
        
    Returns:
        Size threshold in bytes or None if not specified
        
    Raises:
        SystemExit: If arguments are invalid
    """
    # Validate arguments
    if args.prune_at and args.execute:
        print("Error: Cannot use both --execute and --prune-at flags together", file=sys.stderr)
        sys.exit(1)
        
    if args.yes and not (args.execute or args.prune_at):
        print("Warning: -y/--yes flag has no effect without --execute or --prune-at", file=sys.stderr)
    
    # Parse size threshold if provided
    size_threshold_bytes = None
    if args.prune_at:
        try:
            size_threshold_bytes = parse_size_threshold(args.prune_at)
        except ValueError as e:
            print(f"Error: {e}", file=sys.stderr)
            sys.exit(1)
    
    return size_threshold_bytes

def acquire_lock_or_exit(args: argparse.Namespace) -> Optional[int]:
    """Acquire lock or exit if another instance is running.
    
    Args:
        args: Parsed command line arguments
        
    Returns:
        Lock file descriptor or None if not acquired
        
    Raises:
        SystemExit: If another instance is already running and force flag is not set
    """
    # Acquire lock to prevent multiple instances
    if not args.force:
        lock_fd = acquire_lock()
        if lock_fd is None:
            print("Another instance of sabnzbd_cleanup is already running.", file=sys.stderr)
            print("Use --force to override this check.", file=sys.stderr)
            sys.exit(1)
    else:
        lock_fd = None
    
    return lock_fd

def print_header(args: argparse.Namespace, search_path: Path) -> None:
    """Print the header information.
    
    Args:
        args: Parsed command line arguments
        search_path: Path being searched
    """
    # Print header (without banner-style header)
    print(f"Searching in: {search_path}")
    # Handle dry-run/execute logic
    if args.execute:
        dry_run_mode = False
    else:
        dry_run_mode = args.dry_run  # This is True by default
    
    if dry_run_mode:
        print("DRY-RUN MODE: No changes will be made")
    else:
        print("EXECUTE MODE: Directories will be deleted")
    if args.debug:
        print("Debug: ENABLED (showing all directory analysis)")
    elif args.verbose:
        print("Verbose: ENABLED")
    print()

def calculate_sizes(sabnzbd_dirs: List[Tuple[Path, int]]) -> Tuple[int, List[Tuple[Path, int, int]]]:
    """Calculate sizes for all SABnzbd directories.
    
    Args:
        sabnzbd_dirs: List of (Path, score) tuples
        
    Returns:
        Tuple of (total_bytes, dir_info) where dir_info is a list of (Path, size, score) tuples
    """
    # Calculate sizes and display
    total_bytes = 0
    dir_info = []
    
    print("Calculating sizes...")
    for i, (dir_path, score) in enumerate(sabnzbd_dirs, 1):
        size = get_dir_size(dir_path)
        total_bytes += size
        dir_info.append((dir_path, size, score))
        print(f"\rCalculating sizes... {i}/{len(sabnzbd_dirs)}", end='')
        
    print("\rCalculating sizes... Complete!")
    print()
    
    return total_bytes, dir_info

def display_results(args: argparse.Namespace, sabnzbd_dirs: List[Tuple[Path, int]], 
                   dir_info: List[Tuple[Path, int, int]]) -> None:
    """Display the results of the SABnzbd directory detection.
    
    Args:
        args: Parsed command line arguments
        sabnzbd_dirs: List of (Path, score) tuples
        dir_info: List of (Path, size, score) tuples
    """
    # Display results
    for dir_path, size, score in dir_info:
        size_human = bytes_to_human(size)
        print(f"{size_human:>8}  {dir_path.name}")
        if args.verbose:
            print(f"          Score: {score}")
            
    print()
    print("=" * 50)

def handle_prune_at(args: argparse.Namespace, total_bytes: int, size_threshold_bytes: int, 
                  dir_info: List[Tuple[Path, int, int]]) -> bool:
    """Handle the --prune-at logic.
    
    Args:
        args: Parsed command line arguments
        total_bytes: Total size in bytes of all directories
        size_threshold_bytes: Threshold size in bytes for pruning
        dir_info: List of (Path, size, score) tuples
        
    Returns:
        True if pruning was handled, False otherwise
    """
    if total_bytes > size_threshold_bytes:
        print(f"Total size ({bytes_to_human(total_bytes)}) exceeds threshold ({bytes_to_human(size_threshold_bytes)})")
        print("Auto-pruning enabled - proceeding with deletion...")
        print("WARNING: This will permanently delete these directories!")
        
        # Handle confirmation for prune-at
        if not args.yes and not is_non_interactive():
            try:
                response = input("Do you want to proceed with auto-pruning? [y/N]: ")
            except (EOFError, KeyboardInterrupt):
                print("\nAuto-pruning cancelled.")
                sys.exit(1)
            
            if response.lower() not in ['y', 'yes']:
                print("Auto-pruning cancelled.")
                sys.exit(0)
        else:
            if args.yes:
                print("Proceeding with auto-pruning (--yes flag)...")
            else:
                print("Proceeding with auto-pruning (non-interactive environment)...")
        
        # Perform deletion
        print("\nDeleting directories...")
        deleted = 0
        freed = 0
        
        for dir_path, size, _ in dir_info:
            try:
                print(f"  Deleting: {dir_path.name} ({bytes_to_human(size)})")
                shutil.rmtree(dir_path)
                print(f"    ✅ Deleted successfully")
                deleted += 1
                freed += size
            except Exception as e:
                print(f"    ❌ Failed: {e}", file=sys.stderr)
                
        print()
        print(f"Auto-pruned {deleted}/{len(dir_info)} directories")
        print(f"Space freed: {bytes_to_human(freed)}")
        return True
    else:
        print(f"Total size ({bytes_to_human(total_bytes)}) is below threshold ({bytes_to_human(size_threshold_bytes)})")
        print("No pruning needed.")
        return False

def handle_delete(args: argparse.Namespace, dir_info: List[Tuple[Path, int, int]]) -> bool:
    """Handle the --delete logic.
    
    Args:
        args: Parsed command line arguments
        dir_info: List of (Path, size, score) tuples
        
    Returns:
        True if deletion was confirmed and handled, False if cancelled
    """
    print("WARNING: This will permanently delete these directories!")
    
    # Handle confirmation based on flags and environment
    if args.yes or is_non_interactive():
        response = 'yes'
        if args.yes:
            print("Proceeding with deletion (--yes flag)...")
        else:
            print("Proceeding with deletion (non-interactive environment)...")
    else:
        try:
            response = input("Are you sure? [y/N]: ")
        except (EOFError, KeyboardInterrupt):
            print("\nDeletion cancelled.")
            sys.exit(1)
    
    if response.lower() in ['y', 'yes']:
        print("\nDeleting directories...")
        deleted = 0
        freed = 0
        
        for dir_path, size, _ in dir_info:
            try:
                print(f"  Deleting: {dir_path.name} ({bytes_to_human(size)})")
                shutil.rmtree(dir_path)
                print(f"    ✅ Deleted successfully")
                deleted += 1
                freed += size
            except Exception as e:
                print(f"    ❌ Failed: {e}", file=sys.stderr)
                
        print()
        print(f"Deleted {deleted}/{len(dir_info)} directories")
        print(f"Space freed: {bytes_to_human(freed)}")
        return True
    else:
        print("Deletion cancelled.")
        return False

def main():
    parser = argparse.ArgumentParser(
        description=f'SABnzbd Directory Cleanup Script v{VERSION}',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s /downloads                    # List SABnzbd dirs (dry-run mode, default)
  %(prog)s /downloads --execute          # Delete SABnzbd dirs (interactive)
  %(prog)s /downloads --execute -y       # Delete SABnzbd dirs (non-interactive)
  %(prog)s /downloads --prune-at 50G     # Auto-delete if total > 50GB
  %(prog)s /downloads --verbose          # Show detailed detection info
  %(prog)s /downloads --debug            # Show all scoring details
  %(prog)s /downloads --delete           # Backward compatibility: same as --execute
  
Cron Usage:
  # Run every hour to clean up downloads non-interactively
  0 * * * * /path/to/sabnzbd_cleanup /downloads --execute -y
  
  # Auto-prune when downloads exceed 100GB
  0 */6 * * * /path/to/sabnzbd_cleanup /downloads --prune-at 100G
        """
    )
    
    parser.add_argument('path', nargs='?', default='.',
                      help='Directory to search (default: current directory)')
    parser.add_argument('--dry-run', action='store_true', default=True,
                      help='Show what would be done without making changes (default: true)')
    parser.add_argument('--execute', '--delete', action='store_true',
                      help='Actually delete found directories (overrides --dry-run)')
    parser.add_argument('-y', '--yes', action='store_true',
                      help='Skip confirmation prompt (for non-interactive use)')
    parser.add_argument('--prune-at', metavar='SIZE',
                      help='Auto-delete when total size exceeds threshold (e.g., 50G, 2T)')
    parser.add_argument('--verbose', '-v', action='store_true',
                      help='Show verbose output')
    parser.add_argument('--debug', action='store_true',
                      help='Show detailed debug output for all directories')
    parser.add_argument('--no-banner', action='store_true',
                      help='Suppress banner display')
    parser.add_argument('--version', action='version', 
                      version=f'%(prog)s v{VERSION}')
    parser.add_argument('--force', action='store_true',
                      help='Force execution even if another instance is running')
    
    args = parser.parse_args()
    
    # Read global configuration
    auto_execute = read_global_config_bool('AUTO_EXECUTE', False)
    auto_confirm = read_global_config_bool('AUTO_CONFIRM', False)
    quiet_mode = read_global_config_bool('QUIET_MODE', False)
    
    # Apply global configuration (CLI arguments take precedence)
    if auto_execute and not args.execute and not args.prune_at:
        args.execute = True  # Set execute flag if AUTO_EXECUTE is set and no action specified
    if auto_confirm and not args.yes:
        args.yes = True  # Set yes flag if AUTO_CONFIRM is set
    
    # For backward compatibility, map --delete to execute mode
    # The argparse --execute/--delete are aliases, so args.execute will be True for both
    
    # Validate arguments
    size_threshold_bytes = validate_args(args)
    
    # Acquire lock
    lock_fd = acquire_lock_or_exit(args)
    
    try:
        # Convert path to Path object
        search_path = Path(args.path).resolve()
        
        if not search_path.exists():
            print(f"Error: Directory '{search_path}' does not exist", file=sys.stderr)
            sys.exit(1)
            
        if not search_path.is_dir():
            print(f"Error: '{search_path}' is not a directory", file=sys.stderr)
            sys.exit(1)
            
        # Display banner
        display_banner("sabnzbd_cleanup", VERSION, 
                      "detect and clean up orphaned SABnzbd directories",
                      args.no_banner, quiet_mode)
        
        # Print header
        print_header(args, search_path)
        
        # Find SABnzbd directories
        detector = SABnzbdDetector(verbose=args.verbose, debug=args.debug)
        detector.lock_file = lock_fd
        sabnzbd_dirs = detector.find_sabnzbd_directories(search_path)
        
        if not sabnzbd_dirs:
            if args.verbose:
                print("No SABnzbd directories found.")
                print("\nPossible reasons:")
                print("  - No SABnzbd temporary files in this location")
                print("  - All downloads completed successfully")
                print("  - SABnzbd directories were already cleaned up")
                print("\nTry --verbose or --debug for more details")
            sys.exit(0)
            
        # Sort by score (highest first) for display
        sabnzbd_dirs.sort(key=lambda x: x[1], reverse=True)
        
        print(f"Found {len(sabnzbd_dirs)} SABnzbd directories:")
        print("=" * 50)
        print()
        
        # Calculate sizes
        total_bytes, dir_info = calculate_sizes(sabnzbd_dirs)
        
        # Display results
        display_results(args, sabnzbd_dirs, dir_info)
        
        print(f"Total: {bytes_to_human(total_bytes)} across {len(sabnzbd_dirs)} directories")
        print()
        
        # Handle --prune-at logic
        if args.prune_at:
            handled = handle_prune_at(args, total_bytes, size_threshold_bytes, dir_info)
        elif args.execute:
            handled = handle_delete(args, dir_info)
        else:
            print("To delete these directories, run with --execute")
            print("Recommendation: Stop SABnzbd before deleting")
    
    finally:
        # Always release the lock
        release_lock(lock_fd)

if __name__ == '__main__':
    main()
