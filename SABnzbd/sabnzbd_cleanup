#!/usr/bin/env python3
"""
SABnzbd Directory Cleanup Script
Version: 2.0 (Python rewrite)
Purpose: Safely identify and remove SABnzbd temporary/incomplete directories
"""

import os
import sys
import argparse
import subprocess
import re
from pathlib import Path
from typing import List, Tuple, Dict, Optional
import shutil


# ======================================================

# ======================================================
# INJECTED MODULE - START
# Generated by build.py v3.0.0
# Source: utils.py
# ======================================================

"""
Shared Utility Module for Media Library Tools

This module provides backward compatibility by re-exporting functions from the
new modular library structure. New development should use the lib/ modules directly.

DEPRECATED: This module is maintained for backward compatibility only.
New tools should use the modular lib/ structure:
- lib/core.py: Essential utilities (locking, config, platform detection)
- lib/ui.py: User interface functions (banners, formatting, confirmations)
- lib/filesystem.py: File operations
- lib/validation.py: Input validation and error handling

Author: Media Library Tools Project
Version: 1.0.0
"""

import warnings
from pathlib import Path
import sys

# Add lib directory to path for imports
lib_path = Path(__file__).parent / "lib"
if str(lib_path) not in sys.path:
    sys.path.insert(0, str(lib_path))

# Import all functions from modular libraries
try:
    from core import (
        is_non_interactive,
        read_global_config_bool,
        is_windows,
        should_use_emojis,
        FileLock,
        acquire_lock,
        release_lock,
    )
    from ui import (
        display_banner,
        format_size,
        confirm_action,
        format_status_message,
    )
    from filesystem import (
        get_directory_size,
        validate_directory_path,
    )
    from validation import (
        validate_path_argument,
    )
except ImportError as e:
    # Fallback warning if lib modules are not available
    warnings.warn(f"Could not import from lib modules: {e}. Using legacy implementations.", 
                  DeprecationWarning, stacklevel=2)
    
    # Keep legacy implementations as fallback
    import contextlib
    import os
    import platform
    import tempfile
    from typing import Optional, Tuple

    # Platform-specific imports
    try:
        import fcntl  # Unix/Linux/macOS
    except ImportError:
        fcntl = None  # Windows

    try:
        import msvcrt  # Windows
    except ImportError:
        msvcrt = None  # Unix/Linux/macOS

    # Legacy function implementations (fallback only)
    def display_banner(
        script_name: str,
        version: str,
        description: str,
        no_banner_flag: bool = False,
        quiet_mode: bool = False,
    ) -> None:
        """
        Display standardized banner for media library tools.

        Args:
            script_name: Name of the script
            version: Version string
            description: Brief description of the script
            no_banner_flag: If True, suppress banner display
            quiet_mode: If True, suppress banner display
        """
        # Check suppression conditions (highest to lowest priority)
        if no_banner_flag or quiet_mode or is_non_interactive():
            return

        try:
            # Display standardized ASCII art
            print("┏┳┓┏━╸╺┳┓╻┏━┓╻  ╻┏┓ ┏━┓┏━┓┏━┓╻ ╻╺┳╸┏━┓┏━┓╻  ┏━┓")
            print("┃┃┃┣╸  ┃┃┃┣━┫┃  ┃┣┻┓┣┳┛┣━┫┣┳┛┗┳┛ ┃ ┃ ┃┃ ┃┃  ┗━┓")
            print("╹ ╹┗━╸╺┻┛╹╹ ╹┗━╸╹┗━┛╹┗╸╹ ╹╹┗╸ ╹  ╹ ┗━┛┗━┛┗━╸┗━┛")
            print(f"{script_name} v{version}: {description}")
            print()  # Blank line for separation
        except Exception:
            # Banner display errors should not prevent script execution
            pass

    def is_non_interactive() -> bool:
        """
        Detect if running in non-interactive environment (cron, etc.).

        Returns:
            True if non-interactive, False otherwise
        """
        # Check if stdin is not a TTY (common in cron jobs)
        if not sys.stdin.isatty():
            return True

        # Check for common non-interactive environment variables
        non_interactive_vars = ["CRON", "CI", "AUTOMATED", "NON_INTERACTIVE"]
        for var in non_interactive_vars:
            if os.environ.get(var):
                return True

        # Check if TERM is not set or is 'dumb' (common in automated environments)
        term = os.environ.get("TERM", "")
        return bool(not term or term == "dumb")

    def read_global_config_bool(var_name: str, default: bool = False) -> bool:
        """
        Read a boolean environment variable with support for .env files.

        Args:
            var_name: Name of the environment variable
            default: Default value if not found

        Returns:
            Boolean value of the environment variable
        """
        # Check environment variable directly
        value = os.environ.get(var_name)
        if value is not None:
            return value.lower() in ("true", "1", "yes", "on")

        # Check local .env file
        env_file = ".env"
        if os.path.exists(env_file):
            try:
                with open(env_file) as f:
                    for line in f:
                        line = line.strip()
                        if line.startswith(f"{var_name}="):
                            value = line.split("=", 1)[1].strip()
                            return value.lower() in ("true", "1", "yes", "on")
            except OSError:
                pass

        # Check global .env file
        global_env_path = Path.home() / ".media-library-tools" / ".env"
        if global_env_path.exists():
            try:
                with open(global_env_path) as f:
                    for line in f:
                        line = line.strip()
                        if line.startswith(f"{var_name}="):
                            value = line.split("=", 1)[1].strip()
                            return value.lower() in ("true", "1", "yes", "on")
            except OSError:
                pass

        return default

    def is_windows() -> bool:
        """
        Detect if running on Windows platform.

        Returns:
            True if running on Windows, False otherwise
        """
        return platform.system().lower() == "windows"

    def should_use_emojis() -> bool:
        """
        Determine if emojis should be used based on platform and environment.

        Returns:
            True if emojis should be used, False otherwise
        """
        # Don't use emojis on Windows to avoid encoding issues
        if is_windows():
            return False

        # Don't use emojis in non-interactive environments
        if is_non_interactive():
            return False

        # Check for explicit emoji suppression
        return not read_global_config_bool("NO_EMOJIS", False)

    def format_size(size_bytes: int) -> str:
        """
        Format size in bytes to human readable format.

        Args:
            size_bytes: Size in bytes

        Returns:
            Human readable size string
        """
        for unit in ["B", "K", "M", "G", "T"]:
            if size_bytes < 1024.0:
                if unit == "B":
                    return f"{size_bytes:.0f}{unit}"
                else:
                    return f"{size_bytes:.1f}{unit}"
            size_bytes /= 1024.0
        return f"{size_bytes:.1f}P"

    def confirm_action(message: str, skip_confirmation: bool = False) -> bool:
        """
        Ask for user confirmation unless skipped.

        Args:
            message: Confirmation message to display
            skip_confirmation: If True, automatically confirm

        Returns:
            True if confirmed, False otherwise
        """
        if skip_confirmation:
            return True

        try:
            response = input(f"{message} (y/N): ").strip().lower()
            return response in ["y", "yes"]
        except (EOFError, KeyboardInterrupt):
            print("\nOperation cancelled.")
            return False

    class FileLock:
        """
        File locking utility class for preventing concurrent executions.
        """

        def __init__(self, lock_prefix: str = "media_library_tool"):
            """
            Initialize file lock.

            Args:
                lock_prefix: Prefix for lock file name
            """
            self.lock_prefix = lock_prefix
            self.lock_file = None

        def acquire_lock(self, force: bool = False) -> bool:
            """
            Acquire file lock to prevent multiple instances.

            Args:
                force: If True, skip locking mechanism

            Returns:
                True if lock acquired successfully, False otherwise
            """
            if force:
                return True

            try:
                with tempfile.NamedTemporaryFile(
                    mode="w", prefix=f"{self.lock_prefix}_", suffix=".lock", delete=False
                ) as temp_file:
                    self.lock_file = temp_file

                    # Platform-specific file locking
                    if fcntl is not None:  # Unix/Linux/macOS
                        fcntl.flock(self.lock_file.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
                    elif msvcrt is not None:  # Windows
                        msvcrt.locking(self.lock_file.fileno(), msvcrt.LK_NBLCK, 1)
                    else:
                        # Fallback: no locking available, just proceed
                        pass

                    self.lock_file.write(str(os.getpid()))
                    self.lock_file.flush()
                return True
            except OSError as e:
                if self.lock_file:
                    self.lock_file.close()
                    with contextlib.suppress(OSError):
                        os.unlink(self.lock_file.name)
                    self.lock_file = None
                print(
                    "Error: Another instance is already running. Use --force to override."
                )
                print(f"Lock error: {e}")
                return False

        def release_lock(self) -> None:
            """
            Release the file lock.
            """
            if self.lock_file:
                try:
                    # Only unlock if file is still open
                    if not self.lock_file.closed:
                        # Platform-specific file unlocking
                        if fcntl is not None:  # Unix/Linux/macOS
                            fcntl.flock(self.lock_file.fileno(), fcntl.LOCK_UN)
                        elif msvcrt is not None:  # Windows
                            msvcrt.locking(self.lock_file.fileno(), msvcrt.LK_UNLCK, 1)
                        # No explicit unlock needed for fallback case

                        self.lock_file.close()
                except (OSError, ValueError):
                    # Handle both file system errors and closed file errors
                    pass

                # Always try to remove lock file if it exists
                try:
                    if os.path.exists(self.lock_file.name):
                        os.unlink(self.lock_file.name)
                except OSError:
                    pass
                finally:
                    self.lock_file = None

    # Legacy standalone functions for backward compatibility
    def acquire_lock(
        lock_prefix: str = "media_library_tool", force: bool = False
    ) -> Tuple[bool, Optional[FileLock]]:
        """
        Legacy function for acquiring file locks.

        Args:
            lock_prefix: Prefix for lock file name
            force: If True, skip locking mechanism

        Returns:
            Tuple of (success: bool, lock_instance: FileLock or None)
        """
        lock = FileLock(lock_prefix)
        success = lock.acquire_lock(force)
        return success, lock if success else None

    def release_lock(lock_instance: FileLock) -> None:
        """
        Legacy function for releasing file locks.

        Args:
            lock_instance: FileLock instance to release
        """
        if lock_instance:
            lock_instance.release_lock()

    def format_status_message(
        message: str, emoji: str = "", fallback_prefix: str = ""
    ) -> str:
        """
        Format a status message with emoji on supported platforms or fallback text.

        Args:
            message: The main message text
            emoji: The emoji to use on supported platforms
            fallback_prefix: Text prefix to use instead of emoji on unsupported platforms

        Returns:
            Formatted message string
        """
        if should_use_emojis() and emoji:
            return f"{emoji} {message}"
        elif fallback_prefix:
            return f"{fallback_prefix}: {message}"
        else:
            return message

    # Add any missing functions that might be needed for backward compatibility
    def get_directory_size(path: str) -> int:
        """Legacy fallback for directory size calculation."""
        total_size = 0
        try:
            for dirpath, dirnames, filenames in os.walk(path):
                for filename in filenames:
                    filepath = os.path.join(dirpath, filename)
                    try:
                        total_size += os.path.getsize(filepath)
                    except (OSError, IOError):
                        continue
        except (OSError, IOError):
            pass
        return total_size

    def validate_directory_path(path: str) -> Tuple[bool, str]:
        """Legacy fallback for directory path validation."""
        if not path:
            return False, "Path cannot be empty"
        
        path_obj = Path(path)
        
        if not path_obj.exists():
            return False, f"Path does not exist: {path}"
        
        if not path_obj.is_dir():
            return False, f"Path is not a directory: {path}"
        
        return True, ""

    def validate_path_argument(path: str) -> Tuple[bool, str]:
        """Legacy fallback for path argument validation."""
        return validate_directory_path(path)


# ======================================================
# INJECTED MODULE - END
# Source: utils.py
# ======================================================



# ======================================================


VERSION = "2.2"

# Precompiled patterns for module-level functions
SIZE_PATTERN = re.compile(r'^(\d+(?:\.\d+)?)([BKMGT]?)$')



class SABnzbdDetector:
    def __init__(self, verbose=False, debug=False):
        self.verbose = verbose
        self.debug = debug
        self.file_lock = FileLock('sabnzbd_cleanup')
        self.stats = {
            'total_dirs': 0,
            'checked_dirs': 0,
            'sabnzbd_dirs': 0,
            'bittorrent_dirs': 0,
            'permission_denied': 0
        }
        
        # Precompiled regex patterns for performance optimization
        self.tv_show_pattern = re.compile(r'S\d+E\d+.*\.\d+$')
        
        # File pattern sets for efficient checking
        self.bittorrent_extensions = {'.torrent', '.resume', '.fastresume', '.!ut', '.dat'}
        self.bittorrent_name_patterns = {'torrent', 'bt_', 'bittorrent'}
        self.admin_files = {'__admin__', 'SABnzbd_nzf', 'SABnzbd_nzo'}
        self.usenet_name_patterns = {'par2', 'yEnc', 'nzb'}
        self.retry_suffixes = {'.1', '.2', '.3', '.4', '.5'}
        
    def log_verbose(self, msg):
        if self.verbose or self.debug:
            print(f"[VERBOSE] {msg}", file=sys.stderr)
    
    def log_debug(self, msg):
        if self.debug:
            print(f"[DEBUG] {msg}", file=sys.stderr)
    
    def is_bittorrent_directory(self, dir_path: Path) -> bool:
        """Check if directory appears to be a BitTorrent download"""
        try:
            indicators = []
            dirname = dir_path.name
            
            # Single pass through directory to check for BitTorrent files
            try:
                files = list(dir_path.iterdir())
                file_extensions = {f.suffix for f in files if f.is_file()}
                
                # Check for BitTorrent file extensions using set intersection
                if self.bittorrent_extensions & file_extensions:
                    matching_extensions = self.bittorrent_extensions & file_extensions
                    indicators.append(f"BitTorrent files: {', '.join(matching_extensions)}")
                    
            except (PermissionError, OSError):
                pass  # Continue with other checks if file listing fails
                    
            # Check directory name for BitTorrent patterns
            dirname_lower = dirname.lower()
            if any(pattern in dirname_lower for pattern in self.bittorrent_name_patterns):
                indicators.append("BitTorrent naming")
                
            if indicators:
                self.log_verbose(f"  BitTorrent indicators in {dirname}: {', '.join(indicators)}")
                return True
            return False
        except PermissionError:
            # If we can't check, assume it's not BitTorrent
            return False
    
    def analyze_directory(self, dir_path: Path) -> Tuple[bool, int, List[str]]:
        """
        Analyze a directory to determine if it's a SABnzbd directory
        Returns: (is_sabnzbd, score, indicators)
        """
        dirname = dir_path.name
        indicators = []
        score = 0
        
        self.log_debug(f"Analyzing: {dir_path}")
        
        # Check if we can access the directory
        try:
            # Try to list directory contents to check permissions
            list(dir_path.iterdir())
        except PermissionError:
            self.log_debug(f"  → Skipping: Permission denied")
            self.stats['permission_denied'] += 1
            return False, 0, []
        except Exception as e:
            self.log_debug(f"  → Skipping: Error accessing directory: {e}")
            return False, 0, []
        
        # First check: Is this BitTorrent?
        if self.is_bittorrent_directory(dir_path):
            self.log_debug(f"  → Skipping: BitTorrent directory")
            return False, 0, []
        
        # Check for SABnzbd admin files (HIGHEST confidence) using set-based checking
        try:
            existing_files = {f.name for f in dir_path.iterdir() if f.is_file()}
            admin_matches = self.admin_files & existing_files
            if admin_matches:
                for admin_file in admin_matches:
                    indicators.append(f"SABnzbd file: {admin_file}")
                    score += 15
        except (PermissionError, OSError):
            # Fall back to individual checks if directory listing fails
            for admin_file in self.admin_files:
                try:
                    if (dir_path / admin_file).exists():
                        indicators.append(f"SABnzbd file: {admin_file}")
                        score += 15
                except PermissionError:
                    pass  # Skip if we can't check
        
        # Single-pass file system scan for optimal performance
        nzb_files = []
        par2_files = []
        rar_files = []
        has_nzb_files = False
        has_par2_files = False
        has_unpack_subdir = False
        
        try:
            # Single directory iteration to categorize all files and subdirectories
            for item in dir_path.iterdir():
                try:
                    if item.is_file():
                        file_suffix = item.suffix.lower()
                        file_name = item.name.lower()
                        
                        # Categorize files by extension in single pass
                        if file_suffix == '.nzb':
                            nzb_files.append(item)
                        elif file_suffix == '.par2':
                            par2_files.append(item)
                        elif file_suffix == '.rar':
                            if len(rar_files) < 100:  # Limit to prevent memory issues
                                rar_files.append(item)
                        elif file_suffix.startswith('.r') and len(file_suffix) == 4:
                            # Check for .r00, .r01 etc pattern
                            if file_suffix[2:].isdigit() and len(rar_files) < 150:
                                rar_files.append(item)
                                
                    elif item.is_dir():
                        # Check for unpack directories while we're iterating
                        if '_UNPACK_' in item.name or 'EXTRACT_' in item.name:
                            has_unpack_subdir = True
                            
                except (PermissionError, OSError):
                    continue  # Skip inaccessible items
                    
            # Check one level deeper for PAR2 files (limited search)
            try:
                for subdir in dir_path.iterdir():
                    if subdir.is_dir() and len(par2_files) < 100:
                        try:
                            for sub_item in subdir.iterdir():
                                if sub_item.is_file() and sub_item.suffix.lower() == '.par2':
                                    par2_files.append(sub_item)
                                    if len(par2_files) >= 100:
                                        break
                        except (PermissionError, OSError):
                            continue
                        if len(par2_files) >= 100:
                            break
            except (PermissionError, OSError):
                pass
                
        except (PermissionError, OSError):
            # If we can't scan the directory, fall back to original glob-based approach
            try:
                nzb_files = list(dir_path.glob('*.nzb'))
                par2_files = list(dir_path.glob('*.par2'))
                par2_files.extend(list(dir_path.glob('*/*.par2'))[:100])
                rar_files = list(dir_path.glob('*.rar'))[:100]
                rar_files.extend(list(dir_path.glob('*.r[0-9][0-9]'))[:50])
            except (PermissionError, OSError):
                pass  # If all fails, continue with empty lists
        
        # Set flags based on found files
        has_nzb_files = len(nzb_files) > 0
        has_par2_files = len(par2_files) > 0
        
        # Process results and update score
        if has_nzb_files:
            indicators.append(f"NZB files ({len(nzb_files)})")
            score += 10
            
        if has_par2_files:
            indicators.append(f"PAR2 files ({len(par2_files)})")
            score += 6
            if len(par2_files) > 3:
                score += 3
                
        if rar_files:
            # RAR with PAR2 or NZB = strong indicator
            if has_par2_files:
                indicators.append(f"RAR files ({len(rar_files)}) with PAR2")
                score += 6
            elif has_nzb_files:
                indicators.append(f"RAR files ({len(rar_files)}) with NZB")
                score += 6
            elif len(rar_files) > 10:
                indicators.append(f"Many RAR files ({len(rar_files)})")
                score += 2
                
        # Add unpack directory score if found during scan
        if has_unpack_subdir:
            indicators.append("SABnzbd unpack directory")
            score += 12
                
        # Check directory name patterns
        # Pattern 1: ends with .1, .2, etc (retry pattern) using set lookup
        if dirname[-2:] in self.retry_suffixes:
            indicators.append("Retry suffix (.N)")
            score += 5
            
        # Pattern 2: Contains par2/yEnc/nzb in name using set-based checking
        if any(pattern in dirname for pattern in self.usenet_name_patterns):
            indicators.append("Usenet naming pattern")
            score += 6
            
        # Pattern 3: TV show with retry suffix
        if self.tv_show_pattern.search(dirname):
            indicators.append("TV show retry pattern")
            score += 5
            
        # Unpack directory check already handled in single-pass scan above
                
        # Determine threshold using boolean flags instead of locals() checks
        threshold = 10
        
        # Special cases for lower threshold
        if has_nzb_files:
            threshold = 5
            self.log_debug(f"  Threshold lowered to 5 (NZB files present)")
        elif has_par2_files:
            threshold = 8
            self.log_debug(f"  Threshold lowered to 8 (PAR2 files present)")
        elif any(pattern in dirname for pattern in self.usenet_name_patterns) or dirname[-2:] in self.retry_suffixes:
            threshold = 8
            self.log_debug(f"  Threshold lowered to 8 (naming pattern)")
            
        # Override: NZB + PAR2 = definitely SABnzbd (using boolean flags)
        if has_nzb_files and has_par2_files:
            self.log_debug(f"  → OVERRIDE: NZB + PAR2 = definitive SABnzbd")
            return True, score, indicators
            
        # Make decision
        is_sabnzbd = score >= threshold
        
        if self.debug:
            status = "SABnzbd" if is_sabnzbd else "Not SABnzbd"
            print(f"  → {status} (score: {score}, threshold: {threshold})", file=sys.stderr)
            if indicators:
                print(f"    Indicators: {', '.join(indicators)}", file=sys.stderr)
        elif self.verbose and is_sabnzbd:
            print(f"  → SABnzbd directory detected: {dirname}", file=sys.stderr)
            print(f"    Score: {score}, Indicators: {', '.join(indicators)}", file=sys.stderr)
            
        return is_sabnzbd, score, indicators
    
    def find_sabnzbd_directories(self, search_path: Path) -> List[Tuple[Path, int]]:
        """Find all SABnzbd directories in the given path"""
        sabnzbd_dirs = []
        
        print(f"Scanning {search_path}...", file=sys.stderr)
        
        # Get all immediate subdirectories
        try:
            subdirs = [d for d in search_path.iterdir() if d.is_dir()]
        except PermissionError:
            print(f"Error: Permission denied accessing {search_path}", file=sys.stderr)
            return []
            
        self.stats['total_dirs'] = len(subdirs)
        print(f"Found {len(subdirs)} subdirectories to check", file=sys.stderr)
        print(file=sys.stderr)
        
        # Analyze each directory
        for i, dir_path in enumerate(subdirs, 1):
            self.stats['checked_dirs'] = i
            
            # Show progress
            if i % 50 == 0 or i == len(subdirs):
                print(f"\rProgress: {i}/{len(subdirs)} checked, "
                      f"{self.stats['sabnzbd_dirs']} SABnzbd found, "
                      f"{self.stats['bittorrent_dirs']} BitTorrent skipped...", 
                      end='', file=sys.stderr)
                      
            # Check if BitTorrent
            if self.is_bittorrent_directory(dir_path):
                self.stats['bittorrent_dirs'] += 1
                continue
                
            # Analyze for SABnzbd
            is_sabnzbd, score, indicators = self.analyze_directory(dir_path)
            
            if is_sabnzbd:
                sabnzbd_dirs.append((dir_path, score))
                self.stats['sabnzbd_dirs'] += 1
                
        # Clear progress line
        print(f"\rProgress: {len(subdirs)}/{len(subdirs)} checked, "
              f"{self.stats['sabnzbd_dirs']} SABnzbd found, "
              f"{self.stats['bittorrent_dirs']} BitTorrent skipped - Complete!", 
              file=sys.stderr)
        
        if self.stats['permission_denied'] > 0:
            print(f"Skipped {self.stats['permission_denied']} directories due to permission errors", 
                  file=sys.stderr)
        print(file=sys.stderr)
        
        return sabnzbd_dirs

def get_dir_size(path: Path) -> int:
    """Get directory size in bytes using cross-platform Python approach"""
    try:
        total_size = 0
        for dirpath, dirnames, filenames in os.walk(path):
            for filename in filenames:
                try:
                    file_path = os.path.join(dirpath, filename)
                    # Use lstat to avoid following symlinks
                    total_size += os.lstat(file_path).st_size
                except (OSError, FileNotFoundError):
                    # Skip files that can't be accessed
                    continue
        return total_size
    except (OSError, PermissionError):
        return 0

def bytes_to_human(bytes_val: int) -> str:
    """Convert bytes to human readable format"""
    for unit in ['B', 'K', 'M', 'G', 'T']:
        if bytes_val < 1024:
            return f"{bytes_val}{unit}"
        bytes_val //= 1024
    return f"{bytes_val}P"



def acquire_lock() -> Optional[int]:
    """Acquire a file lock to prevent multiple instances.
    
    Returns:
        File descriptor if lock acquired, None if already locked
    """
    lock_file_path = os.path.join(tempfile.gettempdir(), 'sabnzbd_cleanup.lock')
    
    try:
        lock_fd = os.open(lock_file_path, os.O_CREAT | os.O_WRONLY | os.O_TRUNC)
        fcntl.flock(lock_fd, fcntl.LOCK_EX | fcntl.LOCK_NB)
        
        # Write PID to lock file
        os.write(lock_fd, str(os.getpid()).encode())
        os.fsync(lock_fd)
        
        return lock_fd
    except (OSError, IOError):
        return None


def parse_size_threshold(size_str: str) -> int:
    """Parse size threshold string (e.g., '50G', '2T') to bytes.
    
    Args:
        size_str: Size string with unit (B, K, M, G, T)
        
    Returns:
        Size in bytes
        
    Raises:
        ValueError: If size string is invalid
    """
    if not size_str:
        raise ValueError("Size threshold cannot be empty")
        
    size_str = size_str.upper().strip()
    
    # Extract number and unit using precompiled pattern
    match = SIZE_PATTERN.match(size_str)
    if not match:
        raise ValueError(f"Invalid size format: {size_str}. Use format like '50G', '2T', '500M'")
        
    number, unit = match.groups()
    number = float(number)
    
    # Convert to bytes
    multipliers = {
        'B': 1,
        'K': 1024,
        'M': 1024 ** 2,
        'G': 1024 ** 3,
        'T': 1024 ** 4
    }
    
    unit = unit or 'B'  # Default to bytes if no unit
    if unit not in multipliers:
        raise ValueError(f"Invalid unit: {unit}. Use B, K, M, G, or T")
        
    return int(number * multipliers[unit])

def validate_args(args: argparse.Namespace) -> Optional[int]:
    """Validate command line arguments.
    
    Args:
        args: Parsed command line arguments
        
    Returns:
        Size threshold in bytes or None if not specified
        
    Raises:
        SystemExit: If arguments are invalid
    """
    # Validate arguments
    if args.prune_at and args.execute:
        print("Error: Cannot use both --execute and --prune-at flags together", file=sys.stderr)
        sys.exit(1)
        
    if args.yes and not (args.execute or args.prune_at):
        print("Warning: -y/--yes flag has no effect without --execute or --prune-at", file=sys.stderr)
    
    # Parse size threshold if provided
    size_threshold_bytes = None
    if args.prune_at:
        try:
            size_threshold_bytes = parse_size_threshold(args.prune_at)
        except ValueError as e:
            print(f"Error: {e}", file=sys.stderr)
            sys.exit(1)
    
    return size_threshold_bytes

def acquire_lock_or_exit(args: argparse.Namespace) -> Optional[FileLock]:
    """Acquire lock or exit if another instance is running.
    
    Args:
        args: Parsed command line arguments
        
    Returns:
        FileLock instance or None if not acquired
        
    Raises:
        SystemExit: If another instance is already running and force flag is not set
    """
    # Acquire lock to prevent multiple instances
    file_lock = FileLock('sabnzbd_cleanup')
    if not file_lock.acquire_lock(args.force):
        sys.exit(1)
    
    if args.force:
        print("Forcing execution (--force flag provided)")
    
    return file_lock

def print_header(args: argparse.Namespace, search_path: Path) -> None:
    """Print the header information.
    
    Args:
        args: Parsed command line arguments
        search_path: Path being searched
    """
    # Print header (without banner-style header)
    print(f"Searching in: {search_path}")
    # Handle dry-run/execute logic
    if args.execute:
        dry_run_mode = False
    else:
        dry_run_mode = args.dry_run  # This is True by default
    
    if dry_run_mode:
        print("DRY-RUN MODE: No changes will be made")
    else:
        print("EXECUTE MODE: Directories will be deleted")
    if args.debug:
        print("Debug: ENABLED (showing all directory analysis)")
    elif args.verbose:
        print("Verbose: ENABLED")
    print()

def calculate_sizes(sabnzbd_dirs: List[Tuple[Path, int]]) -> Tuple[int, List[Tuple[Path, int, int]]]:
    """Calculate sizes for all SABnzbd directories.
    
    Args:
        sabnzbd_dirs: List of (Path, score) tuples
        
    Returns:
        Tuple of (total_bytes, dir_info) where dir_info is a list of (Path, size, score) tuples
    """
    # Calculate sizes and display
    total_bytes = 0
    dir_info = []
    
    print("Calculating sizes...")
    for i, (dir_path, score) in enumerate(sabnzbd_dirs, 1):
        size = get_dir_size(dir_path)
        total_bytes += size
        dir_info.append((dir_path, size, score))
        print(f"\rCalculating sizes... {i}/{len(sabnzbd_dirs)}", end='')
        
    print("\rCalculating sizes... Complete!")
    print()
    
    return total_bytes, dir_info

def display_results(args: argparse.Namespace, sabnzbd_dirs: List[Tuple[Path, int]], 
                   dir_info: List[Tuple[Path, int, int]]) -> None:
    """Display the results of the SABnzbd directory detection.
    
    Args:
        args: Parsed command line arguments
        sabnzbd_dirs: List of (Path, score) tuples
        dir_info: List of (Path, size, score) tuples
    """
    # Display results
    for dir_path, size, score in dir_info:
        size_human = bytes_to_human(size)
        print(f"{size_human:>8}  {dir_path.name}")
        if args.verbose:
            print(f"          Score: {score}")
            
    print()
    print("=" * 50)

def handle_prune_at(args: argparse.Namespace, total_bytes: int, size_threshold_bytes: int, 
                  dir_info: List[Tuple[Path, int, int]]) -> bool:
    """Handle the --prune-at logic.
    
    Args:
        args: Parsed command line arguments
        total_bytes: Total size in bytes of all directories
        size_threshold_bytes: Threshold size in bytes for pruning
        dir_info: List of (Path, size, score) tuples
        
    Returns:
        True if pruning was handled, False otherwise
    """
    if total_bytes > size_threshold_bytes:
        print(f"Total size ({bytes_to_human(total_bytes)}) exceeds threshold ({bytes_to_human(size_threshold_bytes)})")
        print("Auto-pruning enabled - proceeding with deletion...")
        print("WARNING: This will permanently delete these directories!")
        
        # Handle confirmation for prune-at
        if not args.yes and not is_non_interactive():
            try:
                response = input("Do you want to proceed with auto-pruning? [y/N]: ")
            except (EOFError, KeyboardInterrupt):
                print("\nAuto-pruning cancelled.")
                sys.exit(1)
            
            if response.lower() not in ['y', 'yes']:
                print("Auto-pruning cancelled.")
                sys.exit(0)
        else:
            if args.yes:
                print("Proceeding with auto-pruning (--yes flag)...")
            else:
                print("Proceeding with auto-pruning (non-interactive environment)...")
        
        # Perform deletion
        print("\nDeleting directories...")
        deleted = 0
        freed = 0
        
        for dir_path, size, _ in dir_info:
            try:
                print(f"  Deleting: {dir_path.name} ({bytes_to_human(size)})")
                shutil.rmtree(dir_path)
                print(f"    ✅ Deleted successfully")
                deleted += 1
                freed += size
            except Exception as e:
                print(f"    ❌ Failed: {e}", file=sys.stderr)
                
        print()
        print(f"Auto-pruned {deleted}/{len(dir_info)} directories")
        print(f"Space freed: {bytes_to_human(freed)}")
        return True
    else:
        print(f"Total size ({bytes_to_human(total_bytes)}) is below threshold ({bytes_to_human(size_threshold_bytes)})")
        print("No pruning needed.")
        return False

def handle_delete(args: argparse.Namespace, dir_info: List[Tuple[Path, int, int]]) -> bool:
    """Handle the --delete logic.
    
    Args:
        args: Parsed command line arguments
        dir_info: List of (Path, size, score) tuples
        
    Returns:
        True if deletion was confirmed and handled, False if cancelled
    """
    print("WARNING: This will permanently delete these directories!")
    
    # Handle confirmation based on flags and environment
    if args.yes or is_non_interactive():
        response = 'yes'
        if args.yes:
            print("Proceeding with deletion (--yes flag)...")
        else:
            print("Proceeding with deletion (non-interactive environment)...")
    else:
        try:
            response = input("Are you sure? [y/N]: ")
        except (EOFError, KeyboardInterrupt):
            print("\nDeletion cancelled.")
            sys.exit(1)
    
    if response.lower() in ['y', 'yes']:
        print("\nDeleting directories...")
        deleted = 0
        freed = 0
        
        for dir_path, size, _ in dir_info:
            try:
                print(f"  Deleting: {dir_path.name} ({bytes_to_human(size)})")
                shutil.rmtree(dir_path)
                print(f"    ✅ Deleted successfully")
                deleted += 1
                freed += size
            except Exception as e:
                print(f"    ❌ Failed: {e}", file=sys.stderr)
                
        print()
        print(f"Deleted {deleted}/{len(dir_info)} directories")
        print(f"Space freed: {bytes_to_human(freed)}")
        return True
    else:
        print("Deletion cancelled.")
        return False

def main():
    parser = argparse.ArgumentParser(
        description=f'SABnzbd Directory Cleanup Script v{VERSION}',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s /downloads                    # List SABnzbd dirs (dry-run mode, default)
  %(prog)s /downloads --execute          # Delete SABnzbd dirs (interactive)
  %(prog)s /downloads --execute -y       # Delete SABnzbd dirs (non-interactive)
  %(prog)s /downloads --prune-at 50G     # Auto-delete if total > 50GB
  %(prog)s /downloads --verbose          # Show detailed detection info
  %(prog)s /downloads --debug            # Show all scoring details
  %(prog)s /downloads --delete           # Backward compatibility: same as --execute
  
Cron Usage:
  # Run every hour to clean up downloads non-interactively
  0 * * * * /path/to/sabnzbd_cleanup /downloads --execute -y
  
  # Auto-prune when downloads exceed 100GB
  0 */6 * * * /path/to/sabnzbd_cleanup /downloads --prune-at 100G
        """
    )
    
    parser.add_argument('path', nargs='?', default='.',
                      help='Directory to search (default: current directory)')
    parser.add_argument('--dry-run', action='store_true', default=True,
                      help='Show what would be done without making changes (default: true)')
    parser.add_argument('--execute', '--delete', action='store_true',
                      help='Actually delete found directories (overrides --dry-run)')
    parser.add_argument('-y', '--yes', action='store_true',
                      help='Skip confirmation prompt (for non-interactive use)')
    parser.add_argument('--prune-at', metavar='SIZE',
                      help='Auto-delete when total size exceeds threshold (e.g., 50G, 2T)')
    parser.add_argument('--verbose', '-v', action='store_true',
                      help='Show verbose output')
    parser.add_argument('--debug', action='store_true',
                      help='Show detailed debug output for all directories')
    parser.add_argument('--no-banner', action='store_true',
                      help='Suppress banner display')
    parser.add_argument('--version', action='version', 
                      version=f'%(prog)s v{VERSION}')
    parser.add_argument('--force', action='store_true',
                      help='Force execution even if another instance is running')
    
    args = parser.parse_args()
    
    # Read global configuration
    auto_execute = read_global_config_bool('AUTO_EXECUTE', False)
    auto_confirm = read_global_config_bool('AUTO_CONFIRM', False)
    quiet_mode = read_global_config_bool('QUIET_MODE', False)
    
    # Apply global configuration (CLI arguments take precedence)
    if auto_execute and not args.execute and not args.prune_at:
        args.execute = True  # Set execute flag if AUTO_EXECUTE is set and no action specified
    if auto_confirm and not args.yes:
        args.yes = True  # Set yes flag if AUTO_CONFIRM is set
    
    # For backward compatibility, map --delete to execute mode
    # The argparse --execute/--delete are aliases, so args.execute will be True for both
    
    # Validate arguments
    size_threshold_bytes = validate_args(args)
    
    # Acquire lock
    lock_fd = acquire_lock_or_exit(args)
    
    try:
        # Convert path to Path object
        search_path = Path(args.path).resolve()
        
        if not search_path.exists():
            print(f"Error: Directory '{search_path}' does not exist", file=sys.stderr)
            sys.exit(1)
            
        if not search_path.is_dir():
            print(f"Error: '{search_path}' is not a directory", file=sys.stderr)
            sys.exit(1)
            
        # Display banner
        display_banner("sabnzbd_cleanup", VERSION, 
                      "detect and clean up orphaned SABnzbd directories",
                      args.no_banner, quiet_mode)
        
        # Print header
        print_header(args, search_path)
        
        # Find SABnzbd directories
        detector = SABnzbdDetector(verbose=args.verbose, debug=args.debug)
        detector.lock_file = lock_fd
        sabnzbd_dirs = detector.find_sabnzbd_directories(search_path)
        
        if not sabnzbd_dirs:
            if args.verbose:
                print("No SABnzbd directories found.")
                print("\nPossible reasons:")
                print("  - No SABnzbd temporary files in this location")
                print("  - All downloads completed successfully")
                print("  - SABnzbd directories were already cleaned up")
                print("\nTry --verbose or --debug for more details")
            sys.exit(0)
            
        # Sort by score (highest first) for display
        sabnzbd_dirs.sort(key=lambda x: x[1], reverse=True)
        
        print(f"Found {len(sabnzbd_dirs)} SABnzbd directories:")
        print("=" * 50)
        print()
        
        # Calculate sizes
        total_bytes, dir_info = calculate_sizes(sabnzbd_dirs)
        
        # Display results
        display_results(args, sabnzbd_dirs, dir_info)
        
        print(f"Total: {bytes_to_human(total_bytes)} across {len(sabnzbd_dirs)} directories")
        print()
        
        # Handle --prune-at logic
        if args.prune_at:
            handled = handle_prune_at(args, total_bytes, size_threshold_bytes, dir_info)
        elif args.execute:
            handled = handle_delete(args, dir_info)
        else:
            print("To delete these directories, run with --execute")
            print("Recommendation: Stop SABnzbd before deleting")
    
    finally:
        # Always release the lock
        if lock_fd:
            lock_fd.release_lock()

if __name__ == '__main__':
    main()
