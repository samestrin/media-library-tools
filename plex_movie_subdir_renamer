#!/usr/bin/env python3
"""
Plex Movie Subdirectory Renamer

A tool for renaming movie featurettes and extras in subdirectories according to
Plex naming conventions. This script processes video files in a subdirectory and
renames them with proper Plex-compatible naming patterns.

Features:
- Renames featurettes with Plex-compatible naming conventions
- Auto-detects movie name from parent directory
- Handles multiple files with sequential numbering
- Categorizes different types of extras (featurettes, deleted scenes, etc.)
- Dry-run mode for safe testing
- Cron-friendly operation with non-interactive detection
- File locking to prevent concurrent executions

Author: Media Library Tools Project
Version: 2.1.0
"""

import argparse
import os
import re
import sys
from pathlib import Path
from typing import Dict, List, Optional, Tuple


# ======================================================
# Modular includes will be injected here by build.py
# ======================================================

# Modular utilities will be injected by build.py
# ======================================================



# ======================================================


# Version constant
VERSION = "2.1.0"


# ======================================================
# INJECTED MODULE - START
# Generated by build.py v3.0.0
# Source: lib/core.py
# ======================================================

"""
Core Utilities Module for Media Library Tools
Version: 1.0

This module contains essential utility functions including:
- Platform detection and environment handling
- Configuration management and global settings
- File locking mechanisms for concurrent execution
- Interactive mode detection for automation support

This is part of the modular library structure that enables selective inclusion
in built tools while maintaining the self-contained principle.
"""

import contextlib
import os
import platform
import sys
import tempfile
from pathlib import Path
from typing import Optional, Tuple

# Platform-specific imports
try:
    import fcntl  # Unix/Linux/macOS
except ImportError:
    fcntl = None  # Windows

try:
    import msvcrt  # Windows
except ImportError:
    msvcrt = None  # Unix/Linux/macOS


def is_non_interactive() -> bool:
    """
    Detect if running in non-interactive environment (cron, etc.).

    Returns:
        True if non-interactive, False otherwise
    """
    # Check if stdin is not a TTY (common in cron jobs)
    if not sys.stdin.isatty():
        return True

    # Check for common non-interactive environment variables
    non_interactive_vars = ["CRON", "CI", "AUTOMATED", "NON_INTERACTIVE"]
    for var in non_interactive_vars:
        if os.environ.get(var):
            return True

    # Check if TERM is not set or is 'dumb' (common in automated environments)
    term = os.environ.get("TERM", "")
    return bool(not term or term == "dumb")


def read_global_config_bool(var_name: str, default: bool = False) -> bool:
    """
    Read a boolean environment variable with support for .env files.

    Args:
        var_name: Name of the environment variable
        default: Default value if not found

    Returns:
        Boolean value of the environment variable
    """
    # Check environment variable directly
    value = os.environ.get(var_name)
    if value is not None:
        return value.lower() in ("true", "1", "yes", "on")

    # Check local .env file
    env_file = ".env"
    if os.path.exists(env_file):
        try:
            with open(env_file) as f:
                for line in f:
                    line = line.strip()
                    if line.startswith(f"{var_name}="):
                        value = line.split("=", 1)[1].strip()
                        return value.lower() in ("true", "1", "yes", "on")
        except OSError:
            pass

    # Check global .env file
    global_env_path = Path.home() / ".media-library-tools" / ".env"
    if global_env_path.exists():
        try:
            with open(global_env_path) as f:
                for line in f:
                    line = line.strip()
                    if line.startswith(f"{var_name}="):
                        value = line.split("=", 1)[1].strip()
                        return value.lower() in ("true", "1", "yes", "on")
        except OSError:
            pass

    return default


def is_windows() -> bool:
    """
    Detect if running on Windows platform.

    Returns:
        True if running on Windows, False otherwise
    """
    return platform.system().lower() == "windows"


def should_use_emojis() -> bool:
    """
    Determine if emojis should be used based on platform and environment.

    Returns:
        True if emojis should be used, False otherwise
    """
    # Don't use emojis on Windows to avoid encoding issues
    if is_windows():
        return False

    # Don't use emojis in non-interactive environments
    if is_non_interactive():
        return False

    # Check for explicit emoji suppression
    return not read_global_config_bool("NO_EMOJIS", False)


class FileLock:
    """
    File locking utility class for preventing concurrent executions.
    """

    def __init__(self, lock_prefix: str = "media_library_tool"):
        """
        Initialize file lock.

        Args:
            lock_prefix: Prefix for lock file name
        """
        self.lock_prefix = lock_prefix
        self.lock_file = None

    def acquire_lock(self, force: bool = False) -> bool:
        """
        Acquire file lock to prevent multiple instances.

        Args:
            force: If True, skip locking mechanism

        Returns:
            True if lock acquired successfully, False otherwise
        """
        if force:
            return True

        try:
            with tempfile.NamedTemporaryFile(
                mode="w", prefix=f"{self.lock_prefix}_", suffix=".lock", delete=False
            ) as temp_file:
                self.lock_file = temp_file
                
                # Platform-specific file locking
                if fcntl is not None:  # Unix/Linux/macOS
                    fcntl.flock(self.lock_file.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
                elif msvcrt is not None:  # Windows
                    msvcrt.locking(self.lock_file.fileno(), msvcrt.LK_NBLCK, 1)
                else:
                    # Fallback: no locking available, just proceed
                    pass
                    
                self.lock_file.write(str(os.getpid()))
                self.lock_file.flush()
            return True
        except (OSError, IOError) as e:
            if self.lock_file:
                self.lock_file.close()
                with contextlib.suppress(OSError):
                    os.unlink(self.lock_file.name)
                self.lock_file = None
            print(
                "Error: Another instance is already running. Use --force to override."
            )
            print(f"Lock error: {e}")
            return False

    def release_lock(self) -> None:
        """
        Release the file lock.
        """
        if self.lock_file:
            try:
                # Only unlock if file is still open
                if not self.lock_file.closed:
                    # Platform-specific file unlocking
                    if fcntl is not None:  # Unix/Linux/macOS
                        fcntl.flock(self.lock_file.fileno(), fcntl.LOCK_UN)
                    elif msvcrt is not None:  # Windows
                        msvcrt.locking(self.lock_file.fileno(), msvcrt.LK_UNLCK, 1)
                    # No explicit unlock needed for fallback case
                    
                    self.lock_file.close()
            except (OSError, ValueError, IOError):
                # Handle both file system errors and closed file errors
                pass

            # Always try to remove lock file if it exists
            try:
                if os.path.exists(self.lock_file.name):
                    os.unlink(self.lock_file.name)
            except OSError:
                pass
            finally:
                self.lock_file = None


# Legacy standalone functions for backward compatibility
def acquire_lock(
    lock_prefix: str = "media_library_tool", force: bool = False
) -> Tuple[bool, Optional[FileLock]]:
    """
    Legacy function for acquiring file locks.

    Args:
        lock_prefix: Prefix for lock file name
        force: If True, skip locking mechanism

    Returns:
        Tuple of (success: bool, lock_instance: FileLock or None)
    """
    lock = FileLock(lock_prefix)
    success = lock.acquire_lock(force)
    return success, lock if success else None


def release_lock(lock_instance: FileLock) -> None:
    """
    Legacy function for releasing file locks.

    Args:
        lock_instance: FileLock instance to release
    """
    if lock_instance:
        lock_instance.release_lock()

# ======================================================
# INJECTED MODULE - END
# Source: lib/core.py
# ======================================================


# ======================================================
# INJECTED MODULE - START
# Generated by build.py v3.0.0
# Source: lib/ui.py
# ======================================================

"""
User Interface Module for Media Library Tools
Version: 1.0

This module contains user interface functions including:
- Banner display and application branding
- Size formatting for human-readable output  
- User confirmation prompts

This is part of the modular library structure that enables selective inclusion
in built tools while maintaining the self-contained principle.
"""

import sys
from pathlib import Path

# Import dependencies from core module
try:
    from core import is_non_interactive, should_use_emojis
except ImportError:
    # Fallback for when core module is not available
    # This happens when modules are injected together during build
    def is_non_interactive():
        """Fallback implementation - will be overridden by injected core module"""
        return not sys.stdin.isatty()
    
    def should_use_emojis():
        """Fallback implementation - will be overridden by injected core module"""
        return sys.platform != "win32" and not is_non_interactive()


def display_banner(
    script_name: str,
    version: str,
    description: str,
    no_banner_flag: bool = False,
    quiet_mode: bool = False,
) -> None:
    """
    Display standardized banner for media library tools.

    Args:
        script_name: Name of the script
        version: Version string
        description: Brief description of the script
        no_banner_flag: If True, suppress banner display
        quiet_mode: If True, suppress banner display
    """
    # Check suppression conditions (highest to lowest priority)
    if no_banner_flag or quiet_mode or is_non_interactive():
        return

    try:
        # Display standardized ASCII art
        print("┏┳┓┏━╸╺┳┓╻┏━┓╻  ╻┏┓ ┏━┓┏━┓┏━┓╻ ╻╺┳╸┏━┓┏━┓╻  ┏━┓")
        print("┃┃┃┣╸  ┃┃┃┣━┫┃  ┃┣┻┓┣┳┛┣━┫┣┳┛┗┳┛ ┃ ┃ ┃┃ ┃┃  ┗━┓")
        print("╹ ╹┗━╸╺┻┛╹╹ ╹┗━╸╹┗━┛╹┗╸╹ ╹╹┗╸ ╹  ╹ ┗━┛┗━┛┗━╸┗━┛")
        print(f"{script_name} v{version}: {description}")
        print()  # Blank line for separation
    except Exception:
        # Banner display errors should not prevent script execution
        pass


def format_size(size_bytes: int) -> str:
    """
    Format size in bytes to human readable format.

    Args:
        size_bytes: Size in bytes

    Returns:
        Human readable size string
    """
    for unit in ["B", "K", "M", "G", "T"]:
        if size_bytes < 1024.0:
            if unit == "B":
                return f"{size_bytes:.0f}{unit}"
            else:
                return f"{size_bytes:.1f}{unit}"
        size_bytes /= 1024.0
    return f"{size_bytes:.1f}P"


def confirm_action(message: str, skip_confirmation: bool = False) -> bool:
    """
    Ask for user confirmation unless skipped.

    Args:
        message: Confirmation message to display
        skip_confirmation: If True, automatically confirm

    Returns:
        True if confirmed, False otherwise
    """
    if skip_confirmation:
        return True

    try:
        response = input(f"{message} (y/N): ").strip().lower()
        return response in ["y", "yes"]
    except (EOFError, KeyboardInterrupt):
        print("\nOperation cancelled.")
        return False


def format_status_message(
    message: str, emoji: str = "", fallback_prefix: str = ""
) -> str:
    """
    Format a status message with optional emoji or fallback prefix.

    Args:
        message: The message to format
        emoji: Emoji to use if emojis are supported
        fallback_prefix: Text prefix to use if emojis are not supported

    Returns:
        Formatted message string
    """
    if emoji and should_use_emojis():
        return f"{emoji} {message}"
    elif fallback_prefix:
        return f"{fallback_prefix}: {message}"
    else:
        return message


def display_item_list(items, title: str = None, numbered: bool = False, 
                     show_count: bool = True, indent: str = "  ") -> None:
    """
    Display a list of items with consistent formatting.
    
    Args:
        items: List of items to display (strings or objects with __str__)
        title: Optional title to display above the list
        numbered: Whether to number the items (default: False for bullet points)
        show_count: Whether to show total count in title (default: True)
        indent: Indentation string for list items (default: "  ")
    
    Example:
        display_item_list(['file1.mp4', 'file2.mkv'], 'Files to process', numbered=True)
        # Output:
        # Files to process (2):
        #   1. file1.mp4
        #   2. file2.mkv
    """
    if not items:
        if title:
            print(f"{title}: None found")
        return
    
    # Display title with optional count
    if title:
        count_text = f" ({len(items)})" if show_count else ""
        print(f"{title}{count_text}:")
    
    # Display items
    for i, item in enumerate(items, 1):
        if numbered:
            print(f"{indent}{i}. {item}")
        else:
            print(f"{indent}- {item}")


def display_summary_list(summary_data: dict, title: str = None) -> None:
    """
    Display a summary with categorized counts and totals.
    
    Args:
        summary_data: Dictionary with category names as keys and counts as values
        title: Optional title to display above the summary
    
    Example:
        display_summary_list({
            'Files processed': 15,
            'Files skipped': 3,
            'Errors encountered': 1
        }, 'Processing Summary')
        # Output:
        # Processing Summary:
        #   Files processed: 15
        #   Files skipped: 3
        #   Errors encountered: 1
    """
    if title:
        print(f"{title}:")
    
    # Find the longest key for alignment
    max_key_length = max(len(str(key)) for key in summary_data.keys()) if summary_data else 0
    
    for key, value in summary_data.items():
        print(f"  {str(key).ljust(max_key_length)}: {value}")


def display_progress_item(current: int, total: int, item_name: str, 
                         prefix: str = "Processing") -> None:
    """
    Display current progress for an item being processed.
    
    Args:
        current: Current item number (1-based)
        total: Total number of items
        item_name: Name of the current item being processed
        prefix: Prefix text (default: "Processing")
    
    Example:
        display_progress_item(3, 10, 'movie.mp4')
        # Output: [3/10] Processing: movie.mp4
    """
    print(f"[{current}/{total}] {prefix}: {item_name}")


def display_stats_table(stats: dict, title: str = None, 
                       value_formatter=None) -> None:
    """
    Display statistics in a formatted table with aligned columns.
    
    Args:
        stats: Dictionary with statistic names as keys and values
        title: Optional title to display above the table
        value_formatter: Optional function to format values (e.g., format_size for bytes)
    
    Example:
        display_stats_table({
            'Total files': 1250,
            'Total size': 15728640,
            'Average size': 12582
        }, 'File Statistics', format_size)
    """
    if not stats:
        return
    
    if title:
        print(f"\n{title}:")
    
    # Find the longest key for alignment
    max_key_length = max(len(str(key)) for key in stats.keys())
    
    for key, value in stats.items():
        formatted_value = value_formatter(value) if value_formatter else str(value)
        print(f"  {str(key).ljust(max_key_length)}: {formatted_value}")


def display_results_table(data: list, headers: list, title: str = None,
                         max_width: int = 80) -> None:
    """
    Display structured data in a formatted table with headers and proper alignment.
    
    Args:
        data: List of lists/tuples containing row data
        headers: List of column headers
        title: Optional title to display above the table
        max_width: Maximum width for the table (default: 80)
    
    Example:
        display_results_table([
            ['file1.mp4', '1.2 GB', 'Processed'],
            ['file2.mkv', '850 MB', 'Skipped']
        ], ['Filename', 'Size', 'Status'], 'Processing Results')
    """
    if not data or not headers:
        if title:
            print(f"{title}: No data to display")
        return
    
    if title:
        print(f"\n{title}:")
    
    # Calculate column widths
    col_widths = []
    for i, header in enumerate(headers):
        # Start with header width
        max_width_col = len(header)
        
        # Check data column widths
        for row in data:
            if i < len(row):
                max_width_col = max(max_width_col, len(str(row[i])))
        
        col_widths.append(min(max_width_col, max_width // len(headers)))
    
    # Print header
    header_row = "  " + " | ".join(header.ljust(col_widths[i]) for i, header in enumerate(headers))
    print(header_row)
    print("  " + "-" * (len(header_row) - 2))
    
    # Print data rows
    for row in data:
        formatted_row = []
        for i, cell in enumerate(row):
            if i < len(col_widths):
                cell_str = str(cell)
                if len(cell_str) > col_widths[i]:
                    cell_str = cell_str[:col_widths[i]-3] + "..."
                formatted_row.append(cell_str.ljust(col_widths[i]))
        
        print("  " + " | ".join(formatted_row))

# ======================================================
# INJECTED MODULE - END
# Source: lib/ui.py
# ======================================================









def get_plex_naming_convention():
    """
    Plex naming conventions for extras:
    - behind the scenes: movie-behindthescenes
    - deleted scenes: movie-deleted  
    - featurettes: movie-featurette
    - interviews: movie-interview
    - scenes: movie-scene
    - shorts: movie-short
    - trailers: movie-trailer
    - other: movie-other
    """
    return {
        'trailer': 'trailer',
        'behind the scenes': 'behindthescenes', 
        'deleted scene': 'deleted',
        'featurette': 'featurette',
        'interview': 'interview',
        'scene': 'scene',
        'short': 'short',
        'other': 'other'
    }




def categorize_file(filename: str) -> str:
    """Categorize file based on filename patterns.
    
    Args:
        filename: The filename to categorize
        
    Returns:
        Category string for the file type
    """
    filename_lower = filename.lower()
    
    # Define patterns for different categories
    patterns = {
        'deleted': ['deleted', 'cut', 'alternate', 'extended'],
        'featurette': ['featurette', 'behind', 'making', 'documentary', 'interview'],
        'trailer': ['trailer', 'teaser', 'preview'],
        'other': ['extra', 'bonus', 'special']
    }
    
    for category, keywords in patterns.items():
        if any(keyword in filename_lower for keyword in keywords):
            return category
    
    # Default to featurette if no specific category found
    return 'featurette'

def clean_title(filename: str) -> str:
    """Clean up the filename to extract a readable title.
    
    Args:
        filename: The filename to clean
        
    Returns:
        Cleaned title string
    """
    # Remove file extension
    title = os.path.splitext(filename)[0]
    
    # Remove common prefixes/suffixes
    title = re.sub(r'^(\d+[\s\-_]*)', '', title)  # Remove leading numbers
    title = re.sub(r'[\s\-_]*\d+$', '', title)    # Remove trailing numbers
    
    # Replace separators with spaces
    title = re.sub(r'[\-_\.]+', ' ', title)
    
    # Clean up multiple spaces
    title = re.sub(r'\s+', ' ', title).strip()
    
    return title

def generate_new_filename(original_filename: str, movie_name_clean: str, counter: int) -> str:
    """Generate new filename based on Plex conventions.
    
    Args:
        original_filename: Original filename
        movie_name_clean: Cleaned movie name for filename
        counter: Sequential counter for numbering
        
    Returns:
        New filename following Plex conventions
    """
    file_ext = Path(original_filename).suffix
    category = categorize_file(original_filename)
    
    # Get the naming convention for this category
    naming_conventions = get_plex_naming_convention()
    if category in naming_conventions:
        if counter == 1:
            new_name = f"{movie_name_clean}-{naming_conventions[category]}{file_ext}"
        else:
            new_name = f"{movie_name_clean}-{naming_conventions[category]}{counter:02d}{file_ext}"
    else:
        # Fallback naming
        if counter == 1:
            new_name = f"{movie_name_clean}-featurette{file_ext}"
        else:
            new_name = f"{movie_name_clean}-featurette{counter:02d}{file_ext}"
    
    return new_name

class PlexMovieSubdirRenamer:
    """Main class for renaming movie subdirectory files."""
    
    def __init__(self, dry_run: bool = False, force: bool = False, verbose: bool = False):
        self.dry_run = dry_run
        self.force = force
        self.verbose = verbose
        self.file_lock = FileLock('plex_movie_subdir_renamer')
        
        # Video file extensions
        self.video_extensions = {
            '.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v',
            '.mpg', '.mpeg', '.3gp', '.ogv', '.ts', '.m2ts', '.vob', '.divx',
            '.xvid', '.rm', '.rmvb', '.asf', '.f4v', '.m4p'
        }
    
    def is_video_file(self, file_path) -> bool:
        """Check if a file is a video file based on its extension.
        
        Args:
            file_path: Path to the file to check (str or Path object)
            
        Returns:
            True if file is a video file, False otherwise
        """
        if hasattr(file_path, 'suffix'):
            # Path object
            file_extension = file_path.suffix.lower()
        else:
            # String path
            import os
            file_extension = os.path.splitext(str(file_path))[1].lower()
        return file_extension in self.video_extensions
    
    def acquire_lock(self) -> bool:
        """Acquire file lock to prevent multiple instances."""
        return self.file_lock.acquire_lock(self.force)
    
    def release_lock(self) -> None:
        """Release the file lock."""
        self.file_lock.release_lock()
    
    def rename_featurettes(self, directory_path: str, movie_name: Optional[str] = None) -> bool:
        """Rename all files in the featurettes directory."""
        directory = Path(directory_path)
        
        if not directory.exists():
            print(format_status_message(f"Directory '{directory_path}' does not exist", "❌", "Error"))
            return False
        
        if not directory.is_dir():
            print(format_status_message(f"'{directory_path}' is not a directory", "❌", "Error"))
            return False
    
        # Auto-detect movie name if not provided
        if not movie_name:
            parent_dir = directory.parent.name
            # Extract movie name from parent directory (remove year and quality info)
            movie_match = re.match(r'^(.+?)\s*\(\d{4}\)', parent_dir)
            if movie_match:
                movie_name = movie_match.group(1).strip()
            else:
                # Fallback: use parent directory name, cleaned up
                movie_name = re.sub(r'\s*\[.*?\]', '', parent_dir)
                movie_name = re.sub(r'\s*\(\d{4}\)', '', movie_name).strip()
        
        # Remove special characters from movie name for filename
        movie_name_clean = re.sub(r'[^\w\s-]', '', movie_name)
        movie_name_clean = re.sub(r'\s+', '', movie_name_clean)  # Remove all spaces
        
        # Display processing information
        processing_info = {
            'Processing directory': str(directory),
            'Detected movie name': movie_name,
            'Clean movie name for files': movie_name_clean,
            'Mode': 'DRY RUN' if self.dry_run else 'RENAME FILES'
        }
        display_summary_list(processing_info, 'Processing Information')
        
        # Get all video files
        video_files = [f for f in directory.iterdir() 
                       if f.is_file() and f.suffix.lower() in self.video_extensions]
        
        if not video_files:
            print(format_status_message("No video files found in directory", "ℹ️", "Info"))
            return True
        
        # Sort files for consistent numbering
        video_files.sort(key=lambda x: x.name.lower())
        
        # Group by category for numbering
        category_counters = {}
        
        for video_file in video_files:
            category = categorize_file(video_file.name)
            category_counters[category] = category_counters.get(category, 0) + 1
            counter = category_counters[category]
            
            new_filename = generate_new_filename(
                video_file.name, 
                movie_name_clean, 
                counter
            )
            
            new_path = directory / new_filename
            
            # Display file processing information
            file_info = [
                f"'{video_file.name}' -> '{new_filename}'",
                f"Category: {category}"
            ]
            display_item_list(file_info, numbered=False)
            
            if not self.dry_run:
                try:
                    video_file.rename(new_path)
                    print(format_status_message("Renamed successfully", "✅", "SUCCESS"))
                except Exception as e:
                    print(format_status_message(f"Error renaming: {e}", "❌", "Error"))
                    return False
                print()
        
        return True



def validate_args(args):
    """Validate command line arguments."""
    # Read global configuration
    auto_execute = read_global_config_bool('AUTO_EXECUTE', False)
    auto_confirm = read_global_config_bool('AUTO_CONFIRM', False)
    quiet_mode = read_global_config_bool('QUIET_MODE', False)
    
    # Set quiet_mode as attribute for access elsewhere
    args.quiet_mode = quiet_mode
    
    # Apply global configuration (CLI arguments take precedence)
    if auto_execute and not args.execute:
        args.execute = True  # Set execute flag if AUTO_EXECUTE is set
    if auto_confirm and not args.yes:
        args.yes = True  # Set yes flag if AUTO_CONFIRM is set
    
    # Handle dry-run/execute logic
    if args.execute:
        dry_run_mode = False
    else:
        dry_run_mode = args.dry_run  # This is True by default
    
    # Validate arguments
    if not os.path.exists(args.directory):
        print(format_status_message(f"Directory '{args.directory}' does not exist", "❌", "Error"))
        sys.exit(1)
    
    if not os.path.isdir(args.directory):
        print(format_status_message(f"'{args.directory}' is not a directory", "❌", "Error"))
        sys.exit(1)
    
    return dry_run_mode

def handle_confirmation(args, dry_run_mode):
    """Handle user confirmation for the operation."""
    # Confirm action unless in dry-run mode or confirmation skipped
    if not dry_run_mode:
        if not confirm_action(
            f"Rename video files in '{args.directory}'?",
            args.yes or is_non_interactive()
        ):
            print(format_status_message("Operation cancelled", "❌", "Error"))
            sys.exit(0)

def handle_result(args, dry_run_mode, success):
    """Handle the result of the renaming operation."""
    if success:
        if dry_run_mode:
            print(format_status_message("Dry run completed successfully. Use --execute to make changes", "✅", "SUCCESS"))
        else:
            print(format_status_message("Video files renamed successfully!", "✅", "SUCCESS"))
    else:
        print(format_status_message("Operation failed. Check error messages above", "❌", "Error"))
        sys.exit(1)

def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Rename movie featurettes and extras according to Plex naming conventions",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Preview what would be renamed in current directory (dry-run mode, default)
  %(prog)s
  
  # Preview what would be renamed in specific directory (dry-run mode, default)
  %(prog)s "./Featurettes"
  
  # Actually rename files in current directory with confirmation
  %(prog)s --execute --movie-name "Movie Title"
  
  # Actually rename files in specific directory with confirmation
  %(prog)s "./Deleted Scenes" --execute --movie-name "Movie Title"
  
  # Rename files without confirmation (for automation)
  %(prog)s --execute -y
  
  # Rename files in specific directory without confirmation (for automation)
  %(prog)s "./Behind the Scenes" --execute -y

Cron Usage:
  # Run daily to rename movie extras (non-interactive)
  0 3 * * * /usr/local/bin/plex_movie_subdir_renamer "/movies/Featurettes" --execute -y
  

"""
    )
    
    parser.add_argument(
        "directory", 
        nargs='?',
        default='.',
        help="Directory containing video files to rename (default: current directory)"
    )
    parser.add_argument(
        "--movie-name", 
        help="Movie name (auto-detected from parent directory if not provided)"
    )
    parser.add_argument(
        "--dry-run", 
        action="store_true",
        default=True,
        help="Preview changes without modifying files (default: true)"
    )
    parser.add_argument(
        "--execute", 
        action="store_true", 
        help="Actually perform operations (overrides --dry-run)"
    )
    parser.add_argument(
        "-y", "--yes", 
        action="store_true", 
        help="Skip confirmation prompts (useful for automation/cron)"
    )
    parser.add_argument(
        "--force", 
        action="store_true", 
        help="Force execution even if another instance is running"
    )
    parser.add_argument(
        "--verbose", "-v", 
        action="store_true", 
        help="Enable verbose output for debugging"
    )
    parser.add_argument(
        "--debug", 
        action="store_true", 
        help="Enable debug output (implies --verbose)"
    )
    parser.add_argument(
        "--no-banner",
        action="store_true",
        help="Suppress banner display"
    )
    parser.add_argument(
        "--version", 
        action="version", 
        version=f"%(prog)s {VERSION}"
    )
    
    args = parser.parse_args()
    
    # Handle debug mode
    if args.debug:
        args.verbose = True
    
    # Validate arguments and get dry_run_mode
    dry_run_mode = validate_args(args)
    
    # Display banner
    display_banner("plex_movie_subdir_renamer", VERSION, 
                  "rename movie featurettes and extras according to Plex naming conventions",
                  args.no_banner, getattr(args, 'quiet_mode', False))
    
    # Display mode information
    mode_info = {
        'Mode': 'DRY-RUN (No changes will be made)' if dry_run_mode else 'EXECUTE (Files will be renamed)'
    }
    
    if args.debug:
        mode_info['Debug'] = 'ENABLED'
    elif args.verbose:
        mode_info['Verbose'] = 'ENABLED'
    
    display_summary_list(mode_info, 'Execution Mode')
    
    # Create renamer instance
    renamer = PlexMovieSubdirRenamer(
        dry_run=dry_run_mode,
        force=args.force,
        verbose=args.verbose
    )
    
    # Acquire lock
    if not renamer.acquire_lock():
        sys.exit(1)
    
    try:
        # Show what will be done
        if args.verbose:
            verbose_info = {
                'Directory': args.directory,
                'Movie name': args.movie_name or 'auto-detect',
                'Mode': 'DRY RUN' if dry_run_mode else 'EXECUTE'
            }
            display_summary_list(verbose_info, 'Operation Details')
        
        # Handle confirmation
        handle_confirmation(args, dry_run_mode)
        
        # Execute the renaming
        success = renamer.rename_featurettes(args.directory, args.movie_name)
        
        # Handle result
        handle_result(args, dry_run_mode, success)
            
    except KeyboardInterrupt:
        print(format_status_message("Operation cancelled by user", "❌", "Error"))
        sys.exit(1)
    except Exception as e:
        print(format_status_message(f"Unexpected error: {e}", "❌", "Error"))
        if args.debug:
            import traceback
            traceback.print_exc()
        sys.exit(1)
    finally:
        renamer.release_lock()

if __name__ == "__main__":
    main()
